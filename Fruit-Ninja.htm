<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Conditionals Slice Trainer (1–3)</title>
  <style>
    :root { color-scheme: light dark; }

    /* UI background removed (plain page background) */
    html, body { margin:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body{
      display:flex;
      background:#0b1020;
    }

    #wrap { position:relative; margin:auto; width:min(980px, 100vw); height:min(600px, 100vh); }

    canvas {
      width:100%; height:100%; display:block;
      border-radius:16px;
      background:#0b1020; /* fallback while image loads */
      box-shadow: 0 14px 40px rgba(0,0,0,0.35);
    }

    .hud {
      position:absolute; inset:12px 12px auto 12px;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding:10px 12px; border-radius:12px; backdrop-filter: blur(6px);
      background: rgba(0,0,0,0.40); color:#fff; font-weight:650; user-select:none;
      border:1px solid rgba(255,255,255,0.12);
    }
    .hud .pill { padding:6px 10px; border-radius:999px; background: rgba(255,255,255,0.12); }
    .hud .actions{
      margin-left:auto;
      display:flex;
      gap:8px;
      align-items:center;
    }
    .hud button {
      padding:8px 12px; border-radius:10px;
      border:1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.12);
      color:#fff; font-weight:750; cursor:pointer;
    }
    .hud button:hover { background: rgba(255,255,255,0.18); }

    .sentenceBar{
      position:absolute;
      top:64px;
      left:50%;
      transform:translateX(-50%);
      width:min(920px, calc(100% - 24px));
      padding:10px 12px;
      border-radius:12px;
      background: rgba(0,0,0,0.40);
      border:1px solid rgba(255,255,255,0.12);
      color:#fff;
      user-select:none;
      text-align:center;
    }
    .sentenceBar .meta{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center;
      opacity:0.92; font-size:12px; margin-bottom:6px;
      font-weight:700;
    }
    .sentenceBar .text{
      font-size:16px; line-height:1.35;
      font-weight:800; /* bold letters */
      letter-spacing:0.1px;
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
    }
    .sentenceBar .gap {
      display:inline-block;
      min-width:84px;
      padding:0 6px;
      border-bottom:2px solid rgba(255,255,255,0.60);
      font-weight:900;
      letter-spacing:0.2px;
    }
    .sentenceBar .inf { opacity:0.90; font-weight:750; font-size:13px; margin-left:6px; }
    .sentenceBar .filled { font-weight:900; }

    .centerMsg {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center;
      color:#fff; padding:24px; user-select:none; pointer-events:none;
    }
    .centerMsg .card {
      max-width:660px; background: rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.18);
      border-radius:16px; padding:18px; backdrop-filter: blur(8px);
    }
    .centerMsg h1 { margin:0 0 8px; font-size:22px; }
    .centerMsg p { margin:6px 0; opacity:0.92; line-height:1.35; }
    .small { font-size:12px; opacity:0.85; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c" width="980" height="600"></canvas>

    <div class="hud">
      <div class="pill">Score: <span id="score">0</span></div>
      <div class="pill">Lives: <span id="lives">3</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
      <div class="pill">Time: <span id="time">00:00</span></div>
      <div class="actions">
        <button id="btn" type="button">Start</button>
        <button id="muteBtn" type="button" aria-pressed="false">Sound: On</button>
      </div>
    </div>

    <div class="sentenceBar" id="sentenceBar">
      <div class="meta">
        <span id="condLabel">Conditional</span>
        <span>•</span>
        <span id="gapMeta"><span id="gapMetaPrefix">Slice gap</span> <b id="gapIndexWrap"><span id="gapIndex">1</span></b> <span id="gapMetaSuffix">of <b>2</b></span></span>
      </div>
      <div class="text" id="sentenceText"></div>
    </div>

    <div class="centerMsg" id="msg">
      <div class="card">
        <h1>Conditionals Slice Trainer (1–3)</h1>
        <p>Slice the correct verb form to fill each gap, in order (gap 1 → gap 2).</p>
        <p class="small">Mouse: click-and-hold + drag. Touch: drag. Wrong slice = lose a life. When all lives are lost, the example order is randomized.</p>
        <p class="small">
        </p>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  if (!ctx) return;

  // HUD
  const $score = document.getElementById("score");
  const $lives = document.getElementById("lives");
  const $best  = document.getElementById("best");
  const $time  = document.getElementById("time");
  const $btn   = document.getElementById("btn");
  const $muteBtn = document.getElementById("muteBtn");
  const $msg   = document.getElementById("msg");



  // ---------- Sound ----------
  let soundEnabled = (() => {
    try {
      const v = localStorage.getItem("sliceSoundEnabled");
      return (v === null) ? true : (v === "1");
    } catch (_){
      return true;
    }
  })();

  let audioCtx = null;
  function ensureAudioContext(){
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return null;
    if (!audioCtx) audioCtx = new AC();
    if (audioCtx.state === "suspended"){
      audioCtx.resume().catch(() => {});
    }
    return audioCtx;
  }

  function persistSoundSetting(){
    try { localStorage.setItem("sliceSoundEnabled", soundEnabled ? "1" : "0"); } catch (_) {}
  }

  function updateMuteButton(){
    if (!$muteBtn) return;
    $muteBtn.textContent = soundEnabled ? "Sound: On" : "Sound: Off";
    $muteBtn.setAttribute("aria-pressed", String(!soundEnabled));
  }

  function playSliceSfx(){
    if (!soundEnabled) return;
    const ac = ensureAudioContext();
    if (!ac) return;

    // "Slice" / "swish" built from filtered noise + a fast filter sweep.
    // Designed to sound airy (not like a clap).
    const t0 = ac.currentTime;
    const dur = 0.13;

    // White noise buffer
    const length = Math.max(1, Math.floor(ac.sampleRate * dur));
    const buf = ac.createBuffer(1, length, ac.sampleRate);
    const data = buf.getChannelData(0);

    // Shape the noise in-buffer with a smooth envelope (raised cosine)
    for (let i = 0; i < length; i++){
      const x = i / (length - 1);
      const env = 0.5 - 0.5 * Math.cos(Math.PI * x); // 0..1 smooth
      // Slightly emphasize the middle for an "air" whoosh
      const mid = 1 - Math.abs(2*x - 1);
      data[i] = (Math.random() * 2 - 1) * env * (0.7 + 0.3*mid);
    }

    const src = ac.createBufferSource();
    src.buffer = buf;

    // Filters: high-pass to remove low thump + band-pass with frequency sweep
    const hp = ac.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(700, t0);
    hp.Q.setValueAtTime(0.7, t0);

    const bp = ac.createBiquadFilter();
    bp.type = "bandpass";
    bp.Q.setValueAtTime(1.4, t0);
    bp.frequency.setValueAtTime(3200, t0);
    bp.frequency.exponentialRampToValueAtTime(950, t0 + dur);

    // Gain envelope (softer attack than a clap, quick decay)
    const g = ac.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.22, t0 + 0.015);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    // Slight stereo movement for a more natural swish
    const pan = (ac.createStereoPanner ? ac.createStereoPanner() : null);
    if (pan){
      const r = (Math.random() * 2 - 1) * 0.35;
      pan.pan.setValueAtTime(r, t0);
    }

    src.connect(hp);
    hp.connect(bp);
    if (pan){
      bp.connect(pan);
      pan.connect(g);
    } else {
      bp.connect(g);
    }
    g.connect(ac.destination);

    src.start(t0);
    src.stop(t0 + dur);
  }

  if ($muteBtn){
    updateMuteButton();
    $muteBtn.addEventListener("click", (e) => {
      e.preventDefault();
      soundEnabled = !soundEnabled;
      persistSoundSetting();
      updateMuteButton();
      if (soundEnabled) ensureAudioContext();
    });
  }

  const $sentenceText = document.getElementById("sentenceText");
  const $condLabel = document.getElementById("condLabel");
  const $gapIndex = document.getElementById("gapIndex");
  const $gapMeta  = document.getElementById("gapMeta");
  const $gapMetaPrefix = document.getElementById("gapMetaPrefix");
  const $gapIndexWrap  = document.getElementById("gapIndexWrap");
  const $gapMetaSuffix = document.getElementById("gapMetaSuffix");

  // Safe storage helpers
  const BEST_KEY = "cond_slice_best";
  function safeGetBest() {
    try {
      const v = localStorage.getItem(BEST_KEY);
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    } catch { return 0; }
  }
  function safeSetBest(v) {
    try { localStorage.setItem(BEST_KEY, String(v)); } catch { /* ignore */ }
  }

  // ---------- Background (in-game) ----------
  const bgImg = new Image();
  bgImg.src = "Fruit Ninja Images/Fruit Ninja_Game background.png";
  let bgReady = false;
  bgImg.onload = () => { bgReady = true; };

  function drawBackgroundCover() {
    if (!bgReady) return;
    const cw = state.W, ch = state.H;
    const iw = bgImg.naturalWidth || bgImg.width;
    const ih = bgImg.naturalHeight || bgImg.height;
    if (!iw || !ih) return;

    const scale = Math.max(cw / iw, ch / ih);
    const dw = iw * scale;
    const dh = ih * scale;
    const dx = (cw - dw) / 2;
    const dy = (ch - dh) / 2;

    ctx.drawImage(bgImg, dx, dy, dw, dh);
  }

  // ---------- Fruit images (with white background keyed out to transparency) ----------
  function loadImage(src) {
    const img = new Image();
    img.src = src;
    return img;
  }

  // Turn near-white pixels transparent once per image.
  function makeWhiteTransparent(img, threshold = 245) {
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    if (!iw || !ih) return null;

    const off = document.createElement("canvas");
    off.width = iw;
    off.height = ih;
    const octx = off.getContext("2d", { willReadFrequently: true });
    if (!octx) return null;

    octx.drawImage(img, 0, 0);
    const imd = octx.getImageData(0, 0, iw, ih);
    const d = imd.data;

    for (let i = 0; i < d.length; i += 4) {
      const r = d[i], g = d[i+1], b = d[i+2], a = d[i+3];
      if (a === 0) continue;

      // key out near-white
      if (r >= threshold && g >= threshold && b >= threshold) {
        d[i+3] = 0;
      }
    }
    octx.putImageData(imd, 0, 0);
    return off; // canvas usable as drawImage source
  }

  // Source images live in "Fruit Ninja Images/Fruits"
  const fruitSrc = {
    Apple:      "Fruit Ninja Images/Fruits/Apple.png",
    Orange:     "Fruit Ninja Images/Fruits/Orange.png",
    Pear:       "Fruit Ninja Images/Fruits/Pear.png",
    Grapes:     "Fruit Ninja Images/Fruits/Grapes.png",
    Tomato:     "Fruit Ninja Images/Fruits/Tomato.png",
    Watermelon: "Fruit Ninja Images/Fruits/Watermelon.png",
    Kiwi:       "Fruit Ninja Images/Fruits/Kiwi.png",
    Strawberry: "Fruit Ninja Images/Fruits/Strawberry.png",
  };

  const fruitRaw = {
    Apple:      loadImage(fruitSrc.Apple),
    Orange:     loadImage(fruitSrc.Orange),
    Pear:       loadImage(fruitSrc.Pear),
    Grapes:     loadImage(fruitSrc.Grapes),
    Tomato:     loadImage(fruitSrc.Tomato),
    Watermelon: loadImage(fruitSrc.Watermelon),
    Kiwi:       loadImage(fruitSrc.Kiwi),
    Strawberry: loadImage(fruitSrc.Strawberry),
  };

  // Processed (transparent) versions
  const fruitCut = {
    Apple: null, Orange: null, Pear: null, Grapes: null, Tomato: null, Watermelon: null, Kiwi: null, Strawberry: null
  };

  function hookTransparency(key) {
    const img = fruitRaw[key];
    img.onload = () => {
      fruitCut[key] = makeWhiteTransparent(img, 245);
    };
  }
  Object.keys(fruitRaw).forEach(hookTransparency);

  // Map tense category -> fruit
  // Simple present is split into:
  // - PRESENT_SIMPLE_BASE (I/you/we/they: no -s) -> Apple
  // - PRESENT_SIMPLE_3S   (he/she/it: -s / -es / -ies) -> Strawberry
  const FRUIT_BY_TENSE = {
    PRESENT_SIMPLE_BASE: { key:"Apple" },
    PRESENT_SIMPLE_3S:   { key:"Strawberry" },
    PAST_SIMPLE:         { key:"Orange" },
    PRESENT_PERFECT:     { key:"Pear" },
    PAST_PERFECT:        { key:"Grapes" },
    WILL:                { key:"Watermelon" },
    WOULD:               { key:"Tomato" },
    WOULD_HAVE:          { key:"Kiwi" },
    OTHER:               { key:"Orange" },
  };

  // Lightweight classifier based on verb form string (fits your option sets).
  function classifyTense(form){
    const s = String(form).trim().toLowerCase();

    // Complex / multi-word forms first
    if (s.startsWith("would have ") || s.startsWith("wouldn't have ")) return "WOULD_HAVE";
    if (s.startsWith("will ") || s.startsWith("won't ")) return "WILL";
    if (s.startsWith("had ") || s.startsWith("hadn't ")) return "PAST_PERFECT";
    if (s.startsWith("would ") || s.startsWith("wouldn't ")) return "WOULD";

    // Present perfect (include contractions)
    if (
      s.startsWith("have ") || s.startsWith("has ") ||
      s.startsWith("haven't ") || s.startsWith("hasn't ")
    ) return "PRESENT_PERFECT";

    // Past simple negation
    if (s.startsWith("didn't ")) return "PAST_SIMPLE";

    // Irregular past (single-word forms)
    const PAST_IRREG = new Set([
      "was","were",
      "went","came",
      "did","had",
      "wore","wrote","rode",
      "took","made","saw","left","found",
      "bought","brought",
      "caught","taught","thought",
      "knew","felt","spoke","said","told",
      "got","gave","kept","held","met","paid",
      "ran","sat","stood","slept",
      "grew","threw","flew",
      "ate","drank","drove",
      "froze","broke","chose",
      "won","lost","read"
    ]);
    if (PAST_IRREG.has(s)) return "PAST_SIMPLE";
    if (s.endsWith("ed")) return "PAST_SIMPLE";

    // Simple present split: base vs 3rd-person singular
    // Heuristic: for single-word forms only.
    if (!s.includes(" ")) {
      const THREE_S = new Set(["is","has","does"]);
      const BASE    = new Set(["am","are","have","do"]);

      if (THREE_S.has(s)) return "PRESENT_SIMPLE_3S";
      if (BASE.has(s)) return "PRESENT_SIMPLE_BASE";

      if (s.endsWith("ies")) return "PRESENT_SIMPLE_3S";
      if (s.endsWith("es"))  return "PRESENT_SIMPLE_3S";
      if (s.endsWith("s") && !s.endsWith("ss")) return "PRESENT_SIMPLE_3S";
    }

    return "PRESENT_SIMPLE_BASE";
  }

  // ---------- Option sanitization (prevents non-existent forms and enforces 3rd-person -s where required) ----------
  function baseFromInf(inf){
    // inf can be like "study" or "not rain"
    const s = String(inf).trim().toLowerCase();
    return s.startsWith("not ") ? s.slice(4).trim() : s;
  }

  function toThirdSingular(base){
    const b = String(base).trim().toLowerCase();
    if (!b) return b;
    // Minimal irregulars used in this dataset
    const irr = { be:"is", have:"has", do:"does" };
    if (irr[b]) return irr[b];

    if (b.endsWith("y") && !/[aeiou]y$/.test(b)) return b.slice(0,-1) + "ies";
    if (/(s|sh|ch|x|z|o)$/.test(b)) return b + "es";
    return b + "s";
  }

  function isThirdPersonSingularSubject(word){
    const w = String(word || "").trim().toLowerCase();
    if (!w) return false;
    if (w === "he" || w === "she" || w === "it") return true;
    if (w === "i" || w === "you" || w === "we" || w === "they") return false;
    // Heuristic for nouns: treat as singular unless it looks plural.
    return !w.endsWith("s");
  }

  function subjectWordFromPart(part){
    // Use last token in the part (e.g., "If the teacher" -> "teacher")
    const t = String(part || "").trim().toLowerCase();
    const m = t.match(/([a-z']+)\s*$/i);
    return m ? m[1] : "";
  }

  function inferV3(gap){
    // Derive the past participle from the correct form when auxiliaries are present.
    // Example: "had read" -> "read", "would have finished" -> "finished"
    const c = String(gap.correct || "").trim().toLowerCase();
    const toks = c.split(/\s+/);
    return toks.length >= 2 ? toks[toks.length-1] : "";
  }

  function sanitizeGapOptions(ex, gapIndex){
    const gap = ex.gaps[gapIndex];
    const base = baseFromInf(gap.inf);
    const v3 = inferV3(gap);

    const subjectWord = gapIndex === 0
      ? subjectWordFromPart(String(ex.parts[0] || "").replace(/^if\s+/i, ""))
      : subjectWordFromPart(ex.parts[1]);
    const enforce3sg = isThirdPersonSingularSubject(subjectWord);

    const out = [];
    const seen = new Set();

    function pushUnique(s){
      const key = String(s).toLowerCase();
      if (seen.has(key)) return;
      seen.add(key);
      out.push(String(s));
    }

    for (const raw of (gap.options || [])){
      let opt = String(raw).trim();
      if (!opt) continue;
      let s = opt.toLowerCase();

      // Enforce 3rd-person singular for simple present base forms in 3sg contexts.
      // Example: "If it ___" should not spawn "rain".
      if (enforce3sg && s === base) {
        opt = toThirdSingular(base);
        s = opt.toLowerCase();
      }

      // Reject non-forms like "would had ..."
      if (/^would\s+had\b/.test(s)) continue;

      // Validate auxiliary patterns against base/V3 when possible
      if (/^(will|won't)\s+/.test(s)) {
        const x = s.replace(/^(will|won't)\s+/, "");
        if (x !== base) continue;
        pushUnique(opt);
        continue;
      }
      if (/^(would|wouldn't)\s+have\s+/.test(s)) {
        const x = s.replace(/^(would|wouldn't)\s+have\s+/, "");
        if (v3 && x !== v3) continue;
        pushUnique(opt);
        continue;
      }
      if (/^(would|wouldn't)\s+/.test(s)) {
        const x = s.replace(/^(would|wouldn't)\s+/, "");
        if (x !== base) continue;
        pushUnique(opt);
        continue;
      }
      if (/^(have|haven't|has|hasn't)\s+/.test(s)) {
        const x = s.replace(/^(have|haven't|has|hasn't)\s+/, "");
        if (v3 && x !== v3) continue;
        pushUnique(opt);
        continue;
      }
      if (/^(had|hadn't)\s+/.test(s)) {
        const x = s.replace(/^(had|hadn't)\s+/, "");
        // Past perfect in this game is strictly had + V3 (reject e.g. "had reading", "had bring").
        if (v3) {
          if (x !== v3) continue;
        } else {
          if (x.endsWith("ing")) continue;
        }
        pushUnique(opt);
        continue;
      }
      if (/^didn't\s+/.test(s)) {
        const x = s.replace(/^didn't\s+/, "");
        if (x !== base) continue;
        pushUnique(opt);
        continue;
      }

      // Single-word forms are always allowed (they are real word forms), but de-duplicated.
      if (!/\s/.test(s)) {
        pushUnique(opt);
        continue;
      }

      // Anything else (unexpected multiword pattern) is dropped.
    }

    // Always ensure the correct form is included.
    pushUnique(gap.correct);

    // Safety fallback: if we filtered too aggressively, fall back to original options.
    if (out.length < 2) return Array.from(new Set([...(gap.options || []), gap.correct]));
    return out;
  }


  // ---------- Content: 30 examples (10 per conditional type), 2 gaps each ----------
  const EXAMPLES = [
    // Conditional 1
    { type: 1, parts: ["If you ", ", you ", "."],
      gaps: [
        { inf:"study", correct:"study", options:["study","studies","studied","will study","would study","had studied"] },
        { inf:"pass",  correct:"will pass", options:["will pass","pass","passes","passed","would pass","would have passed"] }
      ]
    },
    { type: 1, parts: ["If it ", ", we ", " inside."],
      gaps: [
        { inf:"rain", correct:"rains", options:["rains","rain","rained","will rain","would rain","has rained"] },
        { inf:"stay", correct:"will stay", options:["will stay","stay","stays","stayed","would stay","would have stayed"] }
      ]
    },
    { type: 1, parts: ["If she ", " early, she ", " the bus."],
      gaps: [
        { inf:"leave", correct:"leaves", options:["leaves","leave","left","will leave","would leave","has left"] },
        { inf:"catch", correct:"will catch", options:["will catch","catches","catch","caught","would catch","would have caught"] }
      ]
    },
    { type: 1, parts: ["If they ", " hard, they ", " the match."],
      gaps: [
        { inf:"train", correct:"train", options:["train","trains","trained","will train","would train","have trained"] },
        { inf:"win", correct:"will win", options:["will win","win","wins","won","would win","would have won"] }
      ]
    },
    { type: 1, parts: ["If I ", " enough money, I ", " a new phone."],
      gaps: [
        { inf:"save", correct:"save", options:["save","saves","saved","will save","would save","have saved"] },
        { inf:"buy", correct:"will buy", options:["will buy","buy","buys","bought","would buy","would have bought"] }
      ]
    },
    { type: 1, parts: ["If you ", " me now, I ", " you back later."],
      gaps: [
        { inf:"call", correct:"call", options:["call","calls","called","will call","would call","have called"] },
        { inf:"phone", correct:"will phone", options:["will phone","phone","phones","phoned","would phone","would have phoned"] }
      ]
    },
    { type: 1, parts: ["If he ", " this button, the computer ", "."],
      gaps: [
        { inf:"press", correct:"presses", options:["presses","press","pressed","will press","would press","has pressed"] },
        { inf:"restart", correct:"will restart", options:["will restart","restart","restarts","restarted","would restart","would have restarted"] }
      ]
    },
    { type: 1, parts: ["If we ", " the tickets today, we ", " a seat."],
      gaps: [
        { inf:"book", correct:"book", options:["book","books","booked","will book","would book","have booked"] },
        { inf:"get", correct:"will get", options:["will get","get","gets","got","would get","would have got"] }
      ]
    },
    { type: 1, parts: ["If the teacher ", ", the lesson ", " earlier."],
      gaps: [
        { inf:"arrive", correct:"arrives", options:["arrives","arrive","arrived","will arrive","would arrive","has arrived"] },
        { inf:"start", correct:"will start", options:["will start","start","starts","started","would start","would have started"] }
      ]
    },
    { type: 1, parts: ["If you ", " water to 100°C, it ", "."],
      gaps: [
        { inf:"heat", correct:"heat", options:["heat","heats","heated","will heat","would heat","have heated"] },
        { inf:"boil", correct:"will boil", options:["will boil","boil","boils","boiled","would boil","would have boiled"] }
      ]
    },

    // Conditional 2
    { type: 2, parts: ["If I ", " more time, I ", " French."],
      gaps: [
        { inf:"have", correct:"had", options:["had","have","has","will have","would have","had had"] },
        { inf:"learn", correct:"would learn", options:["would learn","learn","learns","learned","will learn","would have learned"] }
      ]
    },
    { type: 2, parts: ["If she ", " taller, she ", " basketball."],
      gaps: [
        { inf:"be", correct:"were", options:["were","was","is","will be","would be","had been"] },
        { inf:"play", correct:"would play", options:["would play","play","plays","played","will play","would have played"] }
      ]
    },
    { type: 2, parts: ["If we ", " a car, we ", " there faster."],
      gaps: [
        { inf:"own", correct:"owned", options:["owned","own","owns","will own","would own","had owned"] },
        { inf:"get", correct:"would get", options:["would get","get","gets","got","will get","would have got"] }
      ]
    },
    { type: 2, parts: ["If they ", " closer, we ", " them more often."],
      gaps: [
        { inf:"live", correct:"lived", options:["lived","live","lives","will live","would live","had lived"] },
        { inf:"visit", correct:"would visit", options:["would visit","visit","visits","visited","will visit","would have visited"] }
      ]
    },
    { type: 2, parts: ["If he ", " the answer, he ", " it."],
      gaps: [
        { inf:"know", correct:"knew", options:["knew","know","knows","will know","would know","had known"] },
        { inf:"tell", correct:"would tell", options:["would tell","tell","tells","told","will tell","would have told"] }
      ]
    },
    { type: 2, parts: ["If you ", " me, I ", " you."],
      gaps: [
        { inf:"ask", correct:"asked", options:["asked","ask","asks","will ask","would ask","had asked"] },
        { inf:"help", correct:"would help", options:["would help","help","helps","helped","will help","would have helped"] }
      ]
    },
    { type: 2, parts: ["If it ", " today, we ", " hiking."],
      gaps: [
        { inf:"not rain", correct:"didn't rain", options:["didn't rain","doesn't rain","won't rain","hadn't rained","didn't rained","wouldn't rain"] },
        { inf:"go", correct:"would go", options:["would go","go","goes","went","will go","would have gone"] }
      ]
    },
    { type: 2, parts: ["If I ", " you, I ", " that job."],
      gaps: [
        { inf:"be", correct:"were", options:["were","was","am","will be","would be","had been"] },
        { inf:"take", correct:"would take", options:["would take","take","takes","took","will take","would have taken"] }
      ]
    },
    { type: 2, parts: ["If we ", " the rules better, we ", " fewer mistakes."],
      gaps: [
        { inf:"understand", correct:"understood", options:["understood","understand","understands","will understand","would understand","had understood"] },
        { inf:"make", correct:"would make", options:["would make","make","makes","made","will make","would have made"] }
      ]
    },
    { type: 2, parts: ["If she ", " more confident, she ", " in class."],
      gaps: [
        { inf:"feel", correct:"felt", options:["felt","feel","feels","will feel","would feel","had felt"] },
        { inf:"speak", correct:"would speak", options:["would speak","speak","speaks","spoke","will speak","would have spoken"] }
      ]
    },

    // Conditional 3
    { type: 3, parts: ["If you ", " harder, you ", " the exam."],
      gaps: [
        { inf:"study", correct:"had studied", options:["had studied","studied","have studied","would study","will study","had study"] },
        { inf:"pass", correct:"would have passed", options:["would have passed","would pass","will have passed","passed","have passed","would had passed"] }
      ]
    },
    { type: 3, parts: ["If she ", " earlier, she ", " the bus."],
      gaps: [
        { inf:"leave", correct:"had left", options:["had left","left","has left","had leave","would leave","have left"] },
        { inf:"catch", correct:"would have caught", options:["would have caught","would catch","caught","will have caught","has caught","would had caught"] }
      ]
    },
    { type: 3, parts: ["If we ", " the map, we ", " lost."],
      gaps: [
        { inf:"bring", correct:"had brought", options:["had brought","brought","have brought","had bring","would bring","had brung"] },
        { inf:"not get", correct:"wouldn't have gotten", options:["wouldn't have gotten","didn't get","wouldn't get","won't get","hadn't gotten","wouldn't have got"] }
      ]
    },
    { type: 3, parts: ["If they ", " the warning, they ", " the problem."],
      gaps: [
        { inf:"listen", correct:"had listened", options:["had listened","listened","have listened","had listen","would listen","listens"] },
        { inf:"avoid", correct:"would have avoided", options:["would have avoided","would avoid","avoided","will have avoided","have avoided","would had avoided"] }
      ]
    },
    { type: 3, parts: ["If I ", " your email, I ", " sooner."],
      gaps: [
        { inf:"see", correct:"had seen", options:["had seen","saw","have seen","seen","had see","would see"] },
        { inf:"reply", correct:"would have replied", options:["would have replied","would reply","replied","will have replied","have replied","would had replied"] }
      ]
    },
    { type: 3, parts: ["If he ", " the key, we ", " inside."],
      gaps: [
        { inf:"find", correct:"had found", options:["had found","found","have found","had find","would find","finds"] },
        { inf:"get", correct:"would have gotten", options:["would have gotten","would get","got","will have gotten","have gotten","would had gotten"] }
      ]
    },
    { type: 3, parts: ["If it ", ", the match ", " cancelled."],
      gaps: [
        { inf:"not snow", correct:"hadn't snowed", options:["hadn't snowed","didn't snow","hasn't snowed","wouldn't snow","hadn't snow","didn't snowed"] },
        { inf:"not be", correct:"wouldn't have been", options:["wouldn't have been","wasn't","wouldn't be","won't be","hadn't been","wouldn't have be"] }
      ]
    },
    { type: 3, parts: ["If we ", " earlier, we ", " the traffic."],
      gaps: [
        { inf:"start", correct:"had started", options:["had started","started","have started","had start","would start","starts"] },
        { inf:"avoid", correct:"would have avoided", options:["would have avoided","would avoid","avoided","will have avoided","have avoided","would had avoided"] }
      ]
    },
    { type: 3, parts: ["If she ", " the instructions, she ", " the task."],
      gaps: [
        { inf:"read", correct:"had read", options:["had read","read","has read","had red","would read","had reading"] },
        { inf:"finish", correct:"would have finished", options:["would have finished","would finish","finished","will have finished","has finished","would had finished"] }
      ]
    },
    { type: 3, parts: ["If they ", " their seats, they ", " the flight."],
      gaps: [
        { inf:"book", correct:"had booked", options:["had booked","booked","have booked","had book","would book","books"] },
        { inf:"miss", correct:"wouldn't have missed", options:["wouldn't have missed","didn't miss","wouldn't miss","won't miss","hadn't missed","wouldn't have miss"] }
      ]
    },


    // --- Added: +10 examples per conditional type (now 20 each) ---

    // Conditional 1 (additional 10)
    { type: 1, parts: ["If you ", ", you ", "."],
      gaps: [
        { inf:"eat", correct:"eat", options:["eat","eats","ate","will eat","would eat","have eaten"] },
        { inf:"feel", correct:"will feel", options:["will feel","feel","feels","felt","would feel","would have felt"] }
      ]
    },
    { type: 1, parts: ["If the plants ", ", they ", "."],
      gaps: [
        { inf:"get", correct:"get", options:["get","gets","got","will get","would get","have gotten"] },
        { inf:"grow", correct:"will grow", options:["will grow","grow","grows","grew","would grow","would have grown"] }
      ]
    },
    { type: 1, parts: ["If my brother ", ", he ", "."],
      gaps: [
        { inf:"finish", correct:"finishes", options:["finishes","finish","finished","will finish","would finish","has finished"] },
        { inf:"join", correct:"will join", options:["will join","join","joins","joined","would join","would have joined"] }
      ]
    },
    { type: 1, parts: ["If we ", ", we ", "."],
      gaps: [
        { inf:"recycle", correct:"recycle", options:["recycle","recycles","recycled","will recycle","would recycle","have recycled"] },
        { inf:"reduce", correct:"will reduce", options:["will reduce","reduce","reduces","reduced","would reduce","would have reduced"] }
      ]
    },
    { type: 1, parts: ["If she ", ", she ", "."],
      gaps: [
        { inf:"wear", correct:"wears", options:["wears","wear","wore","will wear","would wear","has worn"] },
        { inf:"be", correct:"will be", options:["will be","am","is","was","would be","would have been"] }
      ]
    },
    { type: 1, parts: ["If the temperature ", ", water ", "."],
      gaps: [
        { inf:"drop", correct:"drops", options:["drops","drop","dropped","will drop","would drop","has dropped"] },
        { inf:"freeze", correct:"will freeze", options:["will freeze","freeze","freezes","froze","would freeze","would have frozen"] }
      ]
    },
    { type: 1, parts: ["If I ", ", I ", "."],
      gaps: [
        { inf:"miss", correct:"miss", options:["miss","misses","missed","will miss","would miss","have missed"] },
        { inf:"take", correct:"will take", options:["will take","take","takes","took","would take","would have taken"] }
      ]
    },
    { type: 1, parts: ["If you ", ", you ", " green."],
      gaps: [
        { inf:"mix", correct:"mix", options:["mix","mixes","mixed","will mix","would mix","have mixed"] },
        { inf:"get", correct:"will get", options:["will get","get","gets","got","would get","would have gotten"] }
      ]
    },
    { type: 1, parts: ["If he ", ", he ", " quickly."],
      gaps: [
        { inf:"practise", correct:"practises", options:["practises","practise","practised","will practise","would practise","has practised"] },
        { inf:"improve", correct:"will improve", options:["will improve","improve","improves","improved","would improve","would have improved"] }
      ]
    },
    { type: 1, parts: ["If they ", " today, we ", " it tomorrow."],
      gaps: [
        { inf:"send", correct:"send", options:["send","sends","sent","will send","would send","have sent"] },
        { inf:"review", correct:"will review", options:["will review","review","reviews","reviewed","would review","would have reviewed"] }
      ]
    },

    // Conditional 2 (additional 10)
    { type: 2, parts: ["If I ", ", I ", " around the world."],
      gaps: [
        { inf:"win", correct:"won", options:["won","win","wins","will win","would win","had won"] },
        { inf:"travel", correct:"would travel", options:["would travel","travel","travels","traveled","will travel","would have traveled"] }
      ]
    },
    { type: 2, parts: ["If she ", " Spanish, she ", " in Madrid."],
      gaps: [
        { inf:"speak", correct:"spoke", options:["spoke","speak","speaks","will speak","would speak","had spoken"] },
        { inf:"work", correct:"would work", options:["would work","work","works","worked","will work","would have worked"] }
      ]
    },
    { type: 2, parts: ["If we ", " a bigger classroom, we ", " more experiments."],
      gaps: [
        { inf:"have", correct:"had", options:["had","have","has","will have","would have","had had"] },
        { inf:"do", correct:"would do", options:["would do","do","does","did","will do","would have done"] }
      ]
    },
    { type: 2, parts: ["If he ", " more careful, he ", " accidents."],
      gaps: [
        { inf:"be", correct:"were", options:["were","was","is","will be","would be","had been"] },
        { inf:"avoid", correct:"would avoid", options:["would avoid","avoid","avoids","avoided","will avoid","would have avoided"] }
      ]
    },
    { type: 2, parts: ["If they ", " by the sea, they ", " every day."],
      gaps: [
        { inf:"live", correct:"lived", options:["lived","live","lives","will live","would live","had lived"] },
        { inf:"swim", correct:"would swim", options:["would swim","swim","swims","swam","will swim","would have swum"] }
      ]
    },
    { type: 2, parts: ["If you ", " less, you ", " more."],
      gaps: [
        { inf:"study", correct:"studied", options:["studied","study","studies","will study","would study","had studied"] },
        { inf:"sleep", correct:"would sleep", options:["would sleep","sleep","sleeps","slept","will sleep","would have slept"] }
      ]
    },
    { type: 2, parts: ["If I ", " her number, I ", " her."],
      gaps: [
        { inf:"know", correct:"knew", options:["knew","know","knows","will know","would know","had known"] },
        { inf:"call", correct:"would call", options:["would call","call","calls","called","will call","would have called"] }
      ]
    },
    { type: 2, parts: ["If the weather ", " warmer, we ", " outside."],
      gaps: [
        { inf:"be", correct:"were", options:["were","was","is","will be","would be","had been"] },
        { inf:"eat", correct:"would eat", options:["would eat","eat","eats","ate","will eat","would have eaten"] }
      ]
    },
    { type: 2, parts: ["If he ", " a bike, he ", " to school."],
      gaps: [
        { inf:"have", correct:"had", options:["had","have","has","will have","would have","had had"] },
        { inf:"cycle", correct:"would cycle", options:["would cycle","cycle","cycles","cycled","will cycle","would have cycled"] }
      ]
    },
    { type: 2, parts: ["If we ", " water, we ", " money."],
      gaps: [
        { inf:"not waste", correct:"didn't waste", options:["didn't waste","doesn't waste","won't waste","hadn't wasted","didn't wasted","wouldn't waste"] },
        { inf:"save", correct:"would save", options:["would save","save","saves","saved","will save","would have saved"] }
      ]
    },

    // Conditional 3 (additional 10)
    { type: 3, parts: ["If I ", " about the meeting, I ", "."],
      gaps: [
        { inf:"know", correct:"had known", options:["had known","knew","have known","had know","would know","knows"] },
        { inf:"come", correct:"would have come", options:["would have come","would come","came","will have come","have come","would had come"] }
      ]
    },
    { type: 3, parts: ["If she ", " the medicine, she ", "."],
      gaps: [
        { inf:"take", correct:"had taken", options:["had taken","took","have taken","had take","would take","takes"] },
        { inf:"recover", correct:"would have recovered", options:["would have recovered","would recover","recovered","will have recovered","has recovered","would had recovered"] }
      ]
    },
    { type: 3, parts: ["If we ", " the schedule, we ", " the delay."],
      gaps: [
        { inf:"check", correct:"had checked", options:["had checked","checked","have checked","had check","would check","checks"] },
        { inf:"avoid", correct:"would have avoided", options:["would have avoided","would avoid","avoided","will have avoided","have avoided","would had avoided"] }
      ]
    },
    { type: 3, parts: ["If they ", " to the teacher, they ", " the task."],
      gaps: [
        { inf:"listen", correct:"had listened", options:["had listened","listened","have listened","had listen","would listen","listens"] },
        { inf:"understand", correct:"would have understood", options:["would have understood","would understand","understood","will have understood","have understood","would had understood"] }
      ]
    },
    { type: 3, parts: ["If he ", " a coat, he ", " a cold."],
      gaps: [
        { inf:"wear", correct:"had worn", options:["had worn","wore","have worn","had wear","would wear","wears"] },
        { inf:"catch", correct:"wouldn't have caught", options:["wouldn't have caught","wouldn't catch","caught","will have caught","has caught","wouldn't have catch"] }
      ]
    },
    { type: 3, parts: ["If the scientists ", " the experiment, they ", " the results."],
      gaps: [
        { inf:"repeat", correct:"had repeated", options:["had repeated","repeated","have repeated","had repeat","would repeat","repeats"] },
        { inf:"confirm", correct:"would have confirmed", options:["would have confirmed","would confirm","confirmed","will have confirmed","have confirmed","would had confirmed"] }
      ]
    },
    { type: 3, parts: ["If you ", " the document, you ", " it."],
      gaps: [
        { inf:"save", correct:"had saved", options:["had saved","saved","have saved","had save","would save","saves"] },
        { inf:"lose", correct:"wouldn't have lost", options:["wouldn't have lost","wouldn't lose","lost","will have lost","have lost","wouldn't have lose"] }
      ]
    },
    { type: 3, parts: ["If she ", " on time, we ", " earlier."],
      gaps: [
        { inf:"arrive", correct:"had arrived", options:["had arrived","arrived","have arrived","had arrive","would arrive","arrives"] },
        { inf:"start", correct:"would have started", options:["would have started","would start","started","will have started","have started","would had started"] }
      ]
    },
    { type: 3, parts: ["If we ", " umbrellas, we ", " wet."],
      gaps: [
        { inf:"bring", correct:"had brought", options:["had brought","brought","have brought","had bring","would bring","brings"] },
        { inf:"get", correct:"wouldn't have gotten", options:["wouldn't have gotten","wouldn't get","got","will have gotten","have gotten","wouldn't have get"] }
      ]
    },
    { type: 3, parts: ["If they ", " more, they ", " better."],
      gaps: [
        { inf:"practice", correct:"had practiced", options:["had practiced","practiced","have practiced","had practice","would practice","practices"] },
        { inf:"play", correct:"would have played", options:["would have played","would play","played","will have played","have played","would had played"] }
      ]
    },
  ];

  // Pre-sanitize options so the game never spawns non-existent forms.
  EXAMPLES.forEach(ex => {
    ex.gaps.forEach((g, i) => {
      g.optionsClean = sanitizeGapOptions(ex, i);
    });
  });

  // ---------- Utilities ----------
  const rand  = (a,b) => a + Math.random()*(b-a);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  function shuffleInPlace(arr){
    for (let i = arr.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function fmtTime(seconds){
    const s = Math.max(0, Math.floor(seconds));
    const mm = String((s/60)|0).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    return `${mm}:${ss}`;
  }

  function segCircleHit(ax,ay,bx,by,cx,cy,r) {
    const abx = bx-ax, aby = by-ay;
    const acx = cx-ax, acy = cy-ay;
    const abLen2 = abx*abx + aby*aby || 1e-6;
    let t = (acx*abx + acy*aby) / abLen2;
    t = clamp(t, 0, 1);
    const px = ax + t*abx, py = ay + t*aby;
    return dist2(px,py,cx,cy) <= r*r;
  }

  function worldFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (("touches" in e) ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (("touches" in e) ? e.touches[0].clientY : e.clientY) - rect.top;
    return { x, y };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ---------- Game State ----------
  const state = {
    W: 980, H: 600,
    running:false,

    score:0,
    lives:3,
    best:safeGetBest(),

    // Timer counts up from 0
    timeElapsed: 0,

    order: [],
    examplePos: 0,
    gapPos: 0,
    filled: ["",""],

    fruits: [],
    particles: [],

    lastT:0,
    spawnTimer:0,
    spawnInterval:0.65,

    // Spawn pool ensures each option appears equally often per sentence gap
    spawnPoolKey: "",
    spawnPool: [],
    lastSpawnText: "",

    pointerDown:false,
    blade:[],
    bladeMax:14,

    flash: 0,
  };

  // ---------- Layout & HUD ----------
  function fitHiDPI() {
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(360, Math.floor(rect.width));
    const h = Math.max(320, Math.floor(rect.height));
    canvas.width  = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    state.W = w;
    state.H = h;
  }
  window.addEventListener("resize", fitHiDPI);

  function updateHUD(){
    $score.textContent = String(state.score);
    $lives.textContent = String(state.lives);
    $best.textContent  = String(state.best);
    $time.textContent  = fmtTime(state.timeElapsed);
  }

  function setMessageVisible(v, html) {
    if (html) $msg.querySelector(".card").innerHTML = html;
    $msg.classList.toggle("hidden", !v);
  }

  function condExplanation(type){
    if (type === 1){
      return {
        title: "First conditional (real / possible future)",
        form: "If + present simple, ... will + base verb",
        use: "Used for a realistic condition and its likely result in the future.",
        note: "The if-clause uses present simple even though the meaning is future."
      };
    }
    if (type === 2){
      return {
        title: "Second conditional (hypothetical present/future)",
        form: "If + past simple, ... would + base verb",
        use: "Used for unreal or unlikely situations in the present/future and their imagined results.",
        note: "‘Were’ is often used with all persons (If I were, If he/she/it were)."
      };
    }
    return {
      title: "Third conditional (unreal past)",
      form: "If + past perfect, ... would have + past participle",
      use: "Used to talk about a past condition that did not happen and its past result that also did not happen.",
      note: "Both clauses refer to the past; the outcome cannot be changed."
    };
  }

  function snapshotExample(ex){
    return {
      type: ex.type,
      parts: [ex.parts[0], ex.parts[1], ex.parts[2]],
      gaps: ex.gaps.map(g => ({ inf: g.inf, correct: g.correct }))
    };
  }

  function solvedSentenceHtml(snap){
    const full = `${snap.parts[0]}${snap.gaps[0].correct}${snap.parts[1]}${snap.gaps[1].correct}${snap.parts[2]}`;
    return escapeHtml(full);
  }
  function condLabel(type){
    if (type === 1) return "Conditional 1";
    if (type === 2) return "Conditional 2";
    return "Conditional 3";
  }

  function currentExample(){
    const idx = state.order[state.examplePos] ?? 0;
    return EXAMPLES[idx];
  }

  function renderSentence(){
    const ex = currentExample();

    if ($gapMetaPrefix) $gapMetaPrefix.textContent = "Slice gap";
    if ($gapIndexWrap) $gapIndexWrap.style.display = "";
    if ($gapMetaSuffix) $gapMetaSuffix.style.display = "";
$condLabel.textContent = condLabel(ex.type);
    $gapIndex.textContent = String(state.gapPos + 1);
const g0 = ex.gaps[0];
    const g1 = ex.gaps[1];

    const s0 = state.filled[0]
      ? `<span class="filled">${escapeHtml(state.filled[0])}</span>`
      : `<span class="gap">_____</span><span class="inf">(${escapeHtml(g0.inf)})</span>`;

    const s1 = state.filled[1]
      ? `<span class="filled">${escapeHtml(state.filled[1])}</span>`
      : `<span class="gap">_____</span><span class="inf">(${escapeHtml(g1.inf)})</span>`;

    $sentenceText.innerHTML = `${escapeHtml(ex.parts[0])}${s0}${escapeHtml(ex.parts[1])}${s1}${escapeHtml(ex.parts[2])}`;
  }

  // ---------- Fruit entities (word-bearing fruits) ----------
  const SIZE_MULT = 1.5; // +50% fruit + text size


  function resetSpawnPool(){
    state.spawnPoolKey = "";
    state.spawnPool.length = 0;
    state.lastSpawnText = "";
  }

  function ensureSpawnPool(){
    const exIdx = state.order[state.examplePos] ?? 0;
    const key = `${exIdx}:${state.gapPos}`;

    if (state.spawnPoolKey !== key){
      state.spawnPoolKey = key;
      state.spawnPool.length = 0;
    }

    if (state.spawnPool.length === 0){
      const ex = currentExample();
      const gap = ex.gaps[state.gapPos];
      const opts = gap.optionsClean || gap.options;

      // Build a balanced "bag": each option appears the same number of times.
      // This avoids long droughts where the needed option does not appear.
      const minPoolSize = 14; // ~9 seconds at 0.65s spawn interval
      const cycles = Math.max(3, Math.ceil(minPoolSize / Math.max(1, opts.length)));
      const pool = [];
      for (let i = 0; i < cycles; i++) pool.push(...opts);
      shuffleInPlace(pool);

      // Avoid the first spawn repeating the last one (when pools refill).
      if (pool.length > 1 && pool[0] === state.lastSpawnText){
        const j = pool.findIndex(v => v !== state.lastSpawnText);
        if (j > 0) [pool[0], pool[j]] = [pool[j], pool[0]];
      }

      state.spawnPool = pool;
    }
  }

  function nextSpawnText(){
    ensureSpawnPool();
    const t = state.spawnPool.pop();
    state.lastSpawnText = t;
    return t;
  }

  function spawnFruit(){
    const ex = currentExample();
    const gap = ex.gaps[state.gapPos];
    const opts = gap.optionsClean || gap.options;
    const text = nextSpawnText();

    const tenseKey = classifyTense(text);
    const map = FRUIT_BY_TENSE[tenseKey] || FRUIT_BY_TENSE.OTHER;

    const x = rand(state.W * 0.12, state.W * 0.88);
    const y = state.H + rand(30, 70);

    // Your chosen height settings:
    const vy = rand(-610, -450) * (state.H/600);

    const vx = rand(-28, 28);
    const g  = 420 * (state.H/600);

    // +50% size
    const baseR = clamp(30 + text.length * 1.2, 32, 60);
    const r = clamp(baseR * SIZE_MULT, 42, 90);

    state.fruits.push({
      text,
      tenseKey,
      fruitKey: map.key,

      x, y, r,
      vx, vy, g,

      rot: rand(-0.06, 0.06),
      spin: rand(-0.22, 0.22),

      dead:false,
      life:0
    });
  }

  function clearFruits(){ state.fruits.length = 0; }

  function addParticles(x,y,good){
    const n = good ? 14 : 20;
    for (let i=0;i<n;i++){
      const a = rand(0, Math.PI*2);
      const sp = rand(120, 520);
      state.particles.push({
        x,y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        g: 1400 * (state.H/600),
        r: rand(2,5),
        a: 1,
        good
      });
    }
  }

  function handleSliceFruit(f){
    if (f.dead) return;

    playSliceSfx();

    const ex = currentExample();
    const gap = ex.gaps[state.gapPos];

    if (f.text === gap.correct){
      f.dead = true;
      addParticles(f.x, f.y, true);

      state.score += 100;
      if (state.score > state.best){
        state.best = state.score;
        safeSetBest(state.best);
      }

      state.filled[state.gapPos] = gap.correct;

      // Enforce order: clear remaining fruits when you progress
      clearFruits();
      if (state.gapPos === 0){
        state.gapPos = 1;
      } else {
        state.gapPos = 0;
        state.filled = ["",""];
        state.examplePos++;
        if (state.examplePos >= state.order.length) state.examplePos = 0;
      }

      renderSentence();
      updateHUD();
      return;
    }

    // Wrong: lose a life
    f.dead = true;
    addParticles(f.x, f.y, false);

    state.lives -= 1;
    state.flash = 0.25;

    updateHUD();
    if (state.lives <= 0){
      gameOver(true, snapshotExample(ex));
    }
  }

  // ---------- Input / blade ----------
  function pushBladePoint(x,y){
    state.blade.push({ x, y, t: performance.now() });
    if (state.blade.length > state.bladeMax) state.blade.shift();
  }
  function clearBlade(){ state.blade.length = 0; }

  function handleMove(x,y){
    pushBladePoint(x,y);
    const n = state.blade.length;
    if (n < 2) return;
    const a = state.blade[n-2], b = state.blade[n-1];

    for (const f of state.fruits){
      if (f.dead) continue;
      if (segCircleHit(a.x,a.y,b.x,b.y,f.x,f.y,f.r * 0.95)){
        handleSliceFruit(f);
      }
    }
  }

  canvas.addEventListener("mousedown", (e) => {
    if (!state.running) return;
    state.pointerDown = true;
    const p = worldFromEvent(e);
    clearBlade();
    pushBladePoint(p.x,p.y);
  });
  window.addEventListener("mouseup", () => { state.pointerDown = false; });

  canvas.addEventListener("mousemove", (e) => {
    if (!state.running || !state.pointerDown) return;
    const p = worldFromEvent(e);
    handleMove(p.x,p.y);
  });

  canvas.addEventListener("touchstart", (e) => {
    if (!state.running) return;
    e.preventDefault();
    state.pointerDown = true;
    const p = worldFromEvent(e);
    clearBlade();
    pushBladePoint(p.x,p.y);
  }, { passive:false });

  canvas.addEventListener("touchmove", (e) => {
    if (!state.running || !state.pointerDown) return;
    e.preventDefault();
    const p = worldFromEvent(e);
    handleMove(p.x,p.y);
  }, { passive:false });

  canvas.addEventListener("touchend", () => { state.pointerDown = false; });

  // ---------- Game lifecycle ----------
  function buildNewOrder(){
    const idxs = EXAMPLES.map((_,i)=>i);
    shuffleInPlace(idxs);
    state.order = idxs;
    state.examplePos = 0;
    state.gapPos = 0;
    state.filled = ["",""];
  }

  function resetGame(){
    state.score = 0;
    state.lives = 3;
    state.timeElapsed = 0;

    state.spawnTimer = 0;
    state.spawnInterval = 0.65;

    state.fruits.length = 0;
    state.particles.length = 0;
    state.blade.length = 0;
    state.flash = 0;

    resetSpawnPool();

    updateHUD();
  }

  function startGame(){
    resetGame();
    buildNewOrder();
    renderSentence();

    state.running = true;
    $btn.textContent = "Restart";
    setMessageVisible(false);

    for (let i=0;i<3;i++) spawnFruit();
    draw();

    state.lastT = performance.now();
    requestAnimationFrame(loop);
  }

  function gameOver(shuffleBecauseLives, lastSnap){
    state.running = false;
    state.pointerDown = false;
    clearBlade();
    clearFruits();
    updateHUD();

    if (shuffleBecauseLives){
      buildNewOrder();
      // Do not overwrite the displayed solution sentence on game-over.
      if (!lastSnap) renderSentence();
    }

    setMessageVisible(true, (() => {
      let solutionBlock = "";
      if (lastSnap){
        const expl = condExplanation(lastSnap.type);
        // Freeze sentence bar to show the solved sentence (not the next randomized item)
        $condLabel.textContent = condLabel(lastSnap.type);
        $sentenceText.innerHTML = `<span class="filled">${solvedSentenceHtml(lastSnap)}</span>`;
        if ($gapMetaPrefix) $gapMetaPrefix.textContent = "Solution";
        if ($gapIndexWrap) $gapIndexWrap.style.display = "none";
        if ($gapMetaSuffix) $gapMetaSuffix.style.display = "none";

        solutionBlock = `
          <hr style="border:none;border-top:1px solid rgba(255,255,255,0.18);margin:12px 0">

          <p><b>Correct sentence:</b><br><span style="font-weight:850">${solvedSentenceHtml(lastSnap)}</span></p>
          <p><b>${escapeHtml(expl.title)}</b><br>
            <span class="small"><b>Form:</b> ${escapeHtml(expl.form)}<br>
            <b>Use:</b> ${escapeHtml(expl.use)}<br>
            <b>Note:</b> ${escapeHtml(expl.note)}</span>
          </p>
        `;
      }

      return `
        <h1>Round finished</h1>
        <p>${shuffleBecauseLives ? "You lost all lives." : "Stopped."}</p>
        ${solutionBlock}
        <p>Score: <b>${state.score}</b> &nbsp;&nbsp; Best: <b>${state.best}</b></p>
        <p class="small">Press “Restart” to play again.</p>
      `;
    })());
  }

  function loop(now){
    if (!state.running) return;

    const dt = Math.min(0.033, (now - state.lastT) / 1000);
    state.lastT = now;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // ---------- Update & physics ----------
  function update(dt){
    state.timeElapsed += dt;

    state.spawnTimer += dt;
    if (state.spawnTimer >= state.spawnInterval){
      state.spawnTimer = 0;
      const burst = (Math.random() < 0.18) ? 2 : 1;
      for (let i=0;i<burst;i++) spawnFruit();
    }

    for (const f of state.fruits){
      f.life += dt;

      f.vy += f.g * dt;
      f.x += f.vx * dt;
      f.y += f.vy * dt;
      f.rot += f.spin * dt;

      // hard top boundary: do not cross top edge
      if (f.y - f.r < 0){
        f.y = f.r;
        if (f.vy < 0) f.vy = 0;
      }

      // remove when off-screen bottom (no penalty)
      if (f.y - f.r > state.H + 260){
        f.dead = true;
      }

      // gentle side bounds
      if (f.x - f.r < 8) { f.x = 8 + f.r; f.vx *= -0.4; }
      if (f.x + f.r > state.W - 8) { f.x = state.W - 8 - f.r; f.vx *= -0.4; }
    }
    state.fruits = state.fruits.filter(f => !f.dead);

    for (const p of state.particles){
      p.vy += p.g * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.a -= dt * 1.3;
    }
    state.particles = state.particles.filter(p => p.a > 0);

    const tNow = performance.now();
    state.blade = state.blade.filter(pt => (tNow - pt.t) < 120);

    state.flash = Math.max(0, state.flash - dt);

    updateHUD();
  }

  // ---------- Rendering ----------
  function drawFruit(f){
    const cut = fruitCut[f.fruitKey]; // transparent (processed) canvas
    const raw = fruitRaw[f.fruitKey]; // fallback if not processed yet
    const r = f.r;

    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.rotate(f.rot);

    // shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.beginPath();
    ctx.ellipse(4, 6, r * 1.05, r * 0.68, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    const source = (cut && cut.width) ? cut : (raw && raw.complete ? raw : null);

    // draw fruit image (cover-fit into a square)
    if (source) {
      const iw = source.width;
      const ih = source.height;

      const target = r * 2.15; // slightly oversize
      const scale = Math.max(target / iw, target / ih);
      const dw = iw * scale;
      const dh = ih * scale;

      ctx.drawImage(source, -dw/2, -dh/2, dw, dh);
    } else {
      // fallback: simple circle
      ctx.fillStyle = "rgba(255,255,255,0.12)";
      ctx.beginPath();
      ctx.arc(0,0,r,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // text (bigger by +50% and with outline for readability)
    ctx.font = `900 ${Math.round(16 * SIZE_MULT)}px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const yText = 2;
    ctx.lineWidth = 6;
    ctx.strokeStyle = "rgba(0,0,0,0.50)";
    ctx.strokeText(f.text, 0, yText);
    ctx.fillStyle = "rgba(255,255,255,0.98)";
    ctx.fillText(f.text, 0, yText);

    ctx.restore();
  }

  function drawBlade(){
    const pts = state.blade;
    if (pts.length < 2) return;

    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    for (let i=1;i<pts.length;i++){
      const a = pts[i-1], b = pts[i];
      const alpha = i / pts.length;
      ctx.strokeStyle = `rgba(255,255,255,${0.10 + 0.55*alpha})`;
      ctx.lineWidth = 2 + 6*alpha;
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawParticles(){
    for (const p of state.particles){
      ctx.globalAlpha = clamp(p.a, 0, 1);
      ctx.fillStyle = p.good ? "rgba(120,255,170,0.95)" : "rgba(255,120,120,0.95)";
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function draw(){
    ctx.clearRect(0,0,state.W,state.H);

    // in-game background (cover)
    drawBackgroundCover();

    // slight dark overlay for contrast
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0,0,state.W,state.H);
    ctx.restore();

    drawParticles();
    for (const f of state.fruits) drawFruit(f);
    drawBlade();

    if (state.flash > 0){
      ctx.save();
      ctx.globalAlpha = clamp(state.flash / 0.25, 0, 1) * 0.18;
      ctx.fillStyle = "rgba(255,60,60,1)";
      ctx.fillRect(0,0,state.W,state.H);
      ctx.restore();
    }
  }

  // ---------- Button ----------
  $btn.addEventListener("click", (e) => {
    e.preventDefault();
    startGame();
  });

  // init
  fitHiDPI();
  updateMuteButton();
  $best.textContent = String(state.best);
  buildNewOrder();
  renderSentence();
  updateHUD();
})();
</script>
</body>
</html>
