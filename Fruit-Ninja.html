<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Conditionals Slice Trainer (1–3)</title>
  <style>
    :root { color-scheme: light dark; }

    /* UI background removed (plain page background) */
    html, body { margin:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body{
      display:flex;
      background:#0b1020;
    }

    #wrap { position:relative; margin:auto; width:min(980px, 100vw); height:min(600px, 100vh); }

    canvas {
      width:100%; height:100%; display:block;
      border-radius:16px;
      background:#0b1020; /* fallback while image loads */
      box-shadow: 0 14px 40px rgba(0,0,0,0.35);
    }

    .hud {
      position:absolute; inset:12px 12px auto 12px;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding:10px 12px; border-radius:12px; backdrop-filter: blur(6px);
      background: rgba(0,0,0,0.40); color:#fff; font-weight:650; user-select:none;
      border:1px solid rgba(255,255,255,0.12);
    }
    .hud .pill { padding:6px 10px; border-radius:999px; background: rgba(255,255,255,0.12); }
    .hud button {
      margin-left:auto;
      padding:8px 12px; border-radius:10px;
      border:1px solid rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.12);
      color:#fff; font-weight:750; cursor:pointer;
    }
    .hud button:hover { background: rgba(255,255,255,0.18); }

    .sentenceBar{
      position:absolute;
      top:64px;
      left:50%;
      transform:translateX(-50%);
      width:min(920px, calc(100% - 24px));
      padding:10px 12px;
      border-radius:12px;
      background: rgba(0,0,0,0.40);
      border:1px solid rgba(255,255,255,0.12);
      color:#fff;
      user-select:none;
      text-align:center;
    }
    .sentenceBar .meta{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center;
      opacity:0.92; font-size:12px; margin-bottom:6px;
      font-weight:700;
    }
    .sentenceBar .text{
      font-size:16px; line-height:1.35;
      font-weight:800; /* bold letters */
      letter-spacing:0.1px;
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
    }
    .sentenceBar .gap {
      display:inline-block;
      min-width:84px;
      padding:0 6px;
      border-bottom:2px solid rgba(255,255,255,0.60);
      font-weight:900;
      letter-spacing:0.2px;
    }
    .sentenceBar .inf { opacity:0.90; font-weight:750; font-size:13px; margin-left:6px; }
    .sentenceBar .filled { font-weight:900; }

    .centerMsg {
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center;
      color:#fff; padding:24px; user-select:none; pointer-events:none;
    }
    .centerMsg .card {
      max-width:660px; background: rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.18);
      border-radius:16px; padding:18px; backdrop-filter: blur(8px);
    }
    .centerMsg h1 { margin:0 0 8px; font-size:22px; }
    .centerMsg p { margin:6px 0; opacity:0.92; line-height:1.35; }
    .small { font-size:12px; opacity:0.85; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c" width="980" height="600"></canvas>

    <div class="hud">
      <div class="pill">Score: <span id="score">0</span></div>
      <div class="pill">Lives: <span id="lives">3</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
      <div class="pill">Time: <span id="time">00:00</span></div>
      <button id="btn" type="button">Start</button>
    </div>

    <div class="sentenceBar" id="sentenceBar">
      <div class="meta">
        <span id="condLabel">Conditional</span>
        <span>•</span>
        <span>Slice gap <b><span id="gapIndex">1</span></b> of <b>2</b></span>
      </div>
      <div class="text" id="sentenceText"></div>
    </div>

    <div class="centerMsg" id="msg">
      <div class="card">
        <h1>Conditionals Slice Trainer (1–3)</h1>
        <p>Slice the correct verb form to fill each gap, in order (gap 1 → gap 2).</p>
        <p class="small">Mouse: click-and-hold + drag. Touch: drag. Wrong slice = lose a life. When all lives are lost, the example order is randomized.</p>
        <p class="small">
        </p>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  if (!ctx) return;

  // HUD
  const $score = document.getElementById("score");
  const $lives = document.getElementById("lives");
  const $best  = document.getElementById("best");
  const $time  = document.getElementById("time");
  const $btn   = document.getElementById("btn");
  const $msg   = document.getElementById("msg");

  const $sentenceText = document.getElementById("sentenceText");
  const $condLabel = document.getElementById("condLabel");
  const $gapIndex = document.getElementById("gapIndex");

  // Safe storage helpers
  const BEST_KEY = "cond_slice_best";
  function safeGetBest() {
    try {
      const v = localStorage.getItem(BEST_KEY);
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    } catch { return 0; }
  }
  function safeSetBest(v) {
    try { localStorage.setItem(BEST_KEY, String(v)); } catch { /* ignore */ }
  }

  // ---------- Background (in-game) ----------
  const bgImg = new Image();
  bgImg.src = "Fruit Ninja_Game background.png";
  let bgReady = false;
  bgImg.onload = () => { bgReady = true; };

  function drawBackgroundCover() {
    if (!bgReady) return;
    const cw = state.W, ch = state.H;
    const iw = bgImg.naturalWidth || bgImg.width;
    const ih = bgImg.naturalHeight || bgImg.height;
    if (!iw || !ih) return;

    const scale = Math.max(cw / iw, ch / ih);
    const dw = iw * scale;
    const dh = ih * scale;
    const dx = (cw - dw) / 2;
    const dy = (ch - dh) / 2;

    ctx.drawImage(bgImg, dx, dy, dw, dh);
  }

  // ---------- Fruit images (with white background keyed out to transparency) ----------
  function loadImage(src) {
    const img = new Image();
    img.src = src;
    return img;
  }

  // Turn near-white pixels transparent once per image.
  function makeWhiteTransparent(img, threshold = 245) {
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    if (!iw || !ih) return null;

    const off = document.createElement("canvas");
    off.width = iw;
    off.height = ih;
    const octx = off.getContext("2d", { willReadFrequently: true });
    if (!octx) return null;

    octx.drawImage(img, 0, 0);
    const imd = octx.getImageData(0, 0, iw, ih);
    const d = imd.data;

    for (let i = 0; i < d.length; i += 4) {
      const r = d[i], g = d[i+1], b = d[i+2], a = d[i+3];
      if (a === 0) continue;

      // key out near-white
      if (r >= threshold && g >= threshold && b >= threshold) {
        d[i+3] = 0;
      }
    }
    octx.putImageData(imd, 0, 0);
    return off; // canvas usable as drawImage source
  }

  // Source images live in subfolder "Fruits"
  const fruitSrc = {
    Apple:      "Fruits/Apple.png",
    Orange:     "Fruits/Orange.png",
    Pear:       "Fruits/Pear.png",
    Grapes:     "Fruits/Grapes.png",
    Tomato:     "Fruits/Tomato.png",
    Watermelon: "Fruits/Watermelon.png",
    Kiwi:       "Fruits/Kiwi.png",
  };

  const fruitRaw = {
    Apple:      loadImage(fruitSrc.Apple),
    Orange:     loadImage(fruitSrc.Orange),
    Pear:       loadImage(fruitSrc.Pear),
    Grapes:     loadImage(fruitSrc.Grapes),
    Tomato:     loadImage(fruitSrc.Tomato),
    Watermelon: loadImage(fruitSrc.Watermelon),
    Kiwi:       loadImage(fruitSrc.Kiwi),
  };

  // Processed (transparent) versions
  const fruitCut = {
    Apple: null, Orange: null, Pear: null, Grapes: null, Tomato: null, Watermelon: null, Kiwi: null
  };

  function hookTransparency(key) {
    const img = fruitRaw[key];
    img.onload = () => {
      fruitCut[key] = makeWhiteTransparent(img, 245);
    };
  }
  Object.keys(fruitRaw).forEach(hookTransparency);

  // Map tense category -> fruit (simple present = apple as requested)
  const FRUIT_BY_TENSE = {
    PRESENT_SIMPLE:  { key:"Apple" },
    PAST_SIMPLE:     { key:"Orange" },
    PRESENT_PERFECT: { key:"Pear" },
    PAST_PERFECT:    { key:"Grapes" },
    WILL:            { key:"Watermelon" },
    WOULD:           { key:"Tomato" },
    WOULD_HAVE:      { key:"Kiwi" },
    OTHER:           { key:"Orange" },
  };

  // Lightweight classifier based on verb form string (fits your option sets).
  function classifyTense(form){
    const s = String(form).trim().toLowerCase();

    if (s.startsWith("would have ") || s.startsWith("wouldn't have ")) return "WOULD_HAVE";
    if (s.startsWith("will ") || s.startsWith("won't ")) return "WILL";
    if (s.startsWith("had ") || s.startsWith("hadn't ")) return "PAST_PERFECT";
    if (s.startsWith("would ") || s.startsWith("wouldn't ")) return "WOULD";

    if (s.startsWith("have ") || s.startsWith("has ")) return "PRESENT_PERFECT";
    if (s.startsWith("didn't ")) return "PAST_SIMPLE";

    const PAST_IRREG = new Set([
      "was","were","had","knew","felt","spoke","took","made","saw","left","found","brought","read","went","got","caught","won"
    ]);
    if (PAST_IRREG.has(s)) return "PAST_SIMPLE";
    if (s.endsWith("ed")) return "PAST_SIMPLE";

    return "PRESENT_SIMPLE";
  }

  // ---------- Content: 30 examples (10 per conditional type), 2 gaps each ----------
  const EXAMPLES = [
    // Conditional 1
    { type: 1, parts: ["If you ", ", you ", "."],
      gaps: [
        { inf:"study", correct:"study", options:["study","studies","studied","will study","would study","had studied"] },
        { inf:"pass",  correct:"will pass", options:["will pass","pass","passes","passed","would pass","would have passed"] }
      ]
    },
    { type: 1, parts: ["If it ", ", we ", " inside."],
      gaps: [
        { inf:"rain", correct:"rains", options:["rains","rain","rained","will rain","would rain","has rained"] },
        { inf:"stay", correct:"will stay", options:["will stay","stay","stays","stayed","would stay","would have stayed"] }
      ]
    },
    { type: 1, parts: ["If she ", " early, she ", " the bus."],
      gaps: [
        { inf:"leave", correct:"leaves", options:["leaves","leave","left","will leave","would leave","has left"] },
        { inf:"catch", correct:"will catch", options:["will catch","catches","catch","caught","would catch","would have caught"] }
      ]
    },
    { type: 1, parts: ["If they ", " hard, they ", " the match."],
      gaps: [
        { inf:"train", correct:"train", options:["train","trains","trained","will train","would train","have trained"] },
        { inf:"win", correct:"will win", options:["will win","win","wins","won","would win","would have won"] }
      ]
    },
    { type: 1, parts: ["If I ", " enough money, I ", " a new phone."],
      gaps: [
        { inf:"save", correct:"save", options:["save","saves","saved","will save","would save","have saved"] },
        { inf:"buy", correct:"will buy", options:["will buy","buy","buys","bought","would buy","would have bought"] }
      ]
    },
    { type: 1, parts: ["If you ", " me now, I ", " you back later."],
      gaps: [
        { inf:"call", correct:"call", options:["call","calls","called","will call","would call","have called"] },
        { inf:"phone", correct:"will phone", options:["will phone","phone","phones","phoned","would phone","would have phoned"] }
      ]
    },
    { type: 1, parts: ["If he ", " this button, the computer ", "."],
      gaps: [
        { inf:"press", correct:"presses", options:["presses","press","pressed","will press","would press","has pressed"] },
        { inf:"restart", correct:"will restart", options:["will restart","restart","restarts","restarted","would restart","would have restarted"] }
      ]
    },
    { type: 1, parts: ["If we ", " the tickets today, we ", " a seat."],
      gaps: [
        { inf:"book", correct:"book", options:["book","books","booked","will book","would book","have booked"] },
        { inf:"get", correct:"will get", options:["will get","get","gets","got","would get","would have got"] }
      ]
    },
    { type: 1, parts: ["If the teacher ", ", the lesson ", " earlier."],
      gaps: [
        { inf:"arrive", correct:"arrives", options:["arrives","arrive","arrived","will arrive","would arrive","has arrived"] },
        { inf:"start", correct:"will start", options:["will start","start","starts","started","would start","would have started"] }
      ]
    },
    { type: 1, parts: ["If you ", " water to 100°C, it ", "."],
      gaps: [
        { inf:"heat", correct:"heat", options:["heat","heats","heated","will heat","would heat","have heated"] },
        { inf:"boil", correct:"will boil", options:["will boil","boil","boils","boiled","would boil","would have boiled"] }
      ]
    },

    // Conditional 2
    { type: 2, parts: ["If I ", " more time, I ", " French."],
      gaps: [
        { inf:"have", correct:"had", options:["had","have","has","will have","would have","had had"] },
        { inf:"learn", correct:"would learn", options:["would learn","learn","learns","learned","will learn","would have learned"] }
      ]
    },
    { type: 2, parts: ["If she ", " taller, she ", " basketball."],
      gaps: [
        { inf:"be", correct:"were", options:["were","was","is","will be","would be","had been"] },
        { inf:"play", correct:"would play", options:["would play","play","plays","played","will play","would have played"] }
      ]
    },
    { type: 2, parts: ["If we ", " a car, we ", " there faster."],
      gaps: [
        { inf:"own", correct:"owned", options:["owned","own","owns","will own","would own","had owned"] },
        { inf:"get", correct:"would get", options:["would get","get","gets","got","will get","would have got"] }
      ]
    },
    { type: 2, parts: ["If they ", " closer, we ", " them more often."],
      gaps: [
        { inf:"live", correct:"lived", options:["lived","live","lives","will live","would live","had lived"] },
        { inf:"visit", correct:"would visit", options:["would visit","visit","visits","visited","will visit","would have visited"] }
      ]
    },
    { type: 2, parts: ["If he ", " the answer, he ", " it."],
      gaps: [
        { inf:"know", correct:"knew", options:["knew","know","knows","will know","would know","had known"] },
        { inf:"tell", correct:"would tell", options:["would tell","tell","tells","told","will tell","would have told"] }
      ]
    },
    { type: 2, parts: ["If you ", " me, I ", " you."],
      gaps: [
        { inf:"ask", correct:"asked", options:["asked","ask","asks","will ask","would ask","had asked"] },
        { inf:"help", correct:"would help", options:["would help","help","helps","helped","will help","would have helped"] }
      ]
    },
    { type: 2, parts: ["If it ", " today, we ", " hiking."],
      gaps: [
        { inf:"not rain", correct:"didn't rain", options:["didn't rain","doesn't rain","won't rain","hadn't rained","didn't rained","wouldn't rain"] },
        { inf:"go", correct:"would go", options:["would go","go","goes","went","will go","would have gone"] }
      ]
    },
    { type: 2, parts: ["If I ", " you, I ", " that job."],
      gaps: [
        { inf:"be", correct:"were", options:["were","was","am","will be","would be","had been"] },
        { inf:"take", correct:"would take", options:["would take","take","takes","took","will take","would have taken"] }
      ]
    },
    { type: 2, parts: ["If we ", " the rules better, we ", " fewer mistakes."],
      gaps: [
        { inf:"understand", correct:"understood", options:["understood","understand","understands","will understand","would understand","had understood"] },
        { inf:"make", correct:"would make", options:["would make","make","makes","made","will make","would have made"] }
      ]
    },
    { type: 2, parts: ["If she ", " more confident, she ", " in class."],
      gaps: [
        { inf:"feel", correct:"felt", options:["felt","feel","feels","will feel","would feel","had felt"] },
        { inf:"speak", correct:"would speak", options:["would speak","speak","speaks","spoke","will speak","would have spoken"] }
      ]
    },

    // Conditional 3
    { type: 3, parts: ["If you ", " harder, you ", " the exam."],
      gaps: [
        { inf:"study", correct:"had studied", options:["had studied","studied","have studied","would study","will study","had study"] },
        { inf:"pass", correct:"would have passed", options:["would have passed","would pass","will have passed","passed","have passed","would had passed"] }
      ]
    },
    { type: 3, parts: ["If she ", " earlier, she ", " the bus."],
      gaps: [
        { inf:"leave", correct:"had left", options:["had left","left","has left","had leave","would leave","have left"] },
        { inf:"catch", correct:"would have caught", options:["would have caught","would catch","caught","will have caught","has caught","would had caught"] }
      ]
    },
    { type: 3, parts: ["If we ", " the map, we ", " lost."],
      gaps: [
        { inf:"bring", correct:"had brought", options:["had brought","brought","have brought","had bring","would bring","had brung"] },
        { inf:"not get", correct:"wouldn't have gotten", options:["wouldn't have gotten","didn't get","wouldn't get","won't get","hadn't gotten","wouldn't have got"] }
      ]
    },
    { type: 3, parts: ["If they ", " the warning, they ", " the problem."],
      gaps: [
        { inf:"listen", correct:"had listened", options:["had listened","listened","have listened","had listen","would listen","listens"] },
        { inf:"avoid", correct:"would have avoided", options:["would have avoided","would avoid","avoided","will have avoided","have avoided","would had avoided"] }
      ]
    },
    { type: 3, parts: ["If I ", " your email, I ", " sooner."],
      gaps: [
        { inf:"see", correct:"had seen", options:["had seen","saw","have seen","seen","had see","would see"] },
        { inf:"reply", correct:"would have replied", options:["would have replied","would reply","replied","will have replied","have replied","would had replied"] }
      ]
    },
    { type: 3, parts: ["If he ", " the key, we ", " inside."],
      gaps: [
        { inf:"find", correct:"had found", options:["had found","found","have found","had find","would find","finds"] },
        { inf:"get", correct:"would have gotten", options:["would have gotten","would get","got","will have gotten","have gotten","would had gotten"] }
      ]
    },
    { type: 3, parts: ["If it ", ", the match ", " cancelled."],
      gaps: [
        { inf:"not snow", correct:"hadn't snowed", options:["hadn't snowed","didn't snow","hasn't snowed","wouldn't snow","hadn't snow","didn't snowed"] },
        { inf:"not be", correct:"wouldn't have been", options:["wouldn't have been","wasn't","wouldn't be","won't be","hadn't been","wouldn't have be"] }
      ]
    },
    { type: 3, parts: ["If we ", " earlier, we ", " the traffic."],
      gaps: [
        { inf:"start", correct:"had started", options:["had started","started","have started","had start","would start","starts"] },
        { inf:"avoid", correct:"would have avoided", options:["would have avoided","would avoid","avoided","will have avoided","have avoided","would had avoided"] }
      ]
    },
    { type: 3, parts: ["If she ", " the instructions, she ", " the task."],
      gaps: [
        { inf:"read", correct:"had read", options:["had read","read","has read","had red","would read","had reading"] },
        { inf:"finish", correct:"would have finished", options:["would have finished","would finish","finished","will have finished","has finished","would had finished"] }
      ]
    },
    { type: 3, parts: ["If they ", " their seats, they ", " the flight."],
      gaps: [
        { inf:"book", correct:"had booked", options:["had booked","booked","have booked","had book","would book","books"] },
        { inf:"miss", correct:"wouldn't have missed", options:["wouldn't have missed","didn't miss","wouldn't miss","won't miss","hadn't missed","wouldn't have miss"] }
      ]
    },
  ];

  // ---------- Utilities ----------
  const rand  = (a,b) => a + Math.random()*(b-a);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  function shuffleInPlace(arr){
    for (let i = arr.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function fmtTime(seconds){
    const s = Math.max(0, Math.floor(seconds));
    const mm = String((s/60)|0).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    return `${mm}:${ss}`;
  }

  function segCircleHit(ax,ay,bx,by,cx,cy,r) {
    const abx = bx-ax, aby = by-ay;
    const acx = cx-ax, acy = cy-ay;
    const abLen2 = abx*abx + aby*aby || 1e-6;
    let t = (acx*abx + acy*aby) / abLen2;
    t = clamp(t, 0, 1);
    const px = ax + t*abx, py = ay + t*aby;
    return dist2(px,py,cx,cy) <= r*r;
  }

  function worldFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (("touches" in e) ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (("touches" in e) ? e.touches[0].clientY : e.clientY) - rect.top;
    return { x, y };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ---------- Game State ----------
  const state = {
    W: 980, H: 600,
    running:false,

    score:0,
    lives:3,
    best:safeGetBest(),

    // Timer counts up from 0
    timeElapsed: 0,

    order: [],
    examplePos: 0,
    gapPos: 0,
    filled: ["",""],

    fruits: [],
    particles: [],

    lastT:0,
    spawnTimer:0,
    spawnInterval:0.65,

    pointerDown:false,
    blade:[],
    bladeMax:14,

    flash: 0,
  };

  // ---------- Layout & HUD ----------
  function fitHiDPI() {
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(360, Math.floor(rect.width));
    const h = Math.max(320, Math.floor(rect.height));
    canvas.width  = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    state.W = w;
    state.H = h;
  }
  window.addEventListener("resize", fitHiDPI);

  function updateHUD(){
    $score.textContent = String(state.score);
    $lives.textContent = String(state.lives);
    $best.textContent  = String(state.best);
    $time.textContent  = fmtTime(state.timeElapsed);
  }

  function setMessageVisible(v, html) {
    if (html) $msg.querySelector(".card").innerHTML = html;
    $msg.classList.toggle("hidden", !v);
  }

  function condLabel(type){
    if (type === 1) return "Conditional 1";
    if (type === 2) return "Conditional 2";
    return "Conditional 3";
  }

  function currentExample(){
    const idx = state.order[state.examplePos] ?? 0;
    return EXAMPLES[idx];
  }

  function renderSentence(){
    const ex = currentExample();
    $condLabel.textContent = condLabel(ex.type);
    $gapIndex.textContent = String(state.gapPos + 1);

    const g0 = ex.gaps[0];
    const g1 = ex.gaps[1];

    const s0 = state.filled[0]
      ? `<span class="filled">${escapeHtml(state.filled[0])}</span>`
      : `<span class="gap">_____</span><span class="inf">(${escapeHtml(g0.inf)})</span>`;

    const s1 = state.filled[1]
      ? `<span class="filled">${escapeHtml(state.filled[1])}</span>`
      : `<span class="gap">_____</span><span class="inf">(${escapeHtml(g1.inf)})</span>`;

    $sentenceText.innerHTML = `${escapeHtml(ex.parts[0])}${s0}${escapeHtml(ex.parts[1])}${s1}${escapeHtml(ex.parts[2])}`;
  }

  // ---------- Fruit entities (word-bearing fruits) ----------
  const SIZE_MULT = 1.5; // +50% fruit + text size

  function spawnFruit(){
    const ex = currentExample();
    const gap = ex.gaps[state.gapPos];
    const text = gap.options[(Math.random()*gap.options.length)|0];

    const tenseKey = classifyTense(text);
    const map = FRUIT_BY_TENSE[tenseKey] || FRUIT_BY_TENSE.OTHER;

    const x = rand(state.W * 0.12, state.W * 0.88);
    const y = state.H + rand(30, 70);

    // Your chosen height settings:
    const vy = rand(-610, -450) * (state.H/600);

    const vx = rand(-28, 28);
    const g  = 420 * (state.H/600);

    // +50% size
    const baseR = clamp(30 + text.length * 1.2, 32, 60);
    const r = clamp(baseR * SIZE_MULT, 42, 90);

    state.fruits.push({
      text,
      tenseKey,
      fruitKey: map.key,

      x, y, r,
      vx, vy, g,

      rot: rand(-0.06, 0.06),
      spin: rand(-0.22, 0.22),

      dead:false,
      life:0
    });
  }

  function clearFruits(){ state.fruits.length = 0; }

  function addParticles(x,y,good){
    const n = good ? 14 : 20;
    for (let i=0;i<n;i++){
      const a = rand(0, Math.PI*2);
      const sp = rand(120, 520);
      state.particles.push({
        x,y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        g: 1400 * (state.H/600),
        r: rand(2,5),
        a: 1,
        good
      });
    }
  }

  function handleSliceFruit(f){
    if (f.dead) return;

    const ex = currentExample();
    const gap = ex.gaps[state.gapPos];

    if (f.text === gap.correct){
      f.dead = true;
      addParticles(f.x, f.y, true);

      state.score += 100;
      if (state.score > state.best){
        state.best = state.score;
        safeSetBest(state.best);
      }

      state.filled[state.gapPos] = gap.correct;

      // Enforce order: clear remaining fruits when you progress
      clearFruits();
      if (state.gapPos === 0){
        state.gapPos = 1;
      } else {
        state.gapPos = 0;
        state.filled = ["",""];
        state.examplePos++;
        if (state.examplePos >= state.order.length) state.examplePos = 0;
      }

      renderSentence();
      updateHUD();
      return;
    }

    // Wrong: lose a life
    f.dead = true;
    addParticles(f.x, f.y, false);

    state.lives -= 1;
    state.flash = 0.25;

    updateHUD();
    if (state.lives <= 0){
      gameOver(true);
    }
  }

  // ---------- Input / blade ----------
  function pushBladePoint(x,y){
    state.blade.push({ x, y, t: performance.now() });
    if (state.blade.length > state.bladeMax) state.blade.shift();
  }
  function clearBlade(){ state.blade.length = 0; }

  function handleMove(x,y){
    pushBladePoint(x,y);
    const n = state.blade.length;
    if (n < 2) return;
    const a = state.blade[n-2], b = state.blade[n-1];

    for (const f of state.fruits){
      if (f.dead) continue;
      if (segCircleHit(a.x,a.y,b.x,b.y,f.x,f.y,f.r * 0.95)){
        handleSliceFruit(f);
      }
    }
  }

  canvas.addEventListener("mousedown", (e) => {
    if (!state.running) return;
    state.pointerDown = true;
    const p = worldFromEvent(e);
    clearBlade();
    pushBladePoint(p.x,p.y);
  });
  window.addEventListener("mouseup", () => { state.pointerDown = false; });

  canvas.addEventListener("mousemove", (e) => {
    if (!state.running || !state.pointerDown) return;
    const p = worldFromEvent(e);
    handleMove(p.x,p.y);
  });

  canvas.addEventListener("touchstart", (e) => {
    if (!state.running) return;
    e.preventDefault();
    state.pointerDown = true;
    const p = worldFromEvent(e);
    clearBlade();
    pushBladePoint(p.x,p.y);
  }, { passive:false });

  canvas.addEventListener("touchmove", (e) => {
    if (!state.running || !state.pointerDown) return;
    e.preventDefault();
    const p = worldFromEvent(e);
    handleMove(p.x,p.y);
  }, { passive:false });

  canvas.addEventListener("touchend", () => { state.pointerDown = false; });

  // ---------- Game lifecycle ----------
  function buildNewOrder(){
    const idxs = EXAMPLES.map((_,i)=>i);
    shuffleInPlace(idxs);
    state.order = idxs;
    state.examplePos = 0;
    state.gapPos = 0;
    state.filled = ["",""];
  }

  function resetGame(){
    state.score = 0;
    state.lives = 3;
    state.timeElapsed = 0;

    state.spawnTimer = 0;
    state.spawnInterval = 0.65;

    state.fruits.length = 0;
    state.particles.length = 0;
    state.blade.length = 0;
    state.flash = 0;

    updateHUD();
  }

  function startGame(){
    resetGame();
    buildNewOrder();
    renderSentence();

    state.running = true;
    $btn.textContent = "Restart";
    setMessageVisible(false);

    for (let i=0;i<3;i++) spawnFruit();
    draw();

    state.lastT = performance.now();
    requestAnimationFrame(loop);
  }

  function gameOver(shuffleBecauseLives){
    state.running = false;
    state.pointerDown = false;
    clearBlade();
    clearFruits();
    updateHUD();

    if (shuffleBecauseLives){
      buildNewOrder();
      renderSentence();
    }

    setMessageVisible(true, `
      <h1>Round finished</h1>
      <p>${shuffleBecauseLives ? "You lost all lives. The example order has been randomized." : "Stopped."}</p>
      <p>Score: <b>${state.score}</b> &nbsp;&nbsp; Best: <b>${state.best}</b></p>
      <p class="small">Press “Restart” to play again.</p>
    `);
  }

  function loop(now){
    if (!state.running) return;

    const dt = Math.min(0.033, (now - state.lastT) / 1000);
    state.lastT = now;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // ---------- Update & physics ----------
  function update(dt){
    state.timeElapsed += dt;

    state.spawnTimer += dt;
    if (state.spawnTimer >= state.spawnInterval){
      state.spawnTimer = 0;
      const burst = (Math.random() < 0.18) ? 2 : 1;
      for (let i=0;i<burst;i++) spawnFruit();
    }

    for (const f of state.fruits){
      f.life += dt;

      f.vy += f.g * dt;
      f.x += f.vx * dt;
      f.y += f.vy * dt;
      f.rot += f.spin * dt;

      // hard top boundary: do not cross top edge
      if (f.y - f.r < 0){
        f.y = f.r;
        if (f.vy < 0) f.vy = 0;
      }

      // remove when off-screen bottom (no penalty)
      if (f.y - f.r > state.H + 260){
        f.dead = true;
      }

      // gentle side bounds
      if (f.x - f.r < 8) { f.x = 8 + f.r; f.vx *= -0.4; }
      if (f.x + f.r > state.W - 8) { f.x = state.W - 8 - f.r; f.vx *= -0.4; }
    }
    state.fruits = state.fruits.filter(f => !f.dead);

    for (const p of state.particles){
      p.vy += p.g * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.a -= dt * 1.3;
    }
    state.particles = state.particles.filter(p => p.a > 0);

    const tNow = performance.now();
    state.blade = state.blade.filter(pt => (tNow - pt.t) < 120);

    state.flash = Math.max(0, state.flash - dt);

    updateHUD();
  }

  // ---------- Rendering ----------
  function drawFruit(f){
    const cut = fruitCut[f.fruitKey]; // transparent (processed) canvas
    const raw = fruitRaw[f.fruitKey]; // fallback if not processed yet
    const r = f.r;

    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.rotate(f.rot);

    // shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.beginPath();
    ctx.ellipse(4, 6, r * 1.05, r * 0.68, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    const source = (cut && cut.width) ? cut : (raw && raw.complete ? raw : null);

    // draw fruit image (cover-fit into a square)
    if (source) {
      const iw = source.width;
      const ih = source.height;

      const target = r * 2.15; // slightly oversize
      const scale = Math.max(target / iw, target / ih);
      const dw = iw * scale;
      const dh = ih * scale;

      ctx.drawImage(source, -dw/2, -dh/2, dw, dh);
    } else {
      // fallback: simple circle
      ctx.fillStyle = "rgba(255,255,255,0.12)";
      ctx.beginPath();
      ctx.arc(0,0,r,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // text (bigger by +50% and with outline for readability)
    ctx.font = `900 ${Math.round(16 * SIZE_MULT)}px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const yText = 2;
    ctx.lineWidth = 6;
    ctx.strokeStyle = "rgba(0,0,0,0.50)";
    ctx.strokeText(f.text, 0, yText);
    ctx.fillStyle = "rgba(255,255,255,0.98)";
    ctx.fillText(f.text, 0, yText);

    ctx.restore();
  }

  function drawBlade(){
    const pts = state.blade;
    if (pts.length < 2) return;

    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    for (let i=1;i<pts.length;i++){
      const a = pts[i-1], b = pts[i];
      const alpha = i / pts.length;
      ctx.strokeStyle = `rgba(255,255,255,${0.10 + 0.55*alpha})`;
      ctx.lineWidth = 2 + 6*alpha;
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawParticles(){
    for (const p of state.particles){
      ctx.globalAlpha = clamp(p.a, 0, 1);
      ctx.fillStyle = p.good ? "rgba(120,255,170,0.95)" : "rgba(255,120,120,0.95)";
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function draw(){
    ctx.clearRect(0,0,state.W,state.H);

    // in-game background (cover)
    drawBackgroundCover();

    // slight dark overlay for contrast
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0,0,state.W,state.H);
    ctx.restore();

    drawParticles();
    for (const f of state.fruits) drawFruit(f);
    drawBlade();

    if (state.flash > 0){
      ctx.save();
      ctx.globalAlpha = clamp(state.flash / 0.25, 0, 1) * 0.18;
      ctx.fillStyle = "rgba(255,60,60,1)";
      ctx.fillRect(0,0,state.W,state.H);
      ctx.restore();
    }
  }

  // ---------- Button ----------
  $btn.addEventListener("click", (e) => {
    e.preventDefault();
    startGame();
  });

  // init
  fitHiDPI();
  $best.textContent = String(state.best);
  buildNewOrder();
  renderSentence();
  updateHUD();
})();
</script>
</body>
</html>
