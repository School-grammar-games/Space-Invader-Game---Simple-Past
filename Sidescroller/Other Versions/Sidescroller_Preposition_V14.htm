<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Preposition Side-Scroller (Desktop + Touch Controls)</title>
  <style>
    :root{
      --bg1:#cfe9ff; --bg2:#e8f6ff;
      --ground:#5c8a3a; --ground2:#4a732f;
      --btn:#1f2f67;
      --btn2:#23357a;
    }

    *,*::before,*::after{ box-sizing:border-box; }

    html,body{
      height:100%;
      /* Fallback for browsers with dynamic address bars (set via JS as --vh). */
      height: calc(var(--vh, 1vh) * 100);
      min-height:100vh;
      min-height:100dvh;
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background-image: url("Images Sidescroller/background_website.png"),
                  radial-gradient(900px 520px at 20% 15%, rgba(255,255,255,0.90), rgba(255,255,255,0) 60%),
                  radial-gradient(800px 520px at 80% 10%, rgba(255,255,255,0.75), rgba(255,255,255,0) 60%),
                  linear-gradient(var(--bg1), var(--bg2));
      background-size: cover, auto, auto, auto;
      background-position: center, center, center, center;
      background-repeat: no-repeat, no-repeat, no-repeat, no-repeat;
      background-attachment: fixed, fixed, fixed, fixed;
      overflow-x:hidden;
      overflow-y:hidden;
    }

    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      opacity:0.55;
      background:
        radial-gradient(110px 60px at 12% 18%, rgba(255,255,255,0.95), rgba(255,255,255,0) 70%),
        radial-gradient(140px 70px at 18% 16%, rgba(255,255,255,0.90), rgba(255,255,255,0) 70%),
        radial-gradient(120px 60px at 24% 19%, rgba(255,255,255,0.92), rgba(255,255,255,0) 70%),
        radial-gradient(120px 60px at 62% 14%, rgba(255,255,255,0.92), rgba(255,255,255,0) 70%),
        radial-gradient(160px 80px at 70% 12%, rgba(255,255,255,0.90), rgba(255,255,255,0) 70%),
        radial-gradient(120px 60px at 78% 15%, rgba(255,255,255,0.92), rgba(255,255,255,0) 70%),
        radial-gradient(520px 220px at 15% 78%, rgba(45,120,90,0.22), rgba(45,120,90,0) 70%),
        radial-gradient(560px 240px at 55% 82%, rgba(45,120,90,0.20), rgba(45,120,90,0) 72%),
        radial-gradient(520px 220px at 90% 80%, rgba(45,120,90,0.18), rgba(45,120,90,0) 72%);
    }
    body::after{
      content:"";
      position:fixed;
      inset:-2px;
      pointer-events:none;
      background: radial-gradient(1200px 800px at 50% 35%, rgba(0,0,0,0), rgba(0,0,0,0.10) 70%, rgba(0,0,0,0.16) 100%);
      mix-blend-mode:multiply;
      opacity:0.55;
    }

    .wrap{
      height: calc(var(--vh, 1vh) * 100);
      min-height:100vh;
      min-height:100dvh;
      display:grid;
      place-items:center;
      /* Respect notches/home indicators and keep symmetric gutters. */
      padding-top: calc(12px + env(safe-area-inset-top));
      padding-right: calc(12px + env(safe-area-inset-right));
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
      padding-left: calc(12px + env(safe-area-inset-left));
      box-sizing:border-box;
    }

    .frame{
      width:100%;
      max-width:1040px;
      padding:16px;
      border-radius:18px;
      background: rgba(255,255,255,0.32);
      border:1px solid rgba(255,255,255,0.55);
      box-shadow: 0 18px 55px rgba(0,0,0,0.18);
      backdrop-filter: blur(8px);
    }

    canvas{
      width:100%;
      aspect-ratio:16/9;
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.15);
      outline:1px solid rgba(15,23,42,0.10);
      display:block;
      background:transparent;
    }

    .controls-bar{
      margin-top:8px; /* slightly tighter */
      display:flex;
      gap:14px;
      align-items:stretch;
      justify-content:space-between;
      user-select:none;
      -webkit-user-select:none;
    }

    .ctrl{
      flex:1 1 0;
      height:64px;
      border-radius:14px;
      background:linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 10px 24px rgba(0,0,0,0.18);
      color:#fff;
      font-weight:800;
      font-size:20px;
      letter-spacing:0.2px;
      display:grid;
      place-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      cursor:pointer;
    }
    .ctrl.smalltxt{ font-size:18px; }
    .ctrl:active, .ctrl.pressed{
      transform: translateY(1px);
      filter: brightness(1.07);
      box-shadow:0 7px 18px rgba(0,0,0,0.18);
    }

    /* Enemy GIF layer (DOM-based so animated GIFs advance reliably) */
    #enemyLayer{
      position:fixed;
      left:0;
      top:0;
      width:0;
      height:0;
      pointer-events:none;
      overflow:hidden;
      z-index: 2000;
    }
    #enemyLayer img{
      position:absolute;
      left:0;
      top:0;
      width:0;
      height:0;
      user-select:none;
      -webkit-user-select:none;
      pointer-events:none;
      image-rendering:auto;
      transform-origin: center center;
    }

    /* Responsive tweaks for short viewports (common on phones in landscape). */
    @media (max-height: 500px) and (orientation: landscape){
      .wrap{
        padding-top: calc(8px + env(safe-area-inset-top));
        padding-right: calc(8px + env(safe-area-inset-right));
        padding-bottom: calc(8px + env(safe-area-inset-bottom));
        padding-left: calc(8px + env(safe-area-inset-left));
      }
      .frame{ width:100%; max-width:1040px; padding:10px; }
      .controls-bar{ gap:10px; margin:0; }
      .ctrl{ height:48px; font-size:14px; border-radius:12px; }
      .ctrl.smalltxt{ font-size:14px; }
    }
    /* HUD (Level / Hearts / Score / Restart) */
    .hud{
      margin-bottom:6px;
      padding:3px 8px;
      border-radius:10px;
      background: rgba(255,255,255,0.88);
      border:1px solid rgba(255,255,255,0.55);
      box-shadow:0 6px 14px rgba(0,0,0,0.10);
      outline:1px solid rgba(15,23,42,0.08);
    }
    .hud-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:nowrap;
    }
    .hud-left, .hud-right{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:nowrap;
    }
    .hud-level{ font-weight:800; font-size:11.5px; color:rgba(15,23,42,0.85); }
    .hud-hearts{ font-weight:900; font-size:13.5px; letter-spacing:0.5px; color:rgba(220,38,38,0.95); }
    .hud-score{ font-weight:800; font-size:11.5px; color:rgba(15,23,42,0.85); }
    .hud-time{ font-weight:700; font-size:11.5px; color:rgba(15,23,42,0.70); }

    .hud-restart{
      height:24px;
      padding:0 10px;
      border-radius:10px;
      background:linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 6px 12px rgba(0,0,0,0.16);
      color:#fff;
      font-weight:800;
      font-size:11.5px;
      letter-spacing:0.2px;
      display:inline-grid;
      place-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;
      cursor:pointer;
      white-space:nowrap;
    }
    .hud-restart:active{
      transform: translateY(1px);
      filter: brightness(1.07);
      box-shadow:0 5px 10px rgba(0,0,0,0.16);
    }

    .hud-row2{
      margin-top:1px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:8px;
    }
    .hud-prompt{
      margin:0;
      flex:1 1 auto;
      min-width:0;
      font-weight:850;
      font-size:14px;
      color:rgba(15,23,42,0.92);
      line-height:1.12;
    }
    .hud-meta-right{
      display:flex;
      align-items:flex-end;
      justify-content:flex-end;
      gap:8px;
      white-space:nowrap;
    }
    .hud-hint{
      margin:0;
      font-weight:600;
      font-size:10px;
      color:rgba(15,23,42,0.60);
      white-space:nowrap;
    }
    .hud-feedback{
      margin:0;
      font-weight:800;
      font-size:11.5px;
      color:rgba(15,23,42,0.88);
      white-space:nowrap;
      display:none;
    }

    @media (max-width: 720px){
      .hud-top{ flex-wrap:wrap; }
      .hud-left, .hud-right{ flex-wrap:wrap; }
      .hud-meta-right{ white-space:normal; }
      .hud-hint, .hud-feedback{ white-space:normal; }
    }

    @media (max-height: 500px) and (orientation: landscape){
      .hud{ margin-bottom:6px; padding:3px 8px; }
      .hud-prompt{ font-size:14px; }
      .hud-restart{ height:24px; font-size:10px; }
      .hud-hint{ font-size:10px; }
    }


  

    /* Review modal (end-of-run mistakes) */
    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: calc(14px + env(safe-area-inset-top))
               calc(14px + env(safe-area-inset-right))
               calc(14px + env(safe-area-inset-bottom))
               calc(14px + env(safe-area-inset-left));
      background: rgba(0,0,0,0.55);
      z-index: 9999;
    }
    .modal.open{ display:flex; }

    .modal-card{
      width: min(920px, 100%);
      max-height: min(80vh, 720px);
      overflow:hidden;
      border-radius: 16px;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(15,23,42,0.12);
      box-shadow: 0 18px 55px rgba(0,0,0,0.28);
      display:flex;
      flex-direction:column;
    }
    .modal-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(15,23,42,0.10);
      background: rgba(248,250,252,0.92);
    }
    .modal-title{
      font-weight: 900;
      font-size: 15px;
      color: rgba(15,23,42,0.90);
    }
    .modal-close{
      width: 34px;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(15,23,42,0.12);
      background: rgba(255,255,255,0.95);
      cursor:pointer;
      font-size: 20px;
      line-height: 30px;
      font-weight: 800;
      color: rgba(15,23,42,0.70);
    }
    .modal-close:active{ transform: translateY(1px); }

    .modal-body{
      padding: 12px 14px;
      overflow:auto;
    }
    .mistake-item{
      border: 1px solid rgba(15,23,42,0.10);
      border-radius: 12px;
      padding: 10px 10px;
      background: rgba(255,255,255,0.96);
      box-shadow: 0 8px 18px rgba(0,0,0,0.06);
      margin-bottom: 10px;
    }
    .mistake-sentence{
      font-weight: 800;
      font-size: 13.5px;
      color: rgba(15,23,42,0.88);
      margin-bottom: 6px;
    }
    .mistake-meta{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-bottom: 6px;
    }
    .pill{
      display:inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.06);
      border: 1px solid rgba(15,23,42,0.10);
      font-weight: 700;
      font-size: 12px;
      color: rgba(15,23,42,0.78);
    }
    .mistake-why{
      margin: 0;
      font-size: 12.5px;
      line-height: 1.35;
      color: rgba(15,23,42,0.80);
    }

    .modal-actions{
      padding: 12px 14px;
      border-top: 1px solid rgba(15,23,42,0.10);
      display:flex;
      justify-content:flex-end;
      gap:10px;
      background: rgba(248,250,252,0.92);
    }
    .modal-btn{
      height: 36px;
      padding: 0 14px;
      border-radius: 12px;
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 10px 20px rgba(0,0,0,0.16);
      color:#fff;
      font-weight:900;
      cursor:pointer;
    }
    .modal-btn:active{ transform: translateY(1px); }

    /* Intro / Instructions screen (before start) */
    .intro-modal{ z-index: 10000; }
    .intro-card{
      width: min(920px, 100%);
      max-height: min(82vh, 740px);
      overflow:hidden;
      border-radius: 18px;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(15,23,42,0.12);
      box-shadow: 0 18px 55px rgba(0,0,0,0.30);
      display:flex;
      flex-direction:column;
    }
    .intro-head{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(15,23,42,0.10);
      background:
        radial-gradient(900px 240px at 10% 0%, rgba(191,233,255,0.85), rgba(255,255,255,0) 60%),
        radial-gradient(700px 260px at 90% 10%, rgba(217,244,255,0.80), rgba(255,255,255,0) 60%),
        rgba(248,250,252,0.96);
    }
    .intro-title{
      margin:0;
      font-weight: 950;
      font-size: 18px;
      letter-spacing: 0.2px;
      color: rgba(15,23,42,0.90);
    }
    .intro-subtitle{
      margin: 4px 0 0;
      font-weight: 650;
      font-size: 12.5px;
      color: rgba(15,23,42,0.70);
      line-height: 1.35;
    }
    .intro-body{
      padding: 14px 16px;
      overflow:auto;
      background:
        radial-gradient(900px 420px at 20% 0%, rgba(191,233,255,0.40), rgba(255,255,255,0) 60%),
        radial-gradient(900px 420px at 80% 0%, rgba(217,244,255,0.35), rgba(255,255,255,0) 60%),
        rgba(255,255,255,0.96);
    }
    .intro-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 720px){
      .intro-grid{ grid-template-columns: 1fr; }
    }
    .intro-section{
      border: 1px solid rgba(15,23,42,0.10);
      border-radius: 14px;
      padding: 12px 12px;
      background: rgba(255,255,255,0.92);
      box-shadow: 0 10px 22px rgba(0,0,0,0.06);
    }
    .intro-h{
      margin:0 0 6px;
      font-weight: 900;
      font-size: 13.5px;
      color: rgba(15,23,42,0.88);
    }
    .intro-p{
      margin:0;
      font-size: 12.5px;
      line-height: 1.45;
      color: rgba(15,23,42,0.78);
    }
    .intro-ul{
      margin: 6px 0 0;
      padding-left: 18px;
      font-size: 12.5px;
      line-height: 1.45;
      color: rgba(15,23,42,0.78);
    }
    .intro-ul li{ margin: 3px 0; }
    .intro-foot{
      padding: 12px 16px;
      border-top: 1px solid rgba(15,23,42,0.10);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      background: rgba(248,250,252,0.94);
      flex-wrap:wrap;
    }
    .intro-note{
      margin:0;
      font-size: 11.5px;
      color: rgba(15,23,42,0.65);
      line-height: 1.35;
    }
    .intro-start{
      height: 38px;
      padding: 0 16px;
      border-radius: 14px;
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 12px 22px rgba(0,0,0,0.18);
      color:#fff;
      font-weight:950;
      letter-spacing: 0.2px;
      cursor:pointer;
      white-space:nowrap;
    }
    .intro-start:active{ transform: translateY(1px); filter: brightness(1.07); }

  </style>
</head>
<body>
  <div class="wrap">
    <div class="frame">

      <div class="hud" aria-label="Status">
        <div class="hud-top">
          <div class="hud-left">
            <div class="hud-level" id="hudLevel">Level 1 / 50</div>
            <div class="hud-hearts" id="hudHearts" aria-label="Lives">♥♥♥♥♥</div>
          </div>
          <div class="hud-right">
            <div class="hud-score" id="hudScore">Score: 0</div>
            <div class="hud-time" id="hudTime">Time: 00:00</div>
            <div class="hud-restart" id="btnRestart" role="button" aria-label="Restart">Restart</div>
            <div class="hud-restart" id="btnMute" role="button" aria-label="Mute">Mute</div>
          </div>
        </div>
        <div class="hud-row2">
          <div class="hud-prompt" id="hudPrompt"></div>
          <div class="hud-meta-right">
            <div class="hud-hint" id="hudHint">◀ / ▶ move • Jump (double jump) • Restart button (or R on keyboard)</div>
            <div class="hud-feedback" id="hudFeedback"></div>
          </div>
        </div>
      </div>

      <canvas id="game" width="960" height="540"></canvas>
      <div id="enemyLayer" aria-hidden="true"></div>

      <div class="controls-bar" aria-label="Controls">
        <div class="ctrl" id="btnLeft" role="button" aria-label="Move left">◀</div>
        <div class="ctrl smalltxt" id="btnJump" role="button" aria-label="Jump">Jump</div>
        <div class="ctrl" id="btnRight" role="button" aria-label="Move right">▶</div>
      </div>
    </div>
  </div>

  <!-- Intro / Instructions (shown before the first run starts) -->
  <div class="modal intro-modal" id="introModal" aria-hidden="true">
    <div class="intro-card" role="dialog" aria-modal="true" aria-labelledby="introTitle">
      <div class="intro-head">
        <div>
          <div class="intro-title" id="introTitle">The Grammar Runner</div>
          <div class="intro-subtitle">Read the controls and the rules, then press Start to begin.</div>
        </div>
      </div>
      <div class="intro-body">
        <div class="intro-grid">
          <div class="intro-section">
            <div class="intro-h">Goal</div>
            <p class="intro-p">Run into the option that correctly completes the sentence shown in the HUD. Each correct pick advances you to the next level.</p>
          </div>

          <div class="intro-section">
            <div class="intro-h">Lives & scoring</div>
            <ul class="intro-ul">
              <li>Correct: +100 points and the next sentence appears.</li>
              <li>Wrong: you lose a life (♥). When all lives are gone, the run ends.</li>
              <li>After game over, you can review mistakes with accepted answers and a brief explanation.</li>
            </ul>
          </div>

          <div class="intro-section">
            <div class="intro-h">Controls (keyboard)</div>
            <ul class="intro-ul">
              <li>Move: <strong>←</strong> / <strong>→</strong></li>
              <li>Jump (double jump): <strong>↑</strong> or <strong>Space</strong></li>
              <li>Restart: <strong>R</strong> (or the Restart button)</li>
            </ul>
          </div>

          <div class="intro-section">
            <div class="intro-h">Controls (touch)</div>
            <ul class="intro-ul">
              <li>Use the on-screen buttons: ◀, Jump, ▶</li>
              <li>Tap Restart in the HUD to start over.</li>
            </ul>
          </div>
        </div>
      </div>
      <div class="intro-foot">
        <p class="intro-note">Tip: sound may start after your first tap/keypress (browser autoplay rules).</p>
        <button class="intro-start" id="introStart" type="button">Start</button>
      </div>
    </div>
  </div>

  <div class="modal" id="reviewModal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="reviewTitle">
      <div class="modal-head">
        <div class="modal-title" id="reviewTitle">Review mistakes</div>
        <button class="modal-close" id="reviewClose" type="button" aria-label="Close">×</button>
      </div>
      <div class="modal-body" id="reviewBody"></div>
      <div class="modal-actions">
        <button class="modal-btn" id="reviewRestart" type="button">Restart</button>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const enemyLayer = document.getElementById("enemyLayer");

  // IMPORTANT: The game frame uses backdrop-filter, which can create a containing block
  // for position:fixed descendants in some browsers. That breaks viewport-based positioning
  // when we align DOM sprites using getBoundingClientRect(). To keep coordinates consistent,
  // ensure the enemy layer lives directly under <body>.
  if (enemyLayer && enemyLayer.parentElement !== document.body) {
    document.body.appendChild(enemyLayer);
  }

  function syncEnemyLayerToCanvas(){
    if (!enemyLayer) return;
    const r = canvas.getBoundingClientRect();
    enemyLayer.style.left = r.left + 'px';
    enemyLayer.style.top = r.top + 'px';
    enemyLayer.style.width = r.width + 'px';
    enemyLayer.style.height = r.height + 'px';
  }

  // ----------------------------
  // HUD (DOM)
  // ----------------------------
  const hudLevelEl = document.getElementById("hudLevel");
  const hudHeartsEl = document.getElementById("hudHearts");
  const hudScoreEl = document.getElementById("hudScore");
  const hudTimeEl = document.getElementById("hudTime");
  const hudPromptEl = document.getElementById("hudPrompt");
  const hudHintEl = document.getElementById("hudHint");
  const hudFeedbackEl = document.getElementById("hudFeedback");
  const btnRestart = document.getElementById("btnRestart");
  const btnMute = document.getElementById("btnMute");


  // ----------------------------
  // REVIEW MODAL (mistakes)
  // ----------------------------
  const reviewModalEl = document.getElementById("reviewModal");
  const reviewCloseEl = document.getElementById("reviewClose");
  const reviewRestartEl = document.getElementById("reviewRestart");
  const reviewBodyEl = document.getElementById("reviewBody");

  // ----------------------------
  // INTRO MODAL (before first start)
  // ----------------------------
  const introModalEl = document.getElementById("introModal");
  const introStartEl = document.getElementById("introStart");
  function openIntroModal(){
    if (!introModalEl) return;
    introModalEl.classList.add('open');
    introModalEl.setAttribute('aria-hidden','false');
  }
  function closeIntroModal(){
    if (!introModalEl) return;
    introModalEl.classList.remove('open');
    introModalEl.setAttribute('aria-hidden','true');
  }

  function startGameFromIntro(){
    if (gameStarted) return;
    ensureAudio();
    startBGM();
    try { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch(_) {}
    gameStarted = true;
    runStartMs = performance.now();
    closeIntroModal();
    // Clear any buffered input that may have occurred while reading the instructions.
    jumpQueued = false;
    restartQueued = false;
    setFeedback("", 0);
  }

  if (introStartEl) introStartEl.addEventListener('click', () => startGameFromIntro());

  function escapeHtml(s){
    return String(s)
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;')
      .replace(/'/g,'&#39;');
  }

  function closeReviewModal(){
    if (!reviewModalEl) return;
    reviewModalEl.classList.remove('open');
    reviewModalEl.setAttribute('aria-hidden','true');
  }

  function showReviewModal(){
    if (!reviewModalEl || !reviewBodyEl) return;

    const total = mistakeLog.length;
    if (total === 0) {
      reviewBodyEl.innerHTML = '<div class="mistake-item"><div class="mistake-sentence">No mistakes recorded.</div><p class="mistake-why">Restart to play again.</p></div>';
    } else {
      const header = `<div class="mistake-item"><div class="mistake-sentence">End of run review</div><p class="mistake-why">You made ${total} mistake${total===1?'':'s'}. Each item shows the accepted answer(s) and a brief reason.</p></div>`;
      const items = mistakeLog.map(m => {
        const chosen = escapeHtml(m.chosen);
        const corrects = escapeHtml(m.corrects.join(' / '));
        const why = escapeHtml(m.why || '');
        return `
          <div class="mistake-item">
            <div class="mistake-sentence">${escapeHtml(m.prompt)}</div>
            <div class="mistake-meta">
              <span class="pill">Your answer: ${chosen}</span>
              <span class="pill">Accepted: ${corrects}</span>
            </div>
            <p class="mistake-why">${why}</p>
          </div>`;
      }).join('');
      reviewBodyEl.innerHTML = header + items;
    }

    reviewModalEl.classList.add('open');
    reviewModalEl.setAttribute('aria-hidden','false');
  }

  if (reviewCloseEl) reviewCloseEl.addEventListener('click', () => closeReviewModal());
  if (reviewRestartEl) reviewRestartEl.addEventListener('click', () => { closeReviewModal(); restartQueued = true; });
  if (reviewModalEl) reviewModalEl.addEventListener('click', (e) => { if (e.target === reviewModalEl) closeReviewModal(); });
  let lastHudHeight = 0;


  // ----------------------------
  // RESPONSIVE FIT (mobile)
  // ----------------------------
  const frameEl = document.querySelector('.frame');
  const controlsEl = document.querySelector('.controls-bar');
  const hudEl = document.querySelector('.hud');
  const wrapEl = document.querySelector('.wrap');
  const BASE_W = canvas.width;
  const BASE_H = canvas.height;

  // Mobile browsers (notably iOS Safari) report fluctuating CSS viewport units as the
  // address bar shows/hides. We set a JS-driven --vh custom property as a stable fallback.
  function setVhVar(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }

  function getViewportSize(){
    const vv = window.visualViewport;
    if (vv) return { w: vv.width, h: vv.height };
    return { w: window.innerWidth, h: window.innerHeight };
  }

  function fitCanvasToViewport(){
    // Compute available size while preserving the 16:9 game aspect.
    const vp = getViewportSize();
    const vh = vp.h;
    let maxW = frameEl ? frameEl.clientWidth : vp.w;

    const wrapStyle = wrapEl ? getComputedStyle(wrapEl) : null;
    const frameStyle = frameEl ? getComputedStyle(frameEl) : null;
    const framePadX = frameStyle ? (parseFloat(frameStyle.paddingLeft) + parseFloat(frameStyle.paddingRight)) : 0;
    maxW = Math.max(160, Math.min((maxW - framePadX), (vp.w - 2)));
    const controlsStyle = controlsEl ? getComputedStyle(controlsEl) : null;
    const hudStyle = hudEl ? getComputedStyle(hudEl) : null;

    const wrapPad = wrapStyle ? (parseFloat(wrapStyle.paddingTop) + parseFloat(wrapStyle.paddingBottom)) : 0;
    const framePad = frameStyle ? (parseFloat(frameStyle.paddingTop) + parseFloat(frameStyle.paddingBottom)) : 0;
    const controlsMarginTop = controlsStyle ? (parseFloat(controlsStyle.marginTop) || 0) : 0;
    const controlsH = controlsEl ? controlsEl.offsetHeight : 0;

    const hudMargin = hudStyle ? ((parseFloat(hudStyle.marginTop) || 0) + (parseFloat(hudStyle.marginBottom) || 0)) : 0;
    const hudH = hudEl ? hudEl.offsetHeight : 0;

    // Small safety buffer helps across browsers with dynamic toolbars.
    const extra = wrapPad + framePad + hudH + hudMargin + controlsH + controlsMarginTop + 6;
    const maxH = Math.max(160, vh - extra);

    const scale = Math.min(maxW / BASE_W, maxH / BASE_H);
    const cssW = Math.max(1, Math.floor(BASE_W * scale));
    const cssH = Math.max(1, Math.floor(BASE_H * scale));

    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.style.margin = '0 auto';

    // Keep the DOM enemy layer aligned to the canvas.
    syncEnemyLayerToCanvas();
  }

  // Keep the CSS viewport fallback current.
  setVhVar();
  window.addEventListener('resize', () => { setVhVar(); fitCanvasToViewport(); });
  window.addEventListener('orientationchange', () => setTimeout(() => { setVhVar(); fitCanvasToViewport(); }, 120));
  if (window.visualViewport) {
    // visualViewport events fire when the browser chrome collapses/expands.
    window.visualViewport.addEventListener('resize', () => { setVhVar(); fitCanvasToViewport(); });
    window.visualViewport.addEventListener('scroll', () => { setVhVar(); fitCanvasToViewport(); });
  }
  // Initial sizing
  fitCanvasToViewport();

  // ----------------------------
  // BACKGROUND IMAGE (parallax)
  // ----------------------------
  const bgImg = new Image();
  bgImg.decoding = "async";
  bgImg.src = "Images Sidescroller/background_sidescroller.png";
  let bgReady = false;
  bgImg.onload = () => { bgReady = true; };


// ----------------------------
// ENEMIES (GIFs, animated)
// ----------------------------
// NOTE ON ANIMATED GIFS IN CANVAS
// Some browsers (especially when running local files) can fail to advance GIF frames
// reliably unless the <img> element is present in the DOM. To ensure animations play,
// we create a hidden <img> element and append it to the document.
// Keep a tiny, (almost) invisible container in-viewport so browsers actually paint the GIFs,
// which is required in some engines to advance frames when we later draw them to <canvas>.
let __gifKeeper = null;
function getGifKeeper() {
  if (__gifKeeper) return __gifKeeper;
  const d = document.createElement("div");
  d.setAttribute("aria-hidden", "true");
  d.style.position = "fixed";
  d.style.right = "0";
  d.style.bottom = "0";
  // Keep it in the viewport and actually paintable, but imperceptible.
  // Some engines (notably Safari/WebKit) will not advance GIF frames for elements that
  // are fully transparent, off-screen, or behind the page background.
  d.style.width = "16px";
  d.style.height = "16px";
  d.style.overflow = "hidden";
  d.style.opacity = "0.001"; // must be > 0 to keep animation ticking
  d.style.pointerEvents = "none";
  d.style.zIndex = "2147483647";
  d.style.background = "transparent";
  d.style.transform = "translateZ(0)";
  document.body.appendChild(d);
  __gifKeeper = d;
  return d;
}

function loadAnimatedImageWithFallback(paths) {
  const img = document.createElement("img");
  img.decoding = "sync";
  img.loading = "eager";
  img.style.width = "16px";
  img.style.height = "16px";
  img.style.display = "block";
  img.style.position = "absolute";
  img.style.left = "0";
  img.style.top = "0";
  getGifKeeper().appendChild(img);

  let i = 0;
  const tryNext = () => {
    if (i >= paths.length) return;
    img.src = paths[i++];
  };
  img.onerror = tryNext;
  tryNext();
  return img;
}

// Prefer the user project's folder structure ("Images Sidescroller"), but fall back to a local "Enemies" folder.
const groundEnemyImg = loadAnimatedImageWithFallback([
  "Images Sidescroller/Ground enemy.gif",
  "Enemies/Ground enemy.gif",
  "Ground enemy.gif",
]);
const flyingEnemyImg = loadAnimatedImageWithFallback([
  "Images Sidescroller/Flying enemy.gif",
  "Enemies/Flying enemy.gif",
  "Flying enemy.gif",
]);

let groundEnemyReady = false;
let flyingEnemyReady = false;
groundEnemyImg.onload = () => { groundEnemyReady = true; };
flyingEnemyImg.onload = () => { flyingEnemyReady = true; };

// ----------------------------
// PLAYER (GIF, animated)
// ----------------------------
// We keep the player sprite as a DOM <img> (positioned over the canvas),
// just like enemies. This ensures animated GIF frames advance reliably
// across browsers.
const playerSpriteImg = loadAnimatedImageWithFallback([
  "Images Sidescroller/main character.gif",
  "main character.gif",
]);

// IDLE (STILL) sprite: use the project's "Stil" image from the Images Sidescroller folder.
const playerIdleImg = loadAnimatedImageWithFallback([
  "Images Sidescroller/Stil.png",
  "Images Sidescroller/Stil.gif",
  "Stil.png",
  "Stil.gif",
]);
let playerIdleReady = false;
playerIdleImg.onload = () => { playerIdleReady = true; };
if (playerIdleImg.complete && playerIdleImg.naturalWidth) { playerIdleReady = true; }

let playerSpriteReady = false;

// Gate animated GIF playback: show the GIF only while left/right input is held.
// When idle, we hide the DOM <img> and draw a cached (frozen) frame onto the canvas.
// This avoids relying on canvas export (toDataURL), which can be blocked under some file:// setups.
let playerSpriteAnimatedSrc = "";
let playerWasMoving = false;
let playerMoveInput = false;

// Offscreen canvas holding the last frozen frame.
const playerFrozenCanvas = document.createElement("canvas");
const playerFrozenCtx = playerFrozenCanvas.getContext("2d");
let playerFrozenReady = false;

function freezePlayerSpriteFrame() {
  if (!playerSpriteReady) return;
  const w = playerSpriteImg.naturalWidth || CHAR_W;
  const h = playerSpriteImg.naturalHeight || CHAR_H;
  if (playerFrozenCanvas.width !== w) playerFrozenCanvas.width = w;
  if (playerFrozenCanvas.height !== h) playerFrozenCanvas.height = h;
  playerFrozenCtx.clearRect(0, 0, w, h);
  // draw current GIF frame into the offscreen buffer (no pixel-readback required)
  playerFrozenCtx.drawImage(playerSpriteImg, 0, 0, w, h);
  playerFrozenReady = true;
}

playerSpriteImg.onload = () => {
  playerSpriteReady = true;
  playerSpriteAnimatedSrc = playerSpriteImg.src || "";
  // Initialize the frozen frame so the idle pose is available immediately.
  freezePlayerSpriteFrame();
};

// If the image was already cached and loaded before the onload handler was attached, initialize immediately.
if (playerSpriteImg.complete && playerSpriteImg.naturalWidth) {
  playerSpriteImg.onload();
}

let playerEl = null;
function ensurePlayerEl() {
  if (!enemyLayer) return null;
  if (playerEl) return playerEl;
  const im = document.createElement('img');
  im.alt = '';
  im.draggable = false;
  im.decoding = 'sync';
  im.loading = 'eager';
  im.style.zIndex = '10';
  im.style.transformOrigin = 'center center';
  // Source set in drawPlayer (after fallback resolution)
  enemyLayer.appendChild(im);
  playerEl = im;
  return playerEl;
}



  // ----------------------------
  // AUDIO (WebAudio)
  // ----------------------------
  let audioCtx = null;
  // Background music (HTMLAudioElement)
  let bgm = null;
  let audioMuted = false;
  // Sound effects (HTMLAudioElement templates; cloned per play for overlap)
  let sfxJump = null;
  let sfxCrush = null;
  let sfxCorrect = null;
  let sfxWrong = null;
  let sfxDeath = null;

  function ensureSFX(){
    try {
      if (!sfxJump) {
        sfxJump = new Audio("Images Sidescroller/Jump.mp3");
        sfxJump.preload = "auto";
        sfxJump.volume = 0.65;
      }
      if (!sfxCrush) {
        sfxCrush = new Audio("Images Sidescroller/Crush.mp3");
        sfxCrush.preload = "auto";
        sfxCrush.volume = 0.75;
      }
      if (!sfxCorrect) {
        sfxCorrect = new Audio("Images Sidescroller/Correct.mp3");
        sfxCorrect.preload = "auto";
        sfxCorrect.volume = 0.70;
      }
      if (!sfxWrong) {
        sfxWrong = new Audio("Images Sidescroller/Wrong.mp3");
        sfxWrong.preload = "auto";
        sfxWrong.volume = 0.75;
      }
      if (!sfxDeath) {
        sfxDeath = new Audio("Images Sidescroller/Death.mp3");
        sfxDeath.preload = "auto";
        sfxDeath.volume = 0.85;
      }
      // Keep templates aligned with mute state
      if (sfxJump) sfxJump.muted = audioMuted;
    if (sfxCrush) sfxCrush.muted = audioMuted;
    if (sfxCorrect) sfxCorrect.muted = audioMuted;
    if (sfxWrong) sfxWrong.muted = audioMuted;
    if (sfxDeath) sfxDeath.muted = audioMuted;
      if (sfxCorrect) sfxCorrect.muted = audioMuted;
      if (sfxWrong) sfxWrong.muted = audioMuted;
      if (sfxDeath) sfxDeath.muted = audioMuted;
    } catch(_) {
      // If audio creation fails, keep SFX null (game remains playable).
      sfxJump = sfxJump || null;
      sfxCrush = sfxCrush || null;
      sfxCorrect = sfxCorrect || null;
      sfxWrong = sfxWrong || null;
      sfxDeath = sfxDeath || null;
    }
  }

  function playSFX(template){
    if (audioMuted) return;
    if (!template) return;
    try {
      // Clone so repeated/overlapping triggers do not cut each other off.
      const a = template.cloneNode(true);
      a.muted = audioMuted;
      a.volume = template.volume;
      const p = a.play();
      if (p && typeof p.catch === "function") p.catch(()=>{});
    } catch(_) {}
  }

  function playJumpSFX(){ ensureSFX(); playSFX(sfxJump); }
  function playCrushSFX(){ ensureSFX(); playSFX(sfxCrush); }
  function playCorrectSFX(){ ensureSFX(); playSFX(sfxCorrect); }
  function playWrongSFX(){ ensureSFX(); playSFX(sfxWrong); }
  function playDeathSFX(){ ensureSFX(); playSFX(sfxDeath); }

  function ensureBGM(){
    if (bgm) return;
    try {
      bgm = new Audio("Images Sidescroller/background.mp3");
      bgm.loop = true;
      bgm.preload = "auto";
      bgm.volume = 0.22;
      bgm.muted = audioMuted;
    } catch(_) { bgm = null; }
  }
  function startBGM(){
    ensureBGM();
    ensureSFX();
    if (!bgm) return;
    bgm.muted = audioMuted;
    const p = bgm.play();
    if (p && typeof p.catch === "function") p.catch(()=>{});
  }
  function setMuteState(m){
    audioMuted = !!m;
    if (bgm) bgm.muted = audioMuted;
    if (sfxJump) sfxJump.muted = audioMuted;
    if (sfxCrush) sfxCrush.muted = audioMuted;
    if (sfxCorrect) sfxCorrect.muted = audioMuted;
    if (sfxWrong) sfxWrong.muted = audioMuted;
    if (sfxDeath) sfxDeath.muted = audioMuted;
    if (btnMute) {
      btnMute.textContent = audioMuted ? "Unmute" : "Mute";
      btnMute.setAttribute("aria-label", audioMuted ? "Unmute" : "Mute");
    }
  }
  function ensureAudio() {
    if (audioCtx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    audioCtx = new AC();
  }
  function playBeep({ type="sine", freq=440, dur=0.14, gain=0.12, endFreq=null }) {
    if (!audioCtx || audioMuted) return;
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    if (endFreq != null) osc.frequency.linearRampToValueAtTime(endFreq, t0 + dur);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + dur);
  }
  function soundCorrect() {
    // Prefer the dedicated SFX file; fall back to a simple beep if audio loading fails.
    ensureSFX();
    if (sfxCorrect) { playCorrectSFX(); return; }
    ensureAudio();
    playBeep({ type:"triangle", freq:620, endFreq:880, dur:0.16, gain:0.14 });
    setTimeout(() => playBeep({ type:"triangle", freq:880, endFreq:980, dur:0.12, gain:0.10 }), 110);
  }
  function soundWrong() {
    ensureSFX();
    if (sfxWrong) { playWrongSFX(); return; }
    ensureAudio();
    playBeep({ type:"sawtooth", freq:220, endFreq:160, dur:0.22, gain:0.13 });
  }

  // ----------------------------
  // SCREEN FLASH
  // ----------------------------
  let flash = { t: 0, dur: 0, color: "rgba(0,0,0,0)" };
  function triggerFlash(color, dur=0.18) {
    flash.color = color;
    flash.t = dur;
    flash.dur = dur;
  }

  // ----------------------------
  // SIZES
  // ----------------------------
  const CHAR_W = 104, CHAR_H = 81;
  // Cropped GIF: no padding offsets required.
  const PLAYER_SPRITE_OFF_X = 0;
  const PLAYER_SPRITE_OFF_Y = 4;
  // Hitbox is separate from the visual sprite.
  // Adjust these to fine-tune platform interaction (feet alignment, edge drop-off).
  const HIT_W = 30;
  const HIT_H = 50;
  const HIT_OFF_X = Math.round((CHAR_W - HIT_W) / 2);
  const HIT_OFF_Y = CHAR_H - HIT_H;
  // Require a minimum horizontal overlap (in px) to count as standing on a platform.
  const MIN_FOOT_OVERLAP = 10;

  // Platform width should NOT scale with the player's sprite size.
  // Keep the original platform width to preserve the intended camera/perspective.
  const PLATFORM_W = 102;
  const PLATFORM_H = 18;

  // Thin ground, but ALWAYS at bottom
  const GROUND_H = 40;


// ----------------------------
// ENEMY SYSTEM
// ----------------------------
const ENEMY_CFG = {
  // Spawn intervals (seconds)
  groundSpawnMin: 3.2,
  groundSpawnMax: 5.6,
  flyingSpawnMin: 4.8,
  flyingSpawnMax: 6.6,

  // Speeds (px/sec)
  groundSpeed: 140,
  flyingSpeed: 115,

  // Visual sizes (target heights, px)
  groundH: 90,
  flyingH: 100,

  // Flying motion
  flyAmp: 34,
  flyOscSpeed: 2.2, // radians/sec
};

// Player stomping (ground enemies only)
const STOMP_TOL = 10;          // px: max "from-above" allowance using previous bottom vs enemy top
const STOMP_MIN_OVERLAP = 10;  // px: minimum horizontal overlap to count as a stomp
const STOMP_BOUNCE = 0.55;     // fraction of WORLD.jumpSpeed applied as bounce after stomp
const ENEMY_DEATH_DUR = 0.28;  // seconds (squash + fade)

let enemies = [];
let lastFlyingSpawnY = null;
let enemySpawn = {
  ground: { t: 0, next: 2.8 },
  flying: { t: 0, next: 3.6 },
};
let enemyHitCooldown = 0;

function randRange(a, b) { return a + Math.random() * (b - a); }

function getScaledDims(img, targetH) {
  const ih = (img && (img.naturalHeight || img.height)) || targetH;
  const iw = (img && (img.naturalWidth || img.width)) || (targetH * 0.9);
  const h = targetH;
  const w = (iw / ih) * h;
  return { w, h };
}

function resetEnemies() {
  // Remove any DOM sprite elements.
  for (const e of enemies) {
    if (e.el && e.el.remove) e.el.remove();
  }
  enemies = [];
  enemySpawn.ground.t = 0;
  enemySpawn.flying.t = 0;
  enemySpawn.ground.next = randRange(ENEMY_CFG.groundSpawnMin, ENEMY_CFG.groundSpawnMax);
  enemySpawn.flying.next = randRange(ENEMY_CFG.flyingSpawnMin, ENEMY_CFG.flyingSpawnMax);
  enemyHitCooldown = 0;
}

function spawnGroundEnemy() {
  const dims = getScaledDims(groundEnemyImg, ENEMY_CFG.groundH);
  const spawnX = camera.x + canvas.width + 160;
  const groundTop = canvas.height - GROUND_H;
  enemies.push({
    type: "ground",
    img: groundEnemyImg,
    x: spawnX,
    y: groundTop - dims.h + 20,
    w: dims.w,
    h: dims.h,
    vx: -ENEMY_CFG.groundSpeed,
    flipX: false,
    dead: false,
    deathT: 0,
    deathDur: ENEMY_DEATH_DUR,
  });
}

function spawnFlyingEnemy() {
  const dims = getScaledDims(flyingEnemyImg, ENEMY_CFG.flyingH);
  const spawnX = camera.x + canvas.width + 180;
  // Spawn at varied heights (avoid repeating the same band too often)
  const groundTop = canvas.height - GROUND_H;
  const minY = 60;
  const maxY = Math.max(minY + 120, groundTop - 320);
  let baseY = randRange(minY, maxY);
  if (lastFlyingSpawnY != null && Math.abs(baseY - lastFlyingSpawnY) < 80) {
    baseY = randRange(minY, maxY);
  }
  lastFlyingSpawnY = baseY;
  enemies.push({
    type: "flying",
    img: flyingEnemyImg,
    x: spawnX,
    y: baseY,
    baseY,
    w: dims.w,
    h: dims.h,
    vx: -ENEMY_CFG.flyingSpeed,
    oscT: 0,
    oscAmp: ENEMY_CFG.flyAmp * randRange(0.8, 1.25),
    oscSpeed: ENEMY_CFG.flyOscSpeed * randRange(0.8, 1.25),
    phase: randRange(0, Math.PI * 2),
    flipX: true,
    dead: false,
    deathT: 0,
    deathDur: ENEMY_DEATH_DUR,
  });
}

function updateEnemies(dt) {
  if (enemyHitCooldown > 0) enemyHitCooldown = Math.max(0, enemyHitCooldown - dt);

  // Spawn regulation
  enemySpawn.ground.t += dt;
  enemySpawn.flying.t += dt;

  if (enemySpawn.ground.t >= enemySpawn.ground.next) {
    enemySpawn.ground.t = 0;
    enemySpawn.ground.next = randRange(ENEMY_CFG.groundSpawnMin, ENEMY_CFG.groundSpawnMax);
    spawnGroundEnemy();
  }
  if (enemySpawn.flying.t >= enemySpawn.flying.next) {
    enemySpawn.flying.t = 0;
    enemySpawn.flying.next = randRange(ENEMY_CFG.flyingSpawnMin, ENEMY_CFG.flyingSpawnMax);
    spawnFlyingEnemy();
  }

  const despawnX = camera.x - 220;

  // Move enemies and advance death timers
  for (const e of enemies) {
    if (e.dead) {
      e.deathT = Math.max(0, (e.deathT || 0) - dt);
      continue;
    }
    e.x += e.vx * dt;
    if (e.type === "flying") {
      e.oscT += dt;
      e.y = e.baseY + Math.sin(e.oscT * e.oscSpeed + e.phase) * e.oscAmp;
    }
  }

  // Despawn (off-screen) and fully-dead enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    const offLeft = (e.x + e.w) < despawnX;
    const finishedDeath = e.dead && (e.deathT || 0) <= 0;
    if (offLeft || finishedDeath) {
      if (e.el && e.el.remove) e.el.remove();
      enemies.splice(i, 1);
    }
  }
}

function handleEnemyCollision() {
  const hb = playerHitRect(player);
  const prevHb = player.prevHb || hb;

  for (const e of enemies) {
    if (e.dead) continue;

    if (!aabb(hb.x, hb.y, hb.w, hb.h, e.x, e.y, e.w, e.h)) continue;

    const overlap = xOverlap(hb.x, hb.w, e.x, e.w);
    const prevBottom = prevHb.y + prevHb.h;

    // Stomp: only for ground enemies, only when falling onto them (vertical collision).
    const isStomp = (e.type === "ground") &&
                    (player.vy > 0) &&
                    (prevBottom <= e.y + STOMP_TOL) &&
                    (overlap >= STOMP_MIN_OVERLAP);

    if (isStomp) {
      e.dead = true;
      playCrushSFX();
      e.deathDur = e.deathDur || ENEMY_DEATH_DUR;
      e.deathT = e.deathDur;

      // Bounce the player upward a bit (classic stomp feel).
      player.vy = -WORLD.jumpSpeed * STOMP_BOUNCE;
      player.onGround = false;
      player.coyote = 0;
      player.jumpBuf = 0;

      // Small feedback flash (green) to reinforce successful stomp.
      triggerFlash("rgba(34,197,94,1)", 0.10);
      return;
    }

    // Otherwise treat as damage (horizontal collision or flying enemy).
    if (enemyHitCooldown > 0) return;
    enemyHitCooldown = 1.1;
    triggerFlash("rgba(239,68,68,1)", 0.18);
    playDeathSFX();
    loseLife();
    if (!gameOver) {
      setFeedback("Hit by an enemy. Respawning.", 1.0);
      player = makePlayer();
      // Re-center camera quickly so the respawn doesn't feel disorienting.
      camera.x = player.x - canvas.width * 0.35;
      camera.y = 0;
      // Clear enemies to avoid immediate re-hit.
      resetEnemies();
    }
    return;
  }
}

function drawEnemies() {
  if (!enemies.length) return;

  // Keep enemy layer aligned to the canvas in CSS pixels.
  syncEnemyLayerToCanvas();

  const r = canvas.getBoundingClientRect();
  const scaleX = r.width / canvas.width;
  const scaleY = r.height / canvas.height;

  function ensureEnemyEl(e) {
    if (!enemyLayer) return;
    if (e.el) return;
    const im = document.createElement('img');
    im.alt = '';
    im.draggable = false;
    im.decoding = 'sync';
    im.loading = 'eager';
    im.src = (e.img && e.img.src) ? e.img.src : '';
    enemyLayer.appendChild(im);
    e.el = im;
  }

  for (const e of enemies) {
    const sx = e.x - camera.x;
    const sy = e.y - camera.y;

    const off = (sx + e.w < -200 || sx > canvas.width + 200);

    // Draw only the shadow on the canvas (sprite itself is a DOM <img> so GIFs animate).
    if (!off && e.type === "ground") {
      ctx.save();
      ctx.globalAlpha = 0.28;
      ctx.fillStyle = "#000";
      const shW = e.w * 0.55;
      const shH = 8;
      const shX = sx + (e.w - shW) * 0.5;
      const shY = sy + e.h - 14;
      ctx.beginPath();
      ctx.ellipse(shX + shW/2, shY + shH/2, shW/2, shH/2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Update the DOM sprite.
    ensureEnemyEl(e);
    if (e.el) {
      if (off) {
        e.el.style.display = 'none';
      } else {
        e.el.style.display = 'block';
        e.el.style.left = (sx * scaleX) + 'px';
        e.el.style.top = (sy * scaleY) + 'px';
        e.el.style.width = (e.w * scaleX) + 'px';
        e.el.style.height = (e.h * scaleY) + 'px';

        // Kill animation (squash + fade)
        let sxMul = 1, syMul = 1, alpha = 1;
        if (e.dead) {
          const dur = (e.deathDur || ENEMY_DEATH_DUR);
          const t = Math.max(0, (e.deathT || 0));
          const p = dur > 0 ? (1 - (t / dur)) : 1; // 0..1
          syMul = Math.max(0.15, 1 - 0.75 * p);
          sxMul = 1 + 0.15 * p;
          alpha = Math.max(0, 1 - p);
        }
        const flip = e.flipX ? -1 : 1;
        e.el.style.transform = `scale(${flip * sxMul}, ${syMul})`;
        e.el.style.opacity = String(alpha);
      }
    }
  }
}

  // ----------------------------
  // LEVELS (50)
  // ----------------------------
  const LEVELS_BASE = [
    { prompt: "He's surfing ____ the internet.", options: ["on","in","at","to"], correct: "on", why: "Use 'on the internet' (fixed collocation) to mean using online services/websites." },
    { prompt: "We arrived ____ the station at 6.", options: ["at","to","in","on"], correct: "at", why: "Use 'at' for a specific point/place (station as a location)." },
    { prompt: "I was born ____ 2008.", options: ["in","on","at","since"], correct: "in", why: "Use 'in' for years." },
    { prompt: "The keys are ____ the table.", options: ["on","in","at","to"], correct: "on", why: "Use 'on' for something resting on a surface." },
    { prompt: "She is interested ____ biology.", options: ["in","on","at","for"], correct: "in", why: "Use 'interested in' (fixed collocation)." },
    { prompt: "He apologized ____ being late.", options: ["for","about","to","with"], correct: "for", why: "Use 'apologize for' + noun/gerund to name what you are sorry about." },
    { prompt: "I’m good ____ math.", options: ["at","in","on","to"], correct: "at", why: "Use 'good at' to describe skill/ability." },
    { prompt: "We depend ____ public transport.", options: ["on","in","at","from"], correct: "on", why: "Use 'depend on' (fixed collocation)." },
    { prompt: "They are afraid ____ spiders.", options: ["of","from","about","for"], correct: "of", why: "Use 'afraid of' (fixed collocation)." },
    { prompt: "Please write ____ pen, not pencil.", options: ["with","by","in","on"], correct: "with", why: "Use 'with' to express the instrument/tool used." },
    { prompt: "This book belongs ____ my sister.", options: ["to","for","with","at"], correct: "to", why: "Use 'belong to' to show possession." },
    { prompt: "She arrived ____ time for the lesson.", options: ["on","in","at","to"], correct: "on", why: "Use 'on time' (fixed phrase) meaning punctual." },
    { prompt: "We met ____ Monday morning.", options: ["on","in","at","by"], correct: "on", why: "Use 'on' for days and dates (Monday)." },
    { prompt: "He lives ____ Bavaria.", options: ["in","at","on","to"], correct: "in", why: "Use 'in' for regions/areas (states, countries, cities)." },
    { prompt: "I’ll call you ____ the evening.", options: ["in","on","at","to"], correct: "in", why: "Use 'in' with parts of the day (in the morning/afternoon/evening)." },
    { prompt: "The cat is hiding ____ the bed.", options: ["under","over","between","through"], correct: "under", why: "Use 'under' for a position beneath something." },
    { prompt: "The supermarket is ____ the bank.", options: ["next to","between","behind","across"], correct: "next to", why: "Use 'next to' for immediate adjacency." },
    { prompt: "She walked ____ the street carefully.", options: ["across","through","over","along"], correct: "across", why: "Use 'across' when you go from one side to the other." },
    { prompt: "We drove ____ the tunnel.", options: ["through","across","between","beside"], correct: "through", why: "Use 'through' for movement inside an enclosed space from entrance to exit." },
    { prompt: "I’ve lived here ____ 2019.", options: ["since","for","during","until"], correct: "since", why: "Use 'since' with a starting point (a year/date)." },
    { prompt: "I’ve lived here ____ three years.", options: ["for","since","until","during"], correct: "for", why: "Use 'for' with a duration (length of time)." },
    { prompt: "He has been ill ____ the weekend.", options: ["since","for","at","on"], correct: "since", why: "Use 'since' to mark when the situation started." },
    { prompt: "They talked ____ the test results.", options: ["about","of","for","with"], correct: "about", why: "Use 'talk about' for the topic of a conversation." },
    { prompt: "He’s responsible ____ the project.", options: ["for","of","to","with"], correct: "for", why: "Use 'responsible for' (fixed collocation)." },
    { prompt: "Don’t worry ____ it.", options: ["about","for","of","to"], correct: "about", why: "Use 'worry about' (fixed collocation)." },
    { prompt: "She is married ____ a doctor.", options: ["to","with","for","at"], correct: "to", why: "Use 'married to' (fixed collocation)." },
    { prompt: "I’m looking ____ my phone.", options: ["for","at","to","with"], correct: "for", why: "Use 'look for' to mean search." },
    { prompt: "He looked ____ the picture and smiled.", options: ["at","for","to","in"], correct: "at", why: "Use 'look at' for directing your eyes to something." },
    { prompt: "The train goes ____ Berlin at 7.", options: ["to","at","in","on"], correct: "to", why: "Use 'to' to indicate a destination." },
    { prompt: "Please translate this ____ English.", options: ["into","to","in","at"], correct: "into", why: "Use 'translate into' to indicate the target language/result." },

    // Image description phrases (20)
    { prompt: "____ the foreground, you can see a bicycle.", options: ["In","On","At","To"], correct: "In", why: "Use 'in the foreground' (fixed image-description phrase)." },
    { prompt: "____ the background, there are mountains.", options: ["In","On","At","Into"], correct: "In", why: "Use 'in the background' (fixed image-description phrase)." },
    { prompt: "There is a small house ____ the right.", options: ["on","in","at","to"], correct: "on", why: "In picture descriptions, use 'on the right/left' for relative position." },
    { prompt: "There are two trees ____ the left side.", options: ["on","in","at","to"], correct: "on", why: "In picture descriptions, use 'on the left side' for relative position." },
    { prompt: "The sun is ____ the top of the picture.", options: ["at","in","on","to"], correct: "at", why: "Use 'at the top/bottom' to point to a position on an image." },
    { prompt: "The river is ____ the bottom of the picture.", options: ["at","in","on","to"], correct: "at", why: "Use 'at the top/bottom' to point to a position on an image." },
    { prompt: "The main object is ____ the center.", options: ["in","on","at","to"], correct: ["in","at"], why: "Both can work: 'in the center' (within the central area) or 'at the center' (exact point)." },
    { prompt: "There is a tree ____ the middle of the field.", options: ["in","at","on","to"], correct: ["in","at"], why: "Both can work: 'in the middle' (general area) or 'at the middle' (exact point; less common but acceptable)." },
    { prompt: "A car is parked ____ the building.", options: ["in front of","behind","between","across"], correct: "in front of", why: "Use 'in front of' for a position before something (between you and it)." },
    { prompt: "A garden is ____ the house.", options: ["behind","in front of","over","through"], correct: "behind", why: "Use 'behind' for a position at the back of something." },
    { prompt: "A cat is sitting ____ the chair.", options: ["on","in","at","to"], correct: "on", why: "Use 'on' when something is on top of a surface." },
    { prompt: "The dog is lying ____ the sofa.", options: ["under","on","behind","between"], correct: ["under","on"], why: "Both can be correct depending on meaning: 'on' if it is on top of the sofa; 'under' if it is beneath it." },
    { prompt: "The ball is ____ the box.", options: ["in","on","at","over"], correct: "in", why: "Use 'in' for something inside an enclosed space." },
    { prompt: "The lamp is ____ the table.", options: ["above","under","between","through"], correct: "above", why: "Use 'above' for a higher position without contact." },
    { prompt: "The shoes are ____ the bed.", options: ["under","over","in","at"], correct: "under", why: "Use 'under' for a position beneath something." },
    { prompt: "The school is ____ the church and the supermarket.", options: ["between","behind","over","through"], correct: "between", why: "Use 'between' for something in the middle of two reference points." },
    { prompt: "He walked ____ the bridge.", options: ["across","through","under","into"], correct: "across", why: "Use 'across' when crossing from one side to the other (bridge as a surface)." },
    { prompt: "We drove ____ the tunnel.", options: ["through","across","over","between"], correct: "through", why: "Use 'through' for movement inside an enclosed space from entrance to exit." },
    { prompt: "A bird is flying ____ the lake.", options: ["over","under","between","through"], correct: "over", why: "Use 'over' for a position above something (often while moving)." },
    { prompt: "He is ____ school right now.", options: ["at","in","on","to"], correct: ["at","in"], why: "Both are used: 'at school' focuses on being at the institution/activity; 'in school' can mean inside the building or enrolled/in attendance." },
    { prompt: "We will meet ____ the weekend.", options: ["at","on","in","to"], correct: ["at","on"], why: "Both occur: 'at the weekend' is common in BrE; 'on the weekend' is common in AmE (also used by some BrE speakers)." },
  ];

  // Current level order (shuffled on game-over restart)
  let LEVELS = [...LEVELS_BASE];

  function shuffleLevels() {
    if (LEVELS_BASE.length <= 1) { LEVELS = [...LEVELS_BASE]; return; }
    let next;
    do {
      next = shuffle([...LEVELS_BASE]);
    } while (next[0].prompt === LEVELS[0].prompt);
    LEVELS = next;
  }

  // ----------------------------
  // INPUT (keyboard)
  // ----------------------------
  const keysDown = new Set();
  let jumpQueued = false;
  let restartQueued = false;

  function keyName(e) {
    if (e.code === "Space") return "space";
    if (e.key && e.key.startsWith("Arrow")) return e.key.toLowerCase();
    return (e.key || "").toLowerCase();
  }

  window.addEventListener("keydown", (e) => {
    ensureAudio();
    const k = keyName(e);
    if (k === "arrowleft" || k === "arrowright" || k === "arrowup" || k === "space") e.preventDefault();
    if (!keysDown.has(k)) {
      if (k === "arrowup" || k === "space") jumpQueued = true;
      if (k === "r") restartQueued = true;
    }
    keysDown.add(k);
  }, { passive: false });

  window.addEventListener("keyup", (e) => keysDown.delete(keyName(e)));
  canvas.addEventListener("pointerdown", () => ensureAudio());
  const isDown = (k) => keysDown.has(k);

  // ----------------------------
  // INPUT (buttons)
  // ----------------------------
  const touch = { left:false, right:false };
  const btnLeft  = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");
  const btnJump  = document.getElementById("btnJump");

  if (btnRestart) {
    btnRestart.addEventListener("pointerdown", (ev) => {
      ensureAudio();
      if (ev && ev.preventDefault) ev.preventDefault();
      restartQueued = true;
    }, { passive:false });
  }

  if (btnMute) {
    btnMute.addEventListener("pointerdown", (ev) => {
      ensureAudio();
      if (ev && ev.preventDefault) ev.preventDefault();
      setMuteState(!audioMuted);
      // Attempt to (re)start music on unmute
      if (!audioMuted) startBGM();
    }, { passive:false });
  }

  function setPressed(el, on){ if (el) el.classList.toggle("pressed", !!on); }

  function bindHold(el, onDown, onUp){
    el.addEventListener("pointerdown", (ev) => {
      ensureAudio();
      ev.preventDefault();
      try { el.setPointerCapture(ev.pointerId); } catch(_) {}
      onDown();
      setPressed(el, true);
    }, { passive:false });

    const up = (ev) => {
      if (ev && ev.preventDefault) ev.preventDefault();
      onUp();
      setPressed(el, false);
    };

    el.addEventListener("pointerup", up, { passive:false });
    el.addEventListener("pointercancel", up, { passive:false });
    el.addEventListener("lostpointercapture", up, { passive:true });
  }

  bindHold(btnLeft,  () => { touch.left = true;  }, () => { touch.left = false; });
  bindHold(btnRight, () => { touch.right = true; }, () => { touch.right = false; });

  btnJump.addEventListener("pointerdown", (ev) => {
    ensureAudio();
    ev.preventDefault();
    try { btnJump.setPointerCapture(ev.pointerId); } catch(_) {}
    jumpQueued = true;
    setPressed(btnJump, true);
  }, { passive:false });

  const clearJump = (ev) => {
    if (ev && ev.preventDefault) ev.preventDefault();
    setPressed(btnJump, false);
  };
  btnJump.addEventListener("pointerup", clearJump, { passive:false });
  btnJump.addEventListener("pointercancel", clearJump, { passive:false });
  btnJump.addEventListener("lostpointercapture", clearJump, { passive:true });

  const controlsBar = document.querySelector(".controls-bar");
  controlsBar.addEventListener("touchstart", (e) => e.preventDefault(), { passive:false });
  controlsBar.addEventListener("touchmove",  (e) => e.preventDefault(), { passive:false });

  // ----------------------------
  // WORLD / PLAYER
  // ----------------------------
  const WORLD = {
    gravity: 2200,
    friction: 0.85,
    moveAccel: 2800,
    maxSpeed: 420,
    jumpSpeed: 820,
    coyoteTime: 0.10,
    jumpBuffer: 0.10,
    maxAirJumps: 1,
  };

  const camera = { x: 0, y: 0 };

  function makePlayer() {
    return {
      x: 80, y: 200, w: CHAR_W, h: CHAR_H,
      // Collision hitbox (used for platforms/enemies/collectibles)
      hbW: HIT_W, hbH: HIT_H,
      hbOx: HIT_OFF_X, hbOy: HIT_OFF_Y,
      vx: 0, vy: 0,
      onGround: false,
      coyote: 0,
      jumpBuf: 0,
      facing: 1,
      airJumpsLeft: WORLD.maxAirJumps,
    };
  }
  let player = makePlayer();

  // ----------------------------
  // SCORE / TIMER / LIVES
  // ----------------------------
  let score = 0;
  let lives = 5;
  const MAX_LIVES = 5;
  let gameOver = false;
  let gameStarted = false;


  // Record first wrong attempt per sentence (keeps the end-of-run review concise)
  let mistakeLog = [];
  let mistakeSeenByLevel = new Set();

  function getCorrectArray(lvl){
    return Array.isArray(lvl.correct) ? lvl.correct : [lvl.correct];
  }

  function recordMistake(levelIdx, chosenLabel){
    if (mistakeSeenByLevel.has(levelIdx)) return;
    mistakeSeenByLevel.add(levelIdx);
    const lvl = LEVELS[levelIdx];
    mistakeLog.push({
      level: levelIdx + 1,
      prompt: lvl.prompt,
      chosen: chosenLabel,
      corrects: getCorrectArray(lvl),
      why: lvl.why || ''
    });
  }

  let runStartMs = performance.now();
  function elapsedSeconds() {
    if (!gameStarted) return 0;
    return Math.max(0, (performance.now() - runStartMs) / 1000);
  }
  function fmtTime(sec) {
    const s = Math.floor(sec);
    const mm = String(Math.floor(s / 60)).padStart(2, "0");
    const ss = String(s % 60).padStart(2, "0");
    return `${mm}:${ss}`;
  }

  // ----------------------------
  // HELPERS
  // ----------------------------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const randi = (a, b) => Math.floor(rand(a, b + 1));
  const shuffle = (arr) => arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

  function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }


  function playerHitRect(p) {
    if (p && p.hbW != null && p.hbH != null) {
      return { x: p.x + (p.hbOx || 0), y: p.y + (p.hbOy || 0), w: p.hbW, h: p.hbH };
    }
    return { x: p.x, y: p.y, w: p.w, h: p.h };
  }

  function xOverlap(ax, aw, bx, bw) {
    return Math.max(0, Math.min(ax + aw, bx + bw) - Math.max(ax, bx));
  }
  // ----------------------------
  // PLATFORMS
  // ----------------------------
  let platforms = [];

  const GEN = {
    groundX: -900,
    groundW: 5200,

    minCount: 13,
    maxCount: 26,

    w: PLATFORM_W,
    h: PLATFORM_H,

    gapMin: 110,
    gapMax: 170,


    seamGapMin: 110,
    seamGapMax: 140,
    stepUpMax: 105,
    stepDownMax: 140,

    yMin: 170,
    yMax: 350,
  };

  // ----------------------------
  // WORLD LOOPING (seamless, fully repeating stage)
//
// Goal: the *entire stage* repeats endlessly (platforms + ground), not only the background.
// We treat the platform layout as one repeating segment of length LOOP_LEN.
// For rendering + collision, we consider platform instances in the current segment and its neighbors.
// To keep coordinates bounded (and prevent precision drift), we wrap the player/camera/collectibles
// back by exactly one segment length when approaching the segment edge.
const LOOP_LEN = GEN.groundW;
const LOOP_TRIGGER_PAD = 260;

// Keeps an "unwrapped" camera coordinate for parallax layers.
// When we wrap player/camera by +/- LOOP_LEN, this offset is adjusted so that
// (camera.x + worldWrapOffset) stays continuous. This prevents background jumps.
let worldWrapOffset = 0;

// Offscreen buffers used to produce a stable crossfade at background tile seams.
// We intentionally avoid per-frame canvas allocation to reduce shimmer/jitter.
let seamBufA = null, seamBufB = null;
let seamCtxA = null, seamCtxB = null;
function ensureSeamBuffers(w, h){
  if (!seamBufA) {
    seamBufA = document.createElement('canvas');
    seamBufB = document.createElement('canvas');
    seamCtxA = seamBufA.getContext('2d');
    seamCtxB = seamBufB.getContext('2d');
  }
  if (seamBufA.width !== w || seamBufA.height !== h) {
    seamBufA.width = w; seamBufA.height = h;
    seamBufB.width = w; seamBufB.height = h;
    // Re-acquire contexts after resize (some browsers reset state).
    seamCtxA = seamBufA.getContext('2d');
    seamCtxB = seamBufB.getContext('2d');
  }
}

// Segment origin for the repeating layout (matches the generated ground start).
const loopStartX = GEN.groundX;

function loopOffsetsForX(x){
  const seg = Math.floor((x - loopStartX) / LOOP_LEN);
  return [(seg - 1) * LOOP_LEN, seg * LOOP_LEN, (seg + 1) * LOOP_LEN];
}

function shiftWorld(dx){
  player.x += dx;
  camera.x += dx;
  // Keep unwrapped camera continuous.
  worldWrapOffset -= dx;
  // Keep dynamic entities aligned with the wrapped world.
  for (const e of enemies) e.x += dx;
}

function wrapWorldIfNeeded(){
  const localX = player.x - loopStartX;

  // Wrap right
  if (localX > (LOOP_LEN - LOOP_TRIGGER_PAD)) {
    shiftWorld(-LOOP_LEN);
  }
  // Wrap left
  else if ((player.x + player.w - loopStartX) < LOOP_TRIGGER_PAD) {
    shiftWorld(+LOOP_LEN);
  }
}


function reachableFromGround(platformY) {
    return platformY >= 320 && platformY <= GEN.yMax;
  }
  function generatePlatforms() {
    const list = [];
    const groundY = canvas.height - GROUND_H;
    list.push({ x: GEN.groundX, y: groundY, w: GEN.groundW, h: GROUND_H });

    // First floating platform position (defines the seam reference)
    const firstX = loopStartX + 280;
    let x = firstX;

    let y0 = randi(320, 350);
    if (!reachableFromGround(y0)) y0 = 330;
    list.push({ x, y: y0, w: GEN.w, h: GEN.h });

    // Second platform
    x += GEN.w + randi(GEN.gapMin, GEN.gapMax);
    let y1 = clamp(y0 + randi(-60, 80), GEN.yMin, GEN.yMax);
    list.push({ x, y: y1, w: GEN.w, h: GEN.h });

    // --- Seam control: enforce a bounded gap between segments at the loop seam.
    const seamMin = (GEN.seamGapMin ?? GEN.gapMin);
    const seamMax = (GEN.seamGapMax ?? GEN.gapMax);
    const seamGap = randi(seamMin, seamMax);

    // Want: (firstX + LOOP_LEN) - (lastX + GEN.w) == seamGap
    const forcedLastX = firstX + LOOP_LEN - seamGap - GEN.w;

    // Preserve a small safety margin near the segment end.
    const hardEnd = (loopStartX + LOOP_LEN) - 120;
    let endLimit = Math.min(forcedLastX, hardEnd);
    // If randomization pushes early platforms beyond the desired endLimit, clamp.
    // (This can slightly reduce the seam gap, but avoids empty stretches.)
    if (endLimit < x) endLimit = x;

    function nextPlatformY(prevY) {
      let rawTarget = (Math.random() < 0.5) ? randi(190, 250) : randi(280, 350);
      rawTarget = clamp(rawTarget, GEN.yMin, GEN.yMax);

      let y = rawTarget;
      const dy = y - prevY;
      if (dy < -GEN.stepUpMax) y = prevY - GEN.stepUpMax;
      if (dy >  GEN.stepDownMax) y = prevY + GEN.stepDownMax;

      y = clamp(y + randi(-14, 14), GEN.yMin, GEN.yMax);

      const dy2 = y - prevY;
      if (dy2 < -GEN.stepUpMax) y = prevY - GEN.stepUpMax;
      if (dy2 >  GEN.stepDownMax) y = prevY + GEN.stepDownMax;

      return y;
    }

    // Fill the whole loop segment up to endLimit so there are no long "empty" stretches.
    // Cap iterations defensively.
    let iters = 0;
    const maxIters = Math.max(40, (GEN.maxCount ?? 12) * 4);
    while (iters++ < maxIters) {
      const prev = list[list.length - 1];

      // If we're already at (or extremely near) endLimit, stop.
      if (prev.x >= endLimit - 1) break;

      // Normal next step.
      let nextX = prev.x + GEN.w + randi(GEN.gapMin, GEN.gapMax);

      // Minimum separation between platform left edges (prevents near-duplicate platforms at the segment end).
      const minStartSep = GEN.w + GEN.gapMin;

      // If we'd overshoot endLimit, snap the final candidate to endLimit.
      if (nextX > endLimit) nextX = endLimit;

      // If snapping would create an almost-overlapping "double platform",
      // move the previous platform to endLimit instead of adding a new one.
      if (nextX === endLimit && (endLimit - prev.x) < minStartSep) {
        prev.x = endLimit;
        break;
      }

      // Guard against accidental duplicates.
      if (nextX <= prev.x + 1) break;

      const y = nextPlatformY(prev.y);
      list.push({ x: nextX, y, w: GEN.w, h: GEN.h });
      x = nextX;
    }

    platforms = list;
  }


  // ----------------------------
  // COLLISIONS
  // ----------------------------
  function resolveCollisions(p, dt) {
    // NOTE: physics state is stored on p.x/p.y, but collisions use the hitbox rect.
    // This prevents the sprite's transparent padding from affecting gameplay.
    // Horizontal
    // IMPORTANT: Platforms are treated as "one-way" (land from above). We intentionally do NOT
    // resolve horizontal (side) collisions against platforms because this can cause edge-snapping
    // artifacts when the hitbox barely overlaps a platform while walking off an edge.
    p.x += p.vx * dt;

    // Vertical
    p.y += p.vy * dt;
    p.onGround = false;
    for (const off of loopOffsetsForX(p.x + (p.hbOx || 0))) {
      for (const plat of platforms) {
        const px = plat.x + off;
        const hx = p.x + (p.hbOx || 0);
        const hy = p.y + (p.hbOy || 0);
        const hw = p.hbW != null ? p.hbW : p.w;
        const hh = p.hbH != null ? p.hbH : p.h;
        if (aabb(hx, hy, hw, hh, px, plat.y, plat.w, plat.h)) {
          if (p.vy > 0) {
            // Require a minimum overlap so you drop when only a small corner is still touching.
            const overlap = xOverlap(hx, hw, px, plat.w);
            if (overlap >= MIN_FOOT_OVERLAP) {
              p.y = (plat.y - hh) - (p.hbOy || 0);
              p.vy = 0;
              p.onGround = true;
              p.coyote = WORLD.coyoteTime;
              p.airJumpsLeft = WORLD.maxAirJumps;
            }
          } else if (p.vy < 0) {
            p.y = (plat.y + plat.h) - (p.hbOy || 0);
            p.vy = 0;
          }
        }
      }
    }
  }

  // ----------------------------
  // COLLECTIBLES / FLOW
  // ----------------------------
  let levelIndex = 0;
  let collectibles = [];
  let feedback = { text: "", timer: 0 };
  let transition = { active: false, t: 0, nextLevel: 0 };

  const BOX_W = 110;
  const BOX_H = 48;
  const AIR_OFFSET = 120;

  function pickSpawnPlatforms() {
    const floats = platforms.filter(p => p.h === GEN.h).sort((a,b)=>a.x-b.x);
    const usable = floats.slice(Math.min(2, floats.length));
    const base = (usable.length >= 4) ? usable : floats;

    if (!base.length) return [];
    const n = base.length;
    const q = (a,b) => base.slice(Math.floor(n*a), Math.max(Math.floor(n*a)+1, Math.floor(n*b)));
    const q1=q(0.00,0.25), q2=q(0.25,0.50), q3=q(0.50,0.75), q4=q(0.75,1.00);
    const pick = (bucket) => bucket[Math.floor(Math.random()*bucket.length)];

    if (n >= 4) return [pick(q1), pick(q2), pick(q3), pick(q4)];
    const out = [];
    for (let i=0;i<4;i++) out.push(base[i % n]);
    return out;
  }

  function buildCollectiblesForLevel(i) {
    const lvl = LEVELS[i];
    const opts = shuffle([...lvl.options]);
    const spawnPlats = pickSpawnPlatforms();

    collectibles = opts.map((label, idx) => {
      const p = spawnPlats[idx % spawnPlats.length];
      const x = p ? (p.x + Math.floor((p.w - BOX_W) / 2)) : (loopStartX + 520 + idx*140);
      const y = p ? ((p.y - AIR_OFFSET) - BOX_H) : 220;
            const corrects = Array.isArray(lvl.correct) ? lvl.correct : [lvl.correct];
      return { x, y, w: BOX_W, h: BOX_H, label, isCorrect: corrects.includes(label), active: true };
    });
  }

  function setFeedback(text, seconds = 1.2) {
    feedback.text = text;
    feedback.timer = seconds;
  }

  function beginNextLevelDelay(nextIdx, seconds, message) {
    transition.active = true;
    transition.t = seconds;
    transition.nextLevel = nextIdx;
    setFeedback(message, seconds);
  }

  function finishGame() {
    collectibles = [];
    setFeedback("All done. Tap Restart (or press R) to play again.", 999);
  }

  function loseLife() {
    lives = Math.max(0, lives - 1);
    if (lives <= 0) {
      gameOver = true;
      setFeedback("Game over. Tap Restart (or press R) to try again.", 999);
      // End-of-run review (shows mistakes + explanations)
      setTimeout(() => showReviewModal(), 180);
    }
  }

  function onCorrectPick() {
    soundCorrect();
    triggerFlash("rgba(34,197,94,1)", 0.18);
    score += 100;
    if (levelIndex < LEVELS.length - 1) beginNextLevelDelay(levelIndex + 1, 1.1, "Correct (+100).");
    else { setFeedback("Correct (+100).", 1.2); setTimeout(() => finishGame(), 700); }
  }

  function onWrongPick(chosenLabel) {
    // Record the first wrong attempt for this sentence (for the end-of-run review)
    recordMistake(levelIndex, chosenLabel);
    soundWrong();
    triggerFlash("rgba(239,68,68,1)", 0.22);
    loseLife();
    if (!gameOver) setFeedback("Incorrect. Try again.", 1.4);
  }

  function handleCollectibleCollision() {
    // Collectibles repeat with the looped stage: test against the instance in the
    // current segment and its neighbors.
    const hb = playerHitRect(player);
    const offs = loopOffsetsForX(hb.x);
    for (const c of collectibles) {
      if (!c.active) continue;
      for (const off of offs) {
        const cx = c.x + off;
        if (aabb(hb.x, hb.y, hb.w, hb.h, cx, c.y, c.w, c.h)) {
          c.active = false;
          if (c.isCorrect) onCorrectPick();
          else onWrongPick(c.label);
          return;
        }
      }
    }
  }

  // ----------------------------
  // DRAW HELPERS
  // ----------------------------
  function roundRect(x, y, w, h, r, fill) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if (fill) ctx.fill(); else ctx.stroke();
  }

  function drawWrappedText(text, x, y, maxWidth, lineHeight) {
    const words = String(text || "").split(/\s+/);
    let line = "";
    let yy = y;
    for (let n = 0; n < words.length; n++) {
      const test = line + words[n] + " ";
      const w = ctx.measureText(test).width;
      if (w > maxWidth && n > 0) {
        ctx.fillText(line.trimEnd(), x, yy);
        line = words[n] + " ";
        yy += lineHeight;
      } else {
        line = test;
      }
    }
    if (line) ctx.fillText(line.trimEnd(), x, yy);
  }

  // ----------------------------
  // DRAWING
  // ----------------------------
  function drawBackground() {
    // Sky base (keeps the same clean look as before)
    ctx.save();
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, "#bfe9ff");
    g.addColorStop(0.55, "#d9f4ff");
    g.addColorStop(1, "#f4fbff");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();

    // In-game background image (adapted 'background_side') with parallax scrolling.
    // The image scrolls slower than the camera for depth.
    if (bgReady) {
      const parallax = 0.20;
      const iw = bgImg.naturalWidth || bgImg.width;
      const ih = bgImg.naturalHeight || bgImg.height;

      // Scale image to fill the canvas height (maintains aspect ratio).
      const scale = canvas.height / ih;
      const dw = iw * scale;
      const dh = canvas.height;

      // Parallax tiling in X with a *soft crossfade* at the seam.
      // This avoids visible hard edges when the artwork is not perfectly tileable.
      // Use an unwrapped camera value so parallax does not jump when the world wraps.
      const camXUnwrapped = (typeof worldWrapOffset === 'number') ? (camera.x + worldWrapOffset) : camera.x;
      const raw = -camXUnwrapped * parallax;
      let offsetX = raw % dw;
      if (offsetX > 0) offsetX -= dw;

      // Width of the blended seam region (in screen pixels).
      const blend = Math.max(40, Math.min(140, dw * 0.14));
      const steps = 24; // more steps = smoother blend (costs a few more draw calls)
      const stripW = blend / steps;

      ctx.save();
      const _prevSmooth = ctx.imageSmoothingEnabled;
      ctx.imageSmoothingEnabled = true;
      ctx.globalAlpha = 0.95;

      // 1) Draw the base tiles.
      for (let x = offsetX; x < canvas.width + dw; x += dw) {
        ctx.drawImage(bgImg, x, 0, dw, dh);
      }

      // 2) Crossfade the seam between adjacent tiles.
      // We overlay the *start* of the next tile over the *end* of the current tile
      // with an alpha ramp, creating a smooth transition.
      for (let x = offsetX; x < canvas.width + dw; x += dw) {
        const seamStart = x + dw - blend;
        const nextTileX = x + dw - blend; // shift next tile left so its left edge aligns with seamStart

        for (let i = 0; i < steps; i++) {
          const a = i / (steps - 1);
          const sx = seamStart + i * stripW;

          ctx.save();
          ctx.globalAlpha = 0.95 * a;
          ctx.beginPath();
          ctx.rect(sx, 0, stripW + 0.5, dh);
          ctx.clip();

          // Draw the next tile, shifted left by `blend`, so only its left edge occupies the seam region.
          ctx.drawImage(bgImg, nextTileX, 0, dw, dh);
          ctx.restore();
        }
      }

      ctx.imageSmoothingEnabled = _prevSmooth;
      ctx.restore();

      ctx.save();

      // Overlay: subtle atmospheric haze
      const haze = ctx.createLinearGradient(0, 0, 0, canvas.height);
      haze.addColorStop(0, "rgba(255,255,255,0.20)");
      haze.addColorStop(0.55, "rgba(255,255,255,0.08)");
      haze.addColorStop(1, "rgba(255,255,255,0.00)");
      ctx.fillStyle = haze;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const v = ctx.createRadialGradient(canvas.width*0.5, canvas.height*0.45, 40, canvas.width*0.5, canvas.height*0.45, canvas.width*0.9);
      v.addColorStop(0, "rgba(0,0,0,0)");
      v.addColorStop(1, "rgba(0,0,0,0.10)");
      ctx.fillStyle = v;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    // Moving clouds (independent parallax, keeps motion even if player stands still)
    function puff(x, y, s=1) {
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.16)";
      ctx.shadowBlur = 10;
      ctx.shadowOffsetY = 6;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(x, y, 56*s, 30*s, 0, 0, Math.PI*2);
      ctx.ellipse(x + 42*s, y - 10*s, 48*s, 26*s, 0, 0, Math.PI*2);
      ctx.ellipse(x + 92*s, y, 60*s, 32*s, 0, 0, Math.PI*2);
      ctx.ellipse(x + 52*s, y + 16*s, 68*s, 32*s, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowColor = "transparent";
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(x + 18*s, y - 10*s, 22*s, 12*s, 0, 0, Math.PI*2);
      ctx.ellipse(x + 62*s, y - 16*s, 18*s, 10*s, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Reduce sub-pixel jitter in the cloud layer.
    // Use unwrapped camera for stable looping parallax.
    let cloudOffset = ((camera.x + worldWrapOffset) * 0.35) % 720;
    cloudOffset = Math.round(cloudOffset);
    ctx.save();
    ctx.translate(-cloudOffset, 0);
    for (let i = -1; i < 7; i++) {
      const cx = i * 720 + 120;
      const cy = 90 + (i % 2) * 24;
      puff(cx, cy, 0.95);
      puff(cx + 280, cy + 34, 0.78);
    }
    ctx.restore();
  }



  function drawPlatforms() {
    // Ground keeps the 3D soil/grass look; floating platforms become wooden planks.
    const grassTop = "#63d36f";
    const grassTop2 = "#54c862";
    const dirt = "#b1683d";
    const dirt2 = "#9f5b34";

    function tileFace(x, y, w, h, alpha=0.12) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      const step = 26;
      for (let xx = x + step; xx < x + w; xx += step) {
        ctx.beginPath();
        ctx.moveTo(xx, y + 8);
        ctx.lineTo(xx, y + h - 8);
        ctx.stroke();
      }
      for (let yy = y + step; yy < y + h; yy += step) {
        ctx.beginPath();
        ctx.moveTo(x + 8, yy);
        ctx.lineTo(x + w - 8, yy);
        ctx.stroke();
      }
      ctx.restore();
    }

    function groundBlock(sx, sy, w, h) {
      const capH = Math.max(10, Math.min(16, h));
      const bevel = 10;

      // Drop shadow
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.22)";
      ctx.shadowBlur = 14;
      ctx.shadowOffsetY = 10;
      ctx.fillStyle = dirt2;
      roundRect(sx, sy, w, h, 10, true);
      ctx.restore();

      // Dirt body
      ctx.fillStyle = dirt;
      roundRect(sx, sy, w, h, 10, true);

      // Facet shade
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.moveTo(sx + w, sy + 10);
      ctx.lineTo(sx + w - bevel, sy + 18);
      ctx.lineTo(sx + w - bevel, sy + h - 14);
      ctx.lineTo(sx + w, sy + h - 8);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // Inner band
      ctx.fillStyle = dirt2;
      ctx.fillRect(sx + 2, sy + capH + 2, w - 4, Math.max(0, h - capH - 4));

      // Seams
      tileFace(sx + 6, sy + capH + 6, w - 12, h - capH - 12, 0.10);

      // Grass cap
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.18)";
      ctx.shadowBlur = 10;
      ctx.shadowOffsetY = 6;
      ctx.fillStyle = grassTop;
      roundRect(sx - 2, sy - 2, w + 4, capH + 6, 12, true);
      ctx.restore();

      // Grass highlight
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#fff";
      roundRect(sx + 6, sy + 2, w - 12, Math.max(6, capH*0.45), 10, true);
      ctx.restore();

      // Grass underside shade
      ctx.fillStyle = grassTop2;
      ctx.fillRect(sx - 2, sy + capH + 1, w + 4, 6);

      // Outline
      ctx.strokeStyle = "rgba(15,23,42,0.18)";
      ctx.lineWidth = 2;
      roundRect(sx, sy, w, h, 10, false);
    }

    function woodPlatform(sx, sy, w, h) {
      // render as a chunky plank with plank seams + subtle grain
      const r = 12;
      const topH = Math.max(10, Math.min(16, h));

      // shadow
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = 14;
      ctx.shadowOffsetY = 10;
      ctx.fillStyle = "rgba(0,0,0,0.10)";
      roundRect(sx, sy, w, h, r, true);
      ctx.restore();

      // body gradient
      const grad = ctx.createLinearGradient(sx, sy, sx, sy + h);
      grad.addColorStop(0, "#c98a55");
      grad.addColorStop(0.55, "#b77745");
      grad.addColorStop(1, "#9f643a");
      ctx.fillStyle = grad;
      roundRect(sx, sy, w, h, r, true);

      // top highlight strip
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#fff";
      roundRect(sx + 6, sy + 4, w - 12, Math.min(10, topH), 10, true);
      ctx.restore();

      // plank seams (vertical)
      const plankCount = Math.max(2, Math.round(w / 90));
      const plankW = w / plankCount;
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.strokeStyle = "rgba(15,23,42,0.35)";
      ctx.lineWidth = 2;
      for (let i = 1; i < plankCount; i++) {
        const x = sx + i * plankW;
        ctx.beginPath();
        ctx.moveTo(x, sy + 6);
        ctx.lineTo(x, sy + h - 6);
        ctx.stroke();
      }
      ctx.restore();

      // wood grain (subtle wavy lines)
      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.strokeStyle = "rgba(15,23,42,0.45)";
      ctx.lineWidth = 2;
      const lines = Math.max(2, Math.round(h / 10));
      for (let i = 0; i < lines; i++) {
        const yy = sy + 10 + i * (h - 20) / Math.max(1, lines - 1);
        ctx.beginPath();
        ctx.moveTo(sx + 10, yy);
        const amp = 4;
        for (let xx = sx + 10; xx <= sx + w - 10; xx += 30) {
          ctx.quadraticCurveTo(xx + 15, yy + (i % 2 ? amp : -amp), xx + 30, yy);
        }
        ctx.stroke();
      }
      ctx.restore();

      // nails
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "rgba(15,23,42,0.65)";
      for (let i = 0; i < plankCount; i++) {
        const nx1 = sx + i * plankW + 14;
        const nx2 = sx + (i + 1) * plankW - 14;
        const ny = sy + topH + 10;
        for (const nx of [nx1, nx2]) {
          ctx.beginPath();
          ctx.ellipse(nx, ny, 3.2, 3.2, 0, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();

      // underside shade band
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#000";
      roundRect(sx + 4, sy + h - 12, w - 8, 10, 8, true);
      ctx.restore();

      // outline
      ctx.strokeStyle = "rgba(15,23,42,0.22)";
      ctx.lineWidth = 2;
      roundRect(sx, sy, w, h, r, false);

      // optional simple supports on thicker platforms
      if (h >= 26 && w >= 90) {
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = "rgba(0,0,0,0.20)";
        const postW = 10;
        const postH = Math.min(26, h - 6);
        const left = sx + 18;
        const right = sx + w - 18 - postW;
        roundRect(left, sy + h - postH, postW, postH, 6, true);
        roundRect(right, sy + h - postH, postW, postH, 6, true);
        ctx.restore();
      }
    }

    for (const off of loopOffsetsForX(camera.x + canvas.width * 0.5)) {
      for (const plat of platforms) {
        const sx = (plat.x + off) - camera.x;
        const sy = plat.y - camera.y;
        // quick cull
        if (sx + plat.w < -80 || sx > canvas.width + 80) continue;
        const isGround = plat.h === GROUND_H;
        if (isGround) groundBlock(sx, sy, plat.w, plat.h);
        else woodPlatform(sx, sy, plat.w, plat.h);
      }
    }
  }
  function drawPlayer(p) {
    const sx = p.x - camera.x;
    const sy = p.y - camera.y;


    // DOM sprite overlay for reliable animated GIF playback.
    if (!enemyLayer) {
      // Fallback: if the DOM layer is missing, render a simple placeholder.
      ctx.fillStyle = "rgba(30, 41, 59, 0.95)";
      roundRect(sx, sy, p.w, p.h, 8, true);
      ctx.strokeStyle = "rgba(15,23,42,0.35)";
      ctx.lineWidth = 2;
      roundRect(sx, sy, p.w, p.h, 8, false);
      return;
    }

    // Keep the overlay layer aligned even if there are no enemies.
    syncEnemyLayerToCanvas();

    const r = canvas.getBoundingClientRect();
    const scaleX = r.width / canvas.width;
    const scaleY = r.height / canvas.height;

    const im = ensurePlayerEl();
    if (!im) return;

    // Show the animated GIF only while left/right input is held.
    // When idle, hide the DOM <img> (so the GIF cannot continue animating on-screen)
    // and draw the last frozen frame onto the canvas.
    if (playerMoveInput) {
      if (playerSpriteReady && playerSpriteAnimatedSrc && im.src !== playerSpriteAnimatedSrc) {
        im.src = playerSpriteAnimatedSrc;
      }

      im.style.display = 'block';
      im.style.left = ((sx + PLAYER_SPRITE_OFF_X) * scaleX) + 'px';
      im.style.top = ((sy + PLAYER_SPRITE_OFF_Y) * scaleY) + 'px';
      im.style.width = (p.w * scaleX) + 'px';
      im.style.height = (p.h * scaleY) + 'px';
      im.style.transform = (p.facing === -1) ? 'scaleX(-1)' : '';
    } else {
      // Ensure the animated element is not visible while idle.
      im.style.display = 'none';

      // Draw idle still sprite on the canvas.
      if (playerIdleReady) {
        const dx = sx + PLAYER_SPRITE_OFF_X;
        const dy = sy + PLAYER_SPRITE_OFF_Y;

        ctx.save();
        if (p.facing === -1) {
          // Mirror around the sprite center
          ctx.translate(dx + p.w / 2, dy + p.h / 2);
          ctx.scale(-1, 1);
          ctx.drawImage(playerIdleImg, -p.w / 2, -p.h / 2, p.w, p.h);
        } else {
          ctx.drawImage(playerIdleImg, dx, dy, p.w, p.h);
        }
        ctx.restore();
      } else if (playerFrozenReady) {
        // Fallback: if the Stil image cannot be loaded, use the last frozen GIF frame.
        const dx = sx + PLAYER_SPRITE_OFF_X;
        const dy = sy + PLAYER_SPRITE_OFF_Y;

        ctx.save();
        if (p.facing === -1) {
          ctx.translate(dx + p.w / 2, dy + p.h / 2);
          ctx.scale(-1, 1);
          ctx.drawImage(playerFrozenCanvas, -p.w / 2, -p.h / 2, p.w, p.h);
        } else {
          ctx.drawImage(playerFrozenCanvas, dx, dy, p.w, p.h);
        }
        ctx.restore();
      } else {
        // Fallback placeholder
        ctx.fillStyle = "rgba(30, 41, 59, 0.95)";
        roundRect(sx, sy, p.w, p.h, 8, true);
        ctx.strokeStyle = "rgba(15,23,42,0.35)";
        ctx.lineWidth = 2;
        roundRect(sx, sy, p.w, p.h, 8, false);
      }
    }
  }

  function drawCollectibles() {
    for (const off of loopOffsetsForX(camera.x + canvas.width * 0.5)) {
      for (const c of collectibles) {
        if (!c.active) continue;
        const x = (c.x + off) - camera.x;
        const y = c.y - camera.y;

        // quick cull
        if (x + c.w < -120 || x > canvas.width + 120) continue;

        // Soft shadow
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.22)";
        ctx.shadowBlur = 16;
        ctx.shadowOffsetY = 10;
        ctx.fillStyle = "rgba(255,255,255,0.96)";
        roundRect(x, y, c.w, c.h, 14, true);
        ctx.restore();

        // Face
        ctx.fillStyle = "rgba(255,255,255,0.98)";
        roundRect(x, y, c.w, c.h, 14, true);

        // Top lip (subtle 3D cue)
        ctx.save();
        ctx.globalAlpha = 0.10;
        ctx.fillStyle = "#000";
        roundRect(x + 2, y + 2, c.w - 4, 12, 12, true);
        ctx.restore();

        // Border
        ctx.strokeStyle = "rgba(15,23,42,0.22)";
        ctx.lineWidth = 2;
        roundRect(x, y, c.w, c.h, 14, false);

        // Label
        ctx.fillStyle = "rgba(15,23,42,0.92)";
        ctx.font = "800 17px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(c.label, x + c.w/2, y + c.h/2 + 1);
      }
    }
  }


    function updateHud() {
    if (!hudLevelEl || !hudHeartsEl || !hudScoreEl || !hudTimeEl || !hudPromptEl || !hudFeedbackEl) return;

    const finished = (levelIndex >= LEVELS.length - 1) && collectibles.length === 0 && feedback.timer > 100;
    hudLevelEl.textContent = finished ? "Finished" : `Level ${levelIndex + 1} / ${LEVELS.length}`;

    const heartsFull = "♥".repeat(lives);
    const heartsEmpty = "♡".repeat(MAX_LIVES - lives);
    hudHeartsEl.textContent = `${heartsFull}${heartsEmpty}`;

    hudScoreEl.textContent = `Score: ${score}`;
    hudTimeEl.textContent = `Time: ${fmtTime(elapsedSeconds())}`;

    hudPromptEl.textContent = finished ? "You completed all sentences." : (LEVELS[levelIndex] ? LEVELS[levelIndex].prompt : "");

    const showFeedback = (feedback.timer > 0 && feedback.text);

    hudFeedbackEl.textContent = showFeedback ? feedback.text : "";
    hudFeedbackEl.style.display = showFeedback ? "block" : "none";
    if (hudHintEl) hudHintEl.style.display = showFeedback ? "none" : "";

    // If HUD height changed (e.g., feedback appears), refit the canvas.
    if (hudEl) {
      const h = hudEl.offsetHeight;
      if (Math.abs(h - lastHudHeight) > 1) {
        lastHudHeight = h;
        fitCanvasToViewport();
      }
    }
  }

  function drawTopUI() {
    const pad = 14;
    const boxW = canvas.width - pad * 2;
    const boxH = 70;
    const x = pad;
    const y = pad;

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.88)";
    roundRect(x, y, boxW, boxH, 14, true);

    ctx.strokeStyle = "rgba(15,23,42,0.20)";
    ctx.lineWidth = 2;
    roundRect(x, y, boxW, boxH, 14, false);

    const finished = (levelIndex >= LEVELS.length - 1) && collectibles.length === 0 && feedback.timer > 100;

    ctx.fillStyle = "rgba(15,23,42,0.85)";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(finished ? "Finished" : `Level ${levelIndex + 1} / ${LEVELS.length}`, x + 16, y + 10);

    ctx.font = "600 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textBaseline = "bottom";
    ctx.fillText(finished ? "You completed all sentences." : LEVELS[levelIndex].prompt, x + 16, y + boxH - 12);

    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Score: ${score}   Time: ${fmtTime(elapsedSeconds())}`, x + boxW - 16, y + 10);

    const heartsFull = "♥".repeat(lives);
    const heartsEmpty = "♡".repeat(MAX_LIVES - lives);
    ctx.font = "700 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(15,23,42,0.85)";
    ctx.fillText(`${heartsFull}${heartsEmpty}`, x + boxW - 16, y + 30);

    ctx.font = "500 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(15,23,42,0.65)";
    ctx.textBaseline = "bottom";
    ctx.fillText("←/→ move  •  ↑/Space jump (double jump)  •  R restart", x + boxW - 16, y + boxH - 14);

    if (feedback.timer > 0 && feedback.text) {
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.font = "600 15px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillStyle = "rgba(15,23,42,0.88)";
      drawWrappedText(feedback.text, x + 16, y + boxH + 8, boxW - 32, 18);
    }

    ctx.restore();
  }

  // ----------------------------
  // GAME FLOW
  // ----------------------------
  function spawnRound(i, resetRun = false) {
    levelIndex = clamp(i, 0, LEVELS.length - 1);
    generatePlatforms();
    buildCollectiblesForLevel(levelIndex);
    resetEnemies();
    player = makePlayer();
    camera.x = 0;
    camera.y = 0; // locked
    jumpQueued = false;
    restartQueued = false;
    transition.active = false;
    transition.t = 0;

    if (resetRun) {
      score = 0;
      lives = MAX_LIVES;
      gameOver = false;
      runStartMs = performance.now();
      feedback = { text: "", timer: 0 };
      mistakeLog = [];
      mistakeSeenByLevel = new Set();
      closeReviewModal();
    }
  }

  // ----------------------------
  // UPDATE / RENDER LOOP
  // ----------------------------
  function update(dt) {
        if (restartQueued) {
      restartQueued = false;
      // Restart always randomizes the sentence order for the next run and resets run state.
      shuffleLevels();
      closeReviewModal();
      spawnRound(0, true);
      return;
    }

    if (flash.t > 0) flash.t = Math.max(0, flash.t - dt);

    if (feedback.timer > 0 && feedback.timer < 900) {
      feedback.timer = Math.max(0, feedback.timer - dt);
      if (feedback.timer === 0) feedback.text = "";
    }

    // Pause the simulation until the player presses Start on the intro screen.
    if (!gameStarted) return;

    if (gameOver) return;

    if (transition.active) {
      transition.t = Math.max(0, transition.t - dt);
      if (transition.t === 0) {
        const next = transition.nextLevel;
        transition.active = false;
        spawnRound(next, false);
      }
      return;
    }

    const leftPressed  = isDown("arrowleft")  || touch.left;
    const rightPressed = isDown("arrowright") || touch.right;

    let ax = 0;
    if (leftPressed) ax -= WORLD.moveAccel;
    if (rightPressed) ax += WORLD.moveAccel;
    if (ax !== 0) player.facing = ax > 0 ? 1 : -1;

    player.vx += ax * dt;
    player.vx = clamp(player.vx, -WORLD.maxSpeed, WORLD.maxSpeed);

    if (ax === 0) {
      const fr = Math.pow(WORLD.friction, dt * 60);
      player.vx *= fr;
      if (Math.abs(player.vx) < 10) player.vx = 0;
    }

    // Track whether the player is actively pressing left/right (used to gate GIF animation).
    playerMoveInput = leftPressed || rightPressed;

    // Freeze the current GIF frame when movement input stops.
    if (playerWasMoving && !playerMoveInput) freezePlayerSpriteFrame();
    playerWasMoving = playerMoveInput;

    player.coyote = Math.max(0, player.coyote - dt);
    player.jumpBuf = Math.max(0, player.jumpBuf - dt);

    if (jumpQueued) { player.jumpBuf = WORLD.jumpBuffer; jumpQueued = false; }

    player.vy += WORLD.gravity * dt;
    player.vy = clamp(player.vy, -2000, 2000);

    if (player.jumpBuf > 0) {
      const canGroundJump = player.onGround || player.coyote > 0;
      const canAirJump = !canGroundJump && player.airJumpsLeft > 0;
      if (canGroundJump || canAirJump) {
        player.vy = -WORLD.jumpSpeed;
        playJumpSFX();
        player.onGround = false;
        player.coyote = 0;
        player.jumpBuf = 0;
        if (canAirJump) player.airJumpsLeft -= 1;
      }
    }

    player.prevHb = playerHitRect(player);

    resolveCollisions(player, dt);
    if (collectibles.length) handleCollectibleCollision();

    // Seamless horizontal looping (prevents running off the end of the ground).
    wrapWorldIfNeeded();

    if (player.y > 1200) { setFeedback("Fell. Respawning.", 0.9); spawnRound(levelIndex, false); }

    // Horizontal camera follow only (vertical locked)
    const targetX = player.x - canvas.width * 0.35;
    camera.x += (targetX - camera.x) * (1 - Math.pow(0.001, dt));
    // No hard camera clamp: required for seamless wrapping.
    camera.y = 0;

    // Enemies (time-regulated spawns, move right->left)
    updateEnemies(dt);
    handleEnemyCollision();
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();
    drawPlatforms();
    drawEnemies();
    drawCollectibles();
    drawPlayer(player);
    updateHud();

    if (flash.t > 0) {
      const a = (flash.t / flash.dur) * 0.30;
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = flash.color;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
  }

  let lastTs = 0;
  function loop(ts) {
    const t = ts / 1000;
    const dt = Math.min(0.033, (t - lastTs) || 0);
    lastTs = t;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  spawnRound(0, true);
  // Show the instructions before the first run begins.
  openIntroModal();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
