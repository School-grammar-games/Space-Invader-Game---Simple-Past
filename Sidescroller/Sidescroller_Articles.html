<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Article Side-Scroller (a / an / the / X)</title>
  <style>
    :root{
      --bg1:#cfe9ff; --bg2:#e8f6ff;
      --ground:#5c8a3a; --ground2:#4a732f;
      --btn:#1f2f67;
      --btn2:#23357a;
    }

    *,*::before,*::after{ box-sizing:border-box; }

    html,body{
      height:100%;
      /* Fallback for browsers with dynamic address bars (set via JS as --vh). */
      height: calc(var(--vh, 1vh) * 100);
      min-height:100vh;
      min-height:100dvh;
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background-image: url("Images Sidescroller/background_website.png"),
                  radial-gradient(900px 520px at 20% 15%, rgba(255,255,255,0.90), rgba(255,255,255,0) 60%),
                  radial-gradient(800px 520px at 80% 10%, rgba(255,255,255,0.75), rgba(255,255,255,0) 60%),
                  linear-gradient(var(--bg1), var(--bg2));
      background-size: cover, auto, auto, auto;
      background-position: center, center, center, center;
      background-repeat: no-repeat, no-repeat, no-repeat, no-repeat;
      background-attachment: fixed, fixed, fixed, fixed;
      overflow-x:hidden;
      overflow-y:hidden;
    }

    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      opacity:0.55;
      background:
        radial-gradient(110px 60px at 12% 18%, rgba(255,255,255,0.95), rgba(255,255,255,0) 70%),
        radial-gradient(140px 70px at 18% 16%, rgba(255,255,255,0.90), rgba(255,255,255,0) 70%),
        radial-gradient(120px 60px at 24% 19%, rgba(255,255,255,0.92), rgba(255,255,255,0) 70%),
        radial-gradient(120px 60px at 62% 14%, rgba(255,255,255,0.92), rgba(255,255,255,0) 70%),
        radial-gradient(160px 80px at 70% 12%, rgba(255,255,255,0.90), rgba(255,255,255,0) 70%),
        radial-gradient(120px 60px at 78% 15%, rgba(255,255,255,0.92), rgba(255,255,255,0) 70%),
        radial-gradient(520px 220px at 15% 78%, rgba(45,120,90,0.22), rgba(45,120,90,0) 70%),
        radial-gradient(560px 240px at 55% 82%, rgba(45,120,90,0.20), rgba(45,120,90,0) 72%),
        radial-gradient(520px 220px at 90% 80%, rgba(45,120,90,0.18), rgba(45,120,90,0) 72%);
    }
    body::after{
      content:"";
      position:fixed;
      inset:-2px;
      pointer-events:none;
      background: radial-gradient(1200px 800px at 50% 35%, rgba(0,0,0,0), rgba(0,0,0,0.10) 70%, rgba(0,0,0,0.16) 100%);
      mix-blend-mode:multiply;
      opacity:0.55;
    }

    .wrap{
      height: calc(var(--vh, 1vh) * 100);
      min-height:100vh;
      min-height:100dvh;
      display:grid;
      place-items:center;
      /* Respect notches/home indicators and keep symmetric gutters. */
      padding-top: calc(12px + env(safe-area-inset-top));
      padding-right: calc(12px + env(safe-area-inset-right));
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
      padding-left: calc(12px + env(safe-area-inset-left));
      box-sizing:border-box;
    }

    .frame{
      width:100%;
      max-width:1040px;
      padding:16px;
      border-radius:18px;
      background: rgba(255,255,255,0.32);
      border:1px solid rgba(255,255,255,0.55);
      box-shadow: 0 18px 55px rgba(0,0,0,0.18);
      backdrop-filter: blur(8px);
    }

    canvas{
      width:100%;
      aspect-ratio:16/9;
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.15);
      outline:1px solid rgba(15,23,42,0.10);
      display:block;
      background:transparent;
    }

    .controls-bar{
      margin-top:8px; /* slightly tighter */
      display:flex;
      gap:14px;
      align-items:stretch;
      justify-content:space-between;
      user-select:none;
      -webkit-user-select:none;
    }

    .ctrl{
      flex:1 1 0;
      height:64px;
      border-radius:14px;
      background:linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 10px 24px rgba(0,0,0,0.18);
      color:#fff;
      font-weight:800;
      font-size:20px;
      letter-spacing:0.2px;
      display:grid;
      place-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      cursor:pointer;
    }
    .ctrl.smalltxt{ font-size:18px; }
    .ctrl:active, .ctrl.pressed{
      transform: translateY(1px);
      filter: brightness(1.07);
      box-shadow:0 7px 18px rgba(0,0,0,0.18);
    }

    /* Enemy GIF layer (DOM-based so animated GIFs advance reliably) */
    #enemyLayer{
      position:fixed;
      left:0;
      top:0;
      width:0;
      height:0;
      pointer-events:none;
      overflow:hidden;
      z-index: 2000;
    }
    #enemyLayer img{
      position:absolute;
      left:0;
      top:0;
      width:0;
      height:0;
      user-select:none;
      -webkit-user-select:none;
      pointer-events:none;
      image-rendering:auto;
      transform-origin: center center;
    }

    /* Responsive tweaks for short viewports (common on phones in landscape). */
    @media (max-height: 500px) and (orientation: landscape){
      .wrap{
        padding-top: calc(8px + env(safe-area-inset-top));
        padding-right: calc(8px + env(safe-area-inset-right));
        padding-bottom: calc(8px + env(safe-area-inset-bottom));
        padding-left: calc(8px + env(safe-area-inset-left));
      }
      .frame{ width:100%; max-width:1040px; padding:10px; }
      .controls-bar{ gap:10px; margin:0; }
      .ctrl{ height:48px; font-size:14px; border-radius:12px; }
      .ctrl.smalltxt{ font-size:14px; }
    }
    /* HUD (Level / Hearts / Score / Restart) */
    .hud{
      margin-bottom:6px;
      padding:3px 8px;
      border-radius:10px;
      background: rgba(255,255,255,0.88);
      border:1px solid rgba(255,255,255,0.55);
      box-shadow:0 6px 14px rgba(0,0,0,0.10);
      outline:1px solid rgba(15,23,42,0.08);
    }
    .hud-top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex-wrap:nowrap;
    }
    .hud-left, .hud-right{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:nowrap;
    }
    .hud-level{ font-weight:800; font-size:11.5px; color:rgba(15,23,42,0.85); }
    .hud-hearts{ font-weight:900; font-size:13.5px; letter-spacing:0.5px; color:rgba(220,38,38,0.95); }
    .hud-score{ font-weight:800; font-size:11.5px; color:rgba(15,23,42,0.85); }
        .hud-best{ font-weight:800; font-size:11.5px; color:rgba(15,23,42,0.85); }
    .hud-time{ font-weight:700; font-size:11.5px; color:rgba(15,23,42,0.70); }

    .hud-restart{
      height:24px;
      padding:0 10px;
      border-radius:10px;
      background:linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 6px 12px rgba(0,0,0,0.16);
      color:#fff;
      font-weight:800;
      font-size:11.5px;
      letter-spacing:0.2px;
      display:inline-grid;
      place-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;
      cursor:pointer;
      white-space:nowrap;
    }
    .hud-restart:active{
      transform: translateY(1px);
      filter: brightness(1.07);
      box-shadow:0 5px 10px rgba(0,0,0,0.16);
    }

    .hud-row2{
      margin-top:1px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:8px;
    }
    .hud-prompt{
      margin:0;
      flex:1 1 auto;
      min-width:0;
      font-weight:850;
      font-size:14px;
      color:rgba(15,23,42,0.92);
      line-height:1.12;
    }
    .hud-meta-right{
      display:flex;
      align-items:flex-end;
      justify-content:flex-end;
      gap:8px;
      white-space:nowrap;
    }
    .hud-hint{
      margin:0;
      font-weight:600;
      font-size:10px;
      color:rgba(15,23,42,0.60);
      white-space:nowrap;
    }
    .hud-feedback{
      margin:0;
      font-weight:800;
      font-size:11.5px;
      color:rgba(15,23,42,0.88);
      white-space:nowrap;
      display:none;
    }

    @media (max-width: 720px){
      .hud-top{ flex-wrap:wrap; }
      .hud-left, .hud-right{ flex-wrap:wrap; }
      .hud-meta-right{ white-space:normal; }
      .hud-hint, .hud-feedback{ white-space:normal; }
    }

    @media (max-height: 500px) and (orientation: landscape){
      .hud{ margin-bottom:6px; padding:3px 8px; }
      .hud-prompt{ font-size:14px; }
      .hud-restart{ height:24px; font-size:10px; }
      .hud-hint{ font-size:10px; }
    }


  

    /* Review modal (end-of-run mistakes) */
    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: calc(14px + env(safe-area-inset-top))
               calc(14px + env(safe-area-inset-right))
               calc(14px + env(safe-area-inset-bottom))
               calc(14px + env(safe-area-inset-left));
      background: rgba(0,0,0,0.55);
      z-index: 9999;
    }
    .modal.open{ display:flex; }

    .modal-card{
      width: min(920px, 100%);
      max-height: min(80vh, 720px);
      overflow:hidden;
      border-radius: 16px;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(15,23,42,0.12);
      box-shadow: 0 18px 55px rgba(0,0,0,0.28);
      display:flex;
      flex-direction:column;
    }
    .modal-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(15,23,42,0.10);
      background: rgba(248,250,252,0.92);
    }
    .modal-title{
      font-weight: 900;
      font-size: 15px;
      color: rgba(15,23,42,0.90);
    }
    .modal-close{
      width: 34px;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(15,23,42,0.12);
      background: rgba(255,255,255,0.95);
      cursor:pointer;
      font-size: 20px;
      line-height: 30px;
      font-weight: 800;
      color: rgba(15,23,42,0.70);
    }
    .modal-close:active{ transform: translateY(1px); }

    .modal-body{
      padding: 12px 14px;
      overflow:auto;
    }
    .mistake-item{
      border: 1px solid rgba(15,23,42,0.10);
      border-radius: 12px;
      padding: 10px 10px;
      background: rgba(255,255,255,0.96);
      box-shadow: 0 8px 18px rgba(0,0,0,0.06);
      margin-bottom: 10px;
    }
    .mistake-sentence{
      font-weight: 800;
      font-size: 13.5px;
      color: rgba(15,23,42,0.88);
      margin-bottom: 6px;
    }
    .mistake-meta{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-bottom: 6px;
    }
    .pill{
      display:inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.06);
      border: 1px solid rgba(15,23,42,0.10);
      font-weight: 700;
      font-size: 12px;
      color: rgba(15,23,42,0.78);
    }
    .mistake-why{
      margin: 0;
      font-size: 12.5px;
      line-height: 1.35;
      color: rgba(15,23,42,0.80);
    }

    .modal-actions{
      padding: 12px 14px;
      border-top: 1px solid rgba(15,23,42,0.10);
      display:flex;
      justify-content:flex-end;
      gap:10px;
      background: rgba(248,250,252,0.92);
    }
    .modal-btn{
      height: 36px;
      padding: 0 14px;
      border-radius: 12px;
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 10px 20px rgba(0,0,0,0.16);
      color:#fff;
      font-weight:900;
      cursor:pointer;
    }
    .modal-btn:active{ transform: translateY(1px); }

    /* Intro / Instructions screen (before start) */
    .intro-modal{ z-index: 10000; }
    .intro-card{
      width: min(920px, 100%);
      max-height: min(82vh, 740px);
      overflow:hidden;
      border-radius: 18px;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(15,23,42,0.12);
      box-shadow: 0 18px 55px rgba(0,0,0,0.30);
      display:flex;
      flex-direction:column;
    }
    .intro-head{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(15,23,42,0.10);
      background:
        radial-gradient(900px 240px at 10% 0%, rgba(191,233,255,0.85), rgba(255,255,255,0) 60%),
        radial-gradient(700px 260px at 90% 10%, rgba(217,244,255,0.80), rgba(255,255,255,0) 60%),
        rgba(248,250,252,0.96);
    }
    .intro-title{
      margin:0;
      font-weight: 950;
      font-size: 18px;
      letter-spacing: 0.2px;
      color: rgba(15,23,42,0.90);
    }
    .intro-subtitle{
      margin: 4px 0 0;
      font-weight: 650;
      font-size: 12.5px;
      color: rgba(15,23,42,0.70);
      line-height: 1.35;
    }
    .intro-body{
      padding: 14px 16px;
      overflow:auto;
      background:
        radial-gradient(900px 420px at 20% 0%, rgba(191,233,255,0.40), rgba(255,255,255,0) 60%),
        radial-gradient(900px 420px at 80% 0%, rgba(217,244,255,0.35), rgba(255,255,255,0) 60%),
        rgba(255,255,255,0.96);
    }
    .intro-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 720px){
      .intro-grid{ grid-template-columns: 1fr; }
    }
    .intro-section{
      border: 1px solid rgba(15,23,42,0.10);
      border-radius: 14px;
      padding: 12px 12px;
      background: rgba(255,255,255,0.92);
      box-shadow: 0 10px 22px rgba(0,0,0,0.06);
    }
    .intro-h{
      margin:0 0 6px;
      font-weight: 900;
      font-size: 13.5px;
      color: rgba(15,23,42,0.88);
    }
    .intro-p{
      margin:0;
      font-size: 12.5px;
      line-height: 1.45;
      color: rgba(15,23,42,0.78);
    }
    .intro-ul{
      margin: 6px 0 0;
      padding-left: 18px;
      font-size: 12.5px;
      line-height: 1.45;
      color: rgba(15,23,42,0.78);
    }
    .intro-ul li{ margin: 3px 0; }
    .intro-foot{
      padding: 12px 16px;
      border-top: 1px solid rgba(15,23,42,0.10);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      background: rgba(248,250,252,0.94);
      flex-wrap:wrap;
    }
    .intro-note{
      margin:0;
      font-size: 11.5px;
      color: rgba(15,23,42,0.65);
      line-height: 1.35;
    }
    .intro-start{
      height: 38px;
      padding: 0 16px;
      border-radius: 14px;
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 12px 22px rgba(0,0,0,0.18);
      color:#fff;
      font-weight:950;
      letter-spacing: 0.2px;
      cursor:pointer;
      white-space:nowrap;
    }
    .intro-start:active{ transform: translateY(1px); filter: brightness(1.07); }
    /* Boss encounter modal (every 10 correct answers) */
    .boss-modal{ z-index: 10002; }
    .boss-card{
      width: min(860px, 100%);
      max-height: min(82vh, 760px);
      overflow:hidden;
      border-radius: 18px;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(15,23,42,0.12);
      box-shadow: 0 20px 60px rgba(0,0,0,0.34);
      display:flex;
      flex-direction:column;
    }
    .boss-head{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(15,23,42,0.10);
      background:
        radial-gradient(900px 240px at 10% 0%, rgba(255,216,191,0.55), rgba(255,255,255,0) 60%),
        radial-gradient(700px 260px at 90% 10%, rgba(217,244,255,0.55), rgba(255,255,255,0) 60%),
        rgba(248,250,252,0.96);
    }
    
    .boss-head-top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
    }
    .boss-timer{
      flex: 0 0 auto;
      font-weight: 900;
      font-size: 12.5px;
      color: rgba(15,23,42,0.78);
      background: rgba(15,23,42,0.06);
      border: 1px solid rgba(15,23,42,0.10);
      padding: 6px 10px;
      border-radius: 999px;
      white-space:nowrap;
      margin-top: 2px;
    }
.boss-title{
      margin:0;
      font-weight: 950;
      font-size: 18px;
      color: rgba(15,23,42,0.90);
      letter-spacing: 0.2px;
    }
    .boss-sub{
      margin-top: 4px;
      font-size: 12.5px;
      line-height: 1.35;
      color: rgba(15,23,42,0.70);
    }
    .boss-body{
      padding: 14px 16px;
      overflow:auto;
      background: rgba(255,255,255,0.96);
    }
    .boss-quiz{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .boss-item{
      border: 1px solid rgba(15,23,42,0.10);
      border-radius: 14px;
      padding: 10px 10px;
      background: rgba(255,255,255,0.96);
      box-shadow: 0 10px 22px rgba(0,0,0,0.06);
      display:flex;
      gap: 10px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .boss-num{
      width: 26px;
      height: 26px;
      border-radius: 10px;
      display:grid;
      place-items:center;
      font-weight: 950;
      font-size: 13px;
      background: rgba(15,23,42,0.06);
      border: 1px solid rgba(15,23,42,0.10);
      color: rgba(15,23,42,0.80);
      flex: 0 0 auto;
      margin-top: 2px;
    }
    .boss-qwrap{ flex: 1 1 280px; min-width: 240px; }
    .boss-q{
      margin: 0 0 8px;
      font-weight: 850;
      font-size: 13.5px;
      line-height: 1.35;
      color: rgba(15,23,42,0.88);
    }
    .boss-input{
      width: 100%;
      max-width: 320px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid rgba(15,23,42,0.14);
      background: rgba(255,255,255,0.96);
      padding: 0 10px;
      font-size: 14px;
      font-weight: 700;
      outline: none;
    }
    .boss-input:focus{
      border-color: rgba(56,189,248,0.65);
      box-shadow: 0 0 0 3px rgba(56,189,248,0.18);
    }
    .boss-foot{
      padding: 12px 16px;
      border-top: 1px solid rgba(15,23,42,0.10);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      background: rgba(248,250,252,0.94);
      flex-wrap:wrap;
    }
    .boss-note{
      margin:0;
      font-size: 11.5px;
      color: rgba(15,23,42,0.65);
      line-height: 1.35;
    }
    .boss-submit{
      height: 38px;
      padding: 0 16px;
      border-radius: 14px;
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 12px 22px rgba(0,0,0,0.18);
      color:#fff;
      font-weight:950;
      letter-spacing: 0.2px;
      cursor:pointer;
      white-space:nowrap;
    }
    .boss-submit:active{ transform: translateY(1px); filter: brightness(1.07); }


  </style>
</head>
<body>
  <div class="wrap">
    <div class="frame">

      <div class="hud" aria-label="Status">
        <div class="hud-top">
          <div class="hud-left">
            <div class="hud-level" id="hudLevel">Level 1 / 100</div>
            <div class="hud-hearts" id="hudHearts" aria-label="Lives">♥♥♥♥♥</div>
          </div>
          <div class="hud-right">
            <div class="hud-score" id="hudScore">Score: 0</div>
                        <div class="hud-best" id="hudBest">Best: 0</div>
<div class="hud-time" id="hudTime">Time: 00:00</div>
            <div class="hud-restart" id="btnRestart" role="button" aria-label="Restart">Restart</div>
            <div class="hud-restart" id="btnMute" role="button" aria-label="Mute">Mute</div>
            <div class="hud-restart" id="btnReadout" role="button" aria-label="Read Out">Read Out: On</div>
          </div>
        </div>
        <div class="hud-row2">
          <div class="hud-prompt" id="hudPrompt"></div>
          <div class="hud-meta-right">
            <div class="hud-hint" id="hudHint">Collect the correct article • ◀ / ▶ move • Jump (↑ / Space) • Stomp enemies • MedKit every 3 correct answers</div>
            <div class="hud-feedback" id="hudFeedback"></div>
          </div>
        </div>
      </div>

      <canvas id="game" width="960" height="540"></canvas>
      <div id="enemyLayer" aria-hidden="true"></div>

      <div class="controls-bar" aria-label="Controls">
        <div class="ctrl" id="btnLeft" role="button" aria-label="Move left">◀</div>
        <div class="ctrl smalltxt" id="btnJump" role="button" aria-label="Jump">Jump</div>
        <div class="ctrl" id="btnRight" role="button" aria-label="Move right">▶</div>
      </div>
    </div>
  </div>

  <!-- Intro / Instructions (shown before the first run starts) -->
  <div class="modal intro-modal" id="introModal" aria-hidden="true">
    <div class="intro-card" role="dialog" aria-modal="true" aria-labelledby="introTitle">
      <div class="intro-head">
        <div>
          <div class="intro-title" id="introTitle">The Grammar Runner</div>
          <div class="intro-subtitle">Read the controls and the rules, then press Start to begin.</div>
        </div>
      </div>
      <div class="intro-body">
        <div class="intro-grid">
          <div class="intro-section">
            <div class="intro-h">Goal</div>
            <p class="intro-p">Run into the article that correctly completes the sentence shown in the HUD. Each correct pick advances you to the next level. Watch out for ground enemies—stomp them by jumping on top.</p>
          </div>

          <div class="intro-section">
            <div class="intro-h">Lives & scoring</div>
            <ul class="intro-ul">
              <li>Correct: +100 points and the next sentence appears.</li>
              <li>Wrong: you lose a life (♥). When all lives are gone, the run ends.</li>
              <li>After game over, you can review mistakes with accepted answers and a brief explanation.</li>
            </ul>
          </div>

          <div class="intro-section">
            <div class="intro-h">Controls (keyboard)</div>
            <ul class="intro-ul">
              <li>Move: <strong>←</strong> / <strong>→</strong></li>
              <li>Jump (double jump): <strong>↑</strong> or <strong>Space</strong></li>
              <li>Restart: <strong>Restart</strong> button (HUD)</li>
            </ul>
          </div>

          <div class="intro-section">
            <div class="intro-h">Controls (touch)</div>
            <ul class="intro-ul">
              <li>Use the on-screen buttons: ◀, Jump, ▶</li>
              <li>Tap Restart in the HUD to start over.</li>
            </ul>
          </div>
        </div>

          <div class="intro-section">
            <div class="intro-h">Enemies & MedKits</div>
            <ul class="intro-ul">
              <li>Touching an enemy costs 1 life.</li>
              <li>Jump on top of an enemy to defeat it.</li>
              <li>Every 3 correct answers, a MedKit spawns. Collect it to restore full life.</li>
              <li>If you do not collect the MedKit, it disappears after 2 more answered sentences.</li>
            </ul>
          </div>

      </div>
      <div class="intro-foot">
        <p class="intro-note">Tip: sound may start after your first tap/keypress (browser autoplay rules).</p>
        <button class="intro-start" id="introStart" type="button">Start</button>
      </div>
    </div>
  </div>


  <!-- Boss encounter (every 10 correct answers) -->
  <div class="modal boss-modal" id="bossModal" aria-hidden="true">
    <div class="boss-card" role="dialog" aria-modal="true" aria-labelledby="bossTitle">
      <div class="boss-head">
        <div class="boss-head-top">
          <div class="boss-title" id="bossTitle">Boss challenge</div>
          <div class="boss-timer" id="bossTimer">Time left: 30s</div>
        </div>
        <div class="boss-sub">Fill in the correct article (a, an, the, or X). Each wrong answer makes the boss shoot a feather.</div>
      </div>
      <div class="boss-body">
        <div class="boss-quiz" id="bossQuizBody"></div>
      </div>
      <div class="boss-foot">
        <p class="boss-note">Answers are not case-sensitive. Type a, an, the, or X (for no article).</p>
        <button class="boss-submit" id="bossSubmit" type="button">Submit</button>
      </div>
    </div>
  </div>

  <div class="modal" id="reviewModal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="reviewTitle">
      <div class="modal-head">
        <div class="modal-title" id="reviewTitle">Review mistakes</div>
        <button class="modal-close" id="reviewClose" type="button" aria-label="Close">×</button>
      </div>
      <div class="modal-body" id="reviewBody"></div>
      <div class="modal-actions">
        <button class="modal-btn" id="reviewRestart" type="button">Restart</button>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const enemyLayer = document.getElementById("enemyLayer");

  // IMPORTANT: The game frame uses backdrop-filter, which can create a containing block
  // for position:fixed descendants in some browsers. That breaks viewport-based positioning
  // when we align DOM sprites using getBoundingClientRect(). To keep coordinates consistent,
  // ensure the enemy layer lives directly under <body>.
  if (enemyLayer && enemyLayer.parentElement !== document.body) {
    document.body.appendChild(enemyLayer);
  }

  function syncEnemyLayerToCanvas(){
    if (!enemyLayer) return;
    const r = canvas.getBoundingClientRect();
    enemyLayer.style.left = r.left + 'px';
    enemyLayer.style.top = r.top + 'px';
    enemyLayer.style.width = r.width + 'px';
    enemyLayer.style.height = r.height + 'px';
  }

  // ----------------------------
  // HUD (DOM)
  // ----------------------------
  const hudLevelEl = document.getElementById("hudLevel");
  const hudHeartsEl = document.getElementById("hudHearts");
  const hudScoreEl = document.getElementById("hudScore");
    const hudBestEl = document.getElementById("hudBest");
const hudTimeEl = document.getElementById("hudTime");
  const hudPromptEl = document.getElementById("hudPrompt");
  const hudHintEl = document.getElementById("hudHint");
  const hudFeedbackEl = document.getElementById("hudFeedback");
  const btnRestart = document.getElementById("btnRestart");
  const btnMute = document.getElementById("btnMute");


  
  const btnReadout = document.getElementById("btnReadout");

// ----------------------------
  // REVIEW MODAL (mistakes)
  // ----------------------------
  const reviewModalEl = document.getElementById("reviewModal");
  const reviewCloseEl = document.getElementById("reviewClose");
  const reviewRestartEl = document.getElementById("reviewRestart");
  const reviewBodyEl = document.getElementById("reviewBody");

  // ----------------------------
  // INTRO MODAL (before first start)
  // ----------------------------
  const introModalEl = document.getElementById("introModal");
  const introStartEl = document.getElementById("introStart");
  // ----------------------------
  // BOSS MODAL (every 10 correct answers)
  // ----------------------------
  const bossModalEl = document.getElementById("bossModal");
  const bossQuizBodyEl = document.getElementById("bossQuizBody");
  const bossSubmitEl = document.getElementById("bossSubmit");
  const bossTimerEl = document.getElementById("bossTimer");

  function openBossModal(){
    if (!bossModalEl) return;
    bossModalEl.classList.add('open');
    bossModalEl.setAttribute('aria-hidden','false');
  }
  function closeBossModal(){
    if (!bossModalEl) return;
    bossModalEl.classList.remove('open');
    bossModalEl.setAttribute('aria-hidden','true');
    if (bossTimerEl) bossTimerEl.textContent = "Time left: 30s";
  }


  function openIntroModal(){
    if (!introModalEl) return;
    introModalEl.classList.add('open');
    introModalEl.setAttribute('aria-hidden','false');
  }
  function closeIntroModal(){
    if (!introModalEl) return;
    introModalEl.classList.remove('open');
    introModalEl.setAttribute('aria-hidden','true');
  }

  function startGameFromIntro(){
    if (gameStarted) return;
    ensureAudio();

    startBGM();
    try { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch(_) {}
    gameStarted = true;
    closeIntroModal();

    

    // Read out the first sentence immediately after the intro.
    maybeSpeakCurrentPrompt(true);
// Clear any buffered input that may have occurred while reading the instructions.
    jumpQueued = false;
    restartQueued = false;
    setFeedback("", 0);
  }

  if (introStartEl) introStartEl.addEventListener('click', () => startGameFromIntro());
  if (bossSubmitEl) bossSubmitEl.addEventListener('click', () => {
    if (!bossEncounterInProgress || bossPhase !== "quiz") return;
    const wrong = computeBossWrongCount();
    closeBossModal();
    bossPhase = "attack";
    bossAttackFallbackT = 0.45;
    setFeedback(wrong ? `Boss attacks: ${wrong} feather${wrong===1?'':'s'}!` : "Perfect. No feathers.", 1.6);
    if (wrong > 0) {
      try { fireBossFeathers(wrong); } catch(_) {}
      if (!bossFeathers.length) {
        // Safety: never get stuck in attack phase if feathers could not spawn.
        bossAttackFallbackT = Math.min(bossAttackFallbackT, 0.45);
      }
    } else {
      endBossEncounter();
    }
  });

  // Submit with Enter from any boss input.
  if (bossModalEl) bossModalEl.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter') {
      ev.preventDefault();
      try { bossSubmitEl && bossSubmitEl.click(); } catch(_) {}
    }
  });



  function escapeHtml(s){
    return String(s)
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;')
      .replace(/'/g,'&#39;');
  }

  function closeReviewModal(){
    if (!reviewModalEl) return;
    reviewModalEl.classList.remove('open');
    reviewModalEl.setAttribute('aria-hidden','true');
  }

  function showReviewModal(){
    if (!reviewModalEl || !reviewBodyEl) return;

    const total = mistakeLog.length;
    if (total === 0) {
      reviewBodyEl.innerHTML = '<div class="mistake-item"><div class="mistake-sentence">No mistakes recorded.</div><p class="mistake-why">Restart to play again.</p></div>';
    } else {
      const header = `<div class="mistake-item"><div class="mistake-sentence">End of run review</div><p class="mistake-why">You made ${total} mistake${total===1?'':'s'}. Each item shows the accepted answer(s) and a brief reason.</p></div>`;
      const items = mistakeLog.map(m => {
        const chosen = escapeHtml(m.chosen);
        const corrects = escapeHtml(m.corrects.join(' / '));
        const why = escapeHtml(m.why || '');
        return `
          <div class="mistake-item">
            <div class="mistake-sentence">${escapeHtml(m.prompt)}</div>
            <div class="mistake-meta">
              <span class="pill">Your answer: ${chosen}</span>
              <span class="pill">Accepted: ${corrects}</span>
            </div>
            <p class="mistake-why">${why}</p>
          </div>`;
      }).join('');
      reviewBodyEl.innerHTML = header + items;
    }

    reviewModalEl.classList.add('open');
    reviewModalEl.setAttribute('aria-hidden','false');
  }

  if (reviewCloseEl) reviewCloseEl.addEventListener('click', () => closeReviewModal());
  if (reviewRestartEl) reviewRestartEl.addEventListener('click', () => { closeReviewModal(); restartQueued = true; });
  if (reviewModalEl) reviewModalEl.addEventListener('click', (e) => { if (e.target === reviewModalEl) closeReviewModal(); });
  let lastHudHeight = 0;


  // ----------------------------
  // RESPONSIVE FIT (mobile)
  // ----------------------------
  const frameEl = document.querySelector('.frame');
  const controlsEl = document.querySelector('.controls-bar');
  const hudEl = document.querySelector('.hud');
  const wrapEl = document.querySelector('.wrap');
  const BASE_W = canvas.width;
  const BASE_H = canvas.height;

  // Mobile browsers (notably iOS Safari) report fluctuating CSS viewport units as the
  // address bar shows/hides. We set a JS-driven --vh custom property as a stable fallback.
  function setVhVar(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }

  function getViewportSize(){
    const vv = window.visualViewport;
    if (vv) return { w: vv.width, h: vv.height };
    return { w: window.innerWidth, h: window.innerHeight };
  }

  function fitCanvasToViewport(){
    // Compute available size while preserving the 16:9 game aspect.
    const vp = getViewportSize();
    const vh = vp.h;
    let maxW = frameEl ? frameEl.clientWidth : vp.w;

    const wrapStyle = wrapEl ? getComputedStyle(wrapEl) : null;
    const frameStyle = frameEl ? getComputedStyle(frameEl) : null;
    const framePadX = frameStyle ? (parseFloat(frameStyle.paddingLeft) + parseFloat(frameStyle.paddingRight)) : 0;
    maxW = Math.max(160, Math.min((maxW - framePadX), (vp.w - 2)));
    const controlsStyle = controlsEl ? getComputedStyle(controlsEl) : null;
    const hudStyle = hudEl ? getComputedStyle(hudEl) : null;

    const wrapPad = wrapStyle ? (parseFloat(wrapStyle.paddingTop) + parseFloat(wrapStyle.paddingBottom)) : 0;
    const framePad = frameStyle ? (parseFloat(frameStyle.paddingTop) + parseFloat(frameStyle.paddingBottom)) : 0;
    const controlsMarginTop = controlsStyle ? (parseFloat(controlsStyle.marginTop) || 0) : 0;
    const controlsH = controlsEl ? controlsEl.offsetHeight : 0;

    const hudMargin = hudStyle ? ((parseFloat(hudStyle.marginTop) || 0) + (parseFloat(hudStyle.marginBottom) || 0)) : 0;
    const hudH = hudEl ? hudEl.offsetHeight : 0;

    // Small safety buffer helps across browsers with dynamic toolbars.
    const extra = wrapPad + framePad + hudH + hudMargin + controlsH + controlsMarginTop + 6;
    const maxH = Math.max(160, vh - extra);

    const scale = Math.min(maxW / BASE_W, maxH / BASE_H);
    const cssW = Math.max(1, Math.floor(BASE_W * scale));
    const cssH = Math.max(1, Math.floor(BASE_H * scale));

    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.style.margin = '0 auto';

    // Keep the DOM enemy layer aligned to the canvas.
    syncEnemyLayerToCanvas();
  }

  // Keep the CSS viewport fallback current.
  setVhVar();
  window.addEventListener('resize', () => { setVhVar(); fitCanvasToViewport(); });
  window.addEventListener('orientationchange', () => setTimeout(() => { setVhVar(); fitCanvasToViewport(); }, 120));
  if (window.visualViewport) {
    // visualViewport events fire when the browser chrome collapses/expands.
    window.visualViewport.addEventListener('resize', () => { setVhVar(); fitCanvasToViewport(); });
    window.visualViewport.addEventListener('scroll', () => { setVhVar(); fitCanvasToViewport(); });
  }
  // Initial sizing
  fitCanvasToViewport();

  // ----------------------------
  // BACKGROUND IMAGE (parallax)
  // ----------------------------
  const bgImg = new Image();
  bgImg.decoding = "async";
  bgImg.src = "Images Sidescroller/background_sidescroller.png";
  let bgReady = false;
  bgImg.onload = () => { bgReady = true; };




// ----------------------------
// MEDKIT (image)
// ----------------------------
const medkitImg = new Image();
medkitImg.decoding = "async";
medkitImg.src = "Images Sidescroller/MedKit.png";
let medkitReady = false;
medkitImg.onload = () => { medkitReady = true; };

// ----------------------------
// ENEMIES (GIFs, animated)
// ----------------------------
// NOTE ON ANIMATED GIFS IN CANVAS
// Some browsers (especially when running local files) can fail to advance GIF frames
// reliably unless the <img> element is present in the DOM. To ensure animations play,
// we create a hidden <img> element and append it to the document.
// Keep a tiny, (almost) invisible container in-viewport so browsers actually paint the GIFs,
// which is required in some engines to advance frames when we later draw them to <canvas>.
let __gifKeeper = null;
function getGifKeeper() {
  if (__gifKeeper) return __gifKeeper;
  const d = document.createElement("div");
  d.setAttribute("aria-hidden", "true");
  d.style.position = "fixed";
  d.style.right = "0";
  d.style.bottom = "0";
  // Keep it in the viewport and actually paintable, but imperceptible.
  // Some engines (notably Safari/WebKit) will not advance GIF frames for elements that
  // are fully transparent, off-screen, or behind the page background.
  d.style.width = "16px";
  d.style.height = "16px";
  d.style.overflow = "hidden";
  d.style.opacity = "0.001"; // must be > 0 to keep animation ticking
  d.style.pointerEvents = "none";
  d.style.zIndex = "2147483647";
  d.style.background = "transparent";
  d.style.transform = "translateZ(0)";
  document.body.appendChild(d);
  __gifKeeper = d;
  return d;
}

function loadAnimatedImageWithFallback(paths) {
  const img = document.createElement("img");
  img.decoding = "sync";
  img.loading = "eager";
  img.style.width = "16px";
  img.style.height = "16px";
  img.style.display = "block";
  img.style.position = "absolute";
  img.style.left = "0";
  img.style.top = "0";
  getGifKeeper().appendChild(img);

  let i = 0;
  const tryNext = () => {
    if (i >= paths.length) return;
    img.src = paths[i++];
  };
  img.onerror = tryNext;
  tryNext();
  return img;
}

// Prefer the user project's folder structure ("Images Sidescroller"), but fall back to a local "Enemies" folder.
const groundEnemyImg = loadAnimatedImageWithFallback([
  "Images Sidescroller/Ground enemy.gif",
  "Enemies/Ground enemy.gif",
  "Ground enemy.gif",
]);
const flyingEnemyImg = loadAnimatedImageWithFallback([
  "Images Sidescroller/Flying enemy.gif",
  "Enemies/Flying enemy.gif",
  "Flying enemy.gif",
]);

let groundEnemyReady = false;
let flyingEnemyReady = false;
groundEnemyImg.onload = () => { groundEnemyReady = true; };
flyingEnemyImg.onload = () => { flyingEnemyReady = true; };

// ----------------------------
// PLAYER (GIF, animated)
// ----------------------------
// We keep the player sprite as a DOM <img> (positioned over the canvas),
// just like enemies. This ensures animated GIF frames advance reliably
// across browsers.
const playerSpriteImg = loadAnimatedImageWithFallback([
  "Images Sidescroller/main character.gif",
  "main character.gif",
]);

// IDLE (STILL) sprite: use the project's "Stil" image from the Images Sidescroller folder.
const playerIdleImg = loadAnimatedImageWithFallback([
  "Images Sidescroller/Stil.png",
  "Images Sidescroller/Stil.gif",
  "Stil.png",
  "Stil.gif",
]);
let playerIdleReady = false;
playerIdleImg.onload = () => { playerIdleReady = true; };
if (playerIdleImg.complete && playerIdleImg.naturalWidth) { playerIdleReady = true; }

let playerSpriteReady = false;

// Gate animated GIF playback: show the GIF only while left/right input is held.
// When idle, we hide the DOM <img> and draw a cached (frozen) frame onto the canvas.
// This avoids relying on canvas export (toDataURL), which can be blocked under some file:// setups.
let playerSpriteAnimatedSrc = "";
let playerWasMoving = false;
let playerMoveInput = false;

// Offscreen canvas holding the last frozen frame.
const playerFrozenCanvas = document.createElement("canvas");
const playerFrozenCtx = playerFrozenCanvas.getContext("2d");
let playerFrozenReady = false;

function freezePlayerSpriteFrame() {
  if (!playerSpriteReady) return;
  const w = playerSpriteImg.naturalWidth || CHAR_W;
  const h = playerSpriteImg.naturalHeight || CHAR_H;
  if (playerFrozenCanvas.width !== w) playerFrozenCanvas.width = w;
  if (playerFrozenCanvas.height !== h) playerFrozenCanvas.height = h;
  playerFrozenCtx.clearRect(0, 0, w, h);
  // draw current GIF frame into the offscreen buffer (no pixel-readback required)
  playerFrozenCtx.drawImage(playerSpriteImg, 0, 0, w, h);
  playerFrozenReady = true;
}

playerSpriteImg.onload = () => {
  playerSpriteReady = true;
  playerSpriteAnimatedSrc = playerSpriteImg.src || "";
  // Initialize the frozen frame so the idle pose is available immediately.
  freezePlayerSpriteFrame();
};

// If the image was already cached and loaded before the onload handler was attached, initialize immediately.
if (playerSpriteImg.complete && playerSpriteImg.naturalWidth) {
  playerSpriteImg.onload();
}

let playerEl = null;
function ensurePlayerEl() {
  if (!enemyLayer) return null;
  if (playerEl) return playerEl;
  const im = document.createElement('img');
  im.alt = '';
  im.draggable = false;
  im.decoding = 'sync';
  im.loading = 'eager';
  im.style.zIndex = '23';
  im.style.transformOrigin = 'center center';
  // Source set in drawPlayer (after fallback resolution)
  enemyLayer.appendChild(im);
  playerEl = im;
  return playerEl;
}



  // ----------------------------
  // AUDIO (WebAudio)
  // ----------------------------
  let audioCtx = null;
  // Background music (HTMLAudioElement)
  let bgm = null;
  let audioMuted = false;
  // Sound effects (HTMLAudioElement templates; cloned per play for overlap)
  let sfxJump = null;
  let sfxCrush = null;
  let sfxCorrect = null;
  let sfxWrong = null;
  let sfxDeath = null;

  let sfxHealth = null;

// Boss encounter audio (file-based)
let sfxEagle = null;      // one-shot scream
let sfxWindLoop = null;   // looping ambience
let sfxWingsLoop = null;  // looping ambience

const BOSS_EAGLE_SRC_CANDIDATES = [
  "Images Sidescroller/Eagle scream.mp3",
  "Images Sidescroller/Eagle_scream.mp3",
  "Images Sidescroller/EagleScream.mp3",
  "Images Sidescroller/Eagle scream.wav",
  "Images Sidescroller/Eagle_scream.wav",
  "Images Sidescroller/EagleScream.wav"
];
const BOSS_WIND_SRC_CANDIDATES = [
  "Images Sidescroller/Wind.mp3",
  "Images Sidescroller/Wind.wav",
  "Images Sidescroller/wind.mp3",
  "Images Sidescroller/wind.wav"
];
const BOSS_WINGS_SRC_CANDIDATES = [
  "Images Sidescroller/Wings.mp3",
  "Images Sidescroller/Wings.wav",
  "Images Sidescroller/wings.mp3",
  "Images Sidescroller/wings.wav"
];

function createAudioWithFallback(candidates, opts){
  const o = opts || {};
  let idx = 0;
  const a = new Audio(candidates[idx]);
  a.preload = "auto";
  a.loop = !!o.loop;
  a.volume = (o.volume != null) ? o.volume : 0.7;
  a.muted = audioMuted;
  a.onerror = () => {
    idx += 1;
    if (idx < candidates.length) {
      try {
        a.src = candidates[idx];
        a.load();
      } catch(_) {}
    }
  };
  return a;
}

function ensureBossSFX(){
  try {
    if (!sfxEagle) {
      sfxEagle = createAudioWithFallback(BOSS_EAGLE_SRC_CANDIDATES, { loop:false, volume:0.85 });
    }
    if (!sfxWindLoop) {
      sfxWindLoop = createAudioWithFallback(BOSS_WIND_SRC_CANDIDATES, { loop:true, volume:0.32 });
    }
    if (!sfxWingsLoop) {
      sfxWingsLoop = createAudioWithFallback(BOSS_WINGS_SRC_CANDIDATES, { loop:true, volume:0.32 });
    }
    if (sfxEagle) sfxEagle.muted = audioMuted;
    if (sfxWindLoop) sfxWindLoop.muted = audioMuted;
    if (sfxWingsLoop) sfxWingsLoop.muted = audioMuted;
  } catch(_) {
    sfxEagle = sfxEagle || null;
    sfxWindLoop = sfxWindLoop || null;
    sfxWingsLoop = sfxWingsLoop || null;
  }
}

function startBossLoops(){
  ensureBossSFX();
  if (audioMuted) return;
  try {
    if (sfxWindLoop) {
      if (sfxWindLoop.paused) sfxWindLoop.currentTime = 0;
      const p = sfxWindLoop.play();
      if (p && typeof p.catch === "function") p.catch(()=>{});
    }
  } catch(_) {}
  try {
    if (sfxWingsLoop) {
      if (sfxWingsLoop.paused) sfxWingsLoop.currentTime = 0;
      const p = sfxWingsLoop.play();
      if (p && typeof p.catch === "function") p.catch(()=>{});
    }
  } catch(_) {}
}

function stopBossLoops(){
  try {
    if (sfxWindLoop) { sfxWindLoop.pause(); sfxWindLoop.currentTime = 0; }
  } catch(_) {}
  try {
    if (sfxWingsLoop) { sfxWingsLoop.pause(); sfxWingsLoop.currentTime = 0; }
  } catch(_) {}
}
  function ensureSFX(){
    try {
      if (!sfxJump) {
        sfxJump = new Audio("Images Sidescroller/Jump.mp3");
        sfxJump.preload = "auto";
        sfxJump.volume = 0.65;
      }
      if (!sfxCrush) {
        sfxCrush = new Audio("Images Sidescroller/Crush.mp3");
        sfxCrush.preload = "auto";
        sfxCrush.volume = 0.75;
      }
      if (!sfxCorrect) {
        sfxCorrect = new Audio("Images Sidescroller/Correct.mp3");
        sfxCorrect.preload = "auto";
        sfxCorrect.volume = 0.70;
      }
      if (!sfxWrong) {
        sfxWrong = new Audio("Images Sidescroller/Wrong.mp3");
        sfxWrong.preload = "auto";
        sfxWrong.volume = 0.75;
      }
      if (!sfxDeath) {
        sfxDeath = new Audio("Images Sidescroller/Death.mp3");
        sfxDeath.preload = "auto";
        sfxDeath.volume = 0.85;
      }

if (!sfxHealth) {
  sfxHealth = new Audio("Images Sidescroller/Health.mp3");
  sfxHealth.preload = "auto";
  sfxHealth.volume = 0.75;
}
      // Keep templates aligned with mute state
      if (sfxJump) sfxJump.muted = audioMuted;
    if (sfxCrush) sfxCrush.muted = audioMuted;
    if (sfxCorrect) sfxCorrect.muted = audioMuted;
    if (sfxWrong) sfxWrong.muted = audioMuted;
    if (sfxDeath) sfxDeath.muted = audioMuted;
    if (sfxHealth) sfxHealth.muted = audioMuted;
    if (sfxHealth) sfxHealth.muted = audioMuted;
      if (sfxCorrect) sfxCorrect.muted = audioMuted;
      if (sfxWrong) sfxWrong.muted = audioMuted;
      if (sfxDeath) sfxDeath.muted = audioMuted;
    if (sfxHealth) sfxHealth.muted = audioMuted;
    } catch(_) {
      // If audio creation fails, keep SFX null (game remains playable).
      sfxJump = sfxJump || null;
      sfxCrush = sfxCrush || null;
      sfxCorrect = sfxCorrect || null;
      sfxWrong = sfxWrong || null;
      sfxDeath = sfxDeath || null;
      sfxHealth = sfxHealth || null;
    }
  }

  function playSFX(template){
    if (audioMuted) return;
    if (!template) return;
    try {
      // Clone so repeated/overlapping triggers do not cut each other off.
      const a = template.cloneNode(true);
      a.muted = audioMuted;
      a.volume = template.volume;
      const p = a.play();
      if (p && typeof p.catch === "function") p.catch(()=>{});
    } catch(_) {}
  }

  function playJumpSFX(){ ensureSFX(); playSFX(sfxJump); }
  function playCrushSFX(){ ensureSFX(); playSFX(sfxCrush); }
  function playCorrectSFX(){ ensureSFX(); playSFX(sfxCorrect); }
  function playWrongSFX(){ ensureSFX(); playSFX(sfxWrong); }
  function playDeathSFX(){ ensureSFX(); playSFX(sfxDeath); }

  function playHealthSFX(){ ensureSFX(); playSFX(sfxHealth); }
  function ensureBGM(){
    if (bgm) return;
    try {
      bgm = new Audio("Images Sidescroller/background.mp3");
      bgm.loop = true;
      bgm.preload = "auto";
      bgm.volume = 0.22;
      bgm.muted = audioMuted;
    } catch(_) { bgm = null; }
  }
  function startBGM(){
    ensureBGM();
    ensureSFX();
    if (!bgm) return;
    bgm.muted = audioMuted;
    const p = bgm.play();
    if (p && typeof p.catch === "function") p.catch(()=>{});
  }
  function setMuteState(m){
    audioMuted = !!m;
    if (bgm) bgm.muted = audioMuted;
    if (sfxJump) sfxJump.muted = audioMuted;
    if (sfxCrush) sfxCrush.muted = audioMuted;
    if (sfxCorrect) sfxCorrect.muted = audioMuted;
    if (sfxWrong) sfxWrong.muted = audioMuted;
    if (sfxDeath) sfxDeath.muted = audioMuted;
    if (sfxEagle) sfxEagle.muted = audioMuted;
    if (sfxWindLoop) sfxWindLoop.muted = audioMuted;
    if (sfxWingsLoop) sfxWingsLoop.muted = audioMuted;
    if (btnMute) {
      btnMute.textContent = audioMuted ? "Unmute" : "Mute";
      btnMute.setAttribute("aria-label", audioMuted ? "Unmute" : "Mute");
    }
  }
  function ensureAudio() {
    
    // Prime TTS / gap sound after the first user gesture.
    try { primeTts(); } catch(_) {}
    try { ensureGapSound(); } catch(_) {}
if (audioCtx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    audioCtx = new AC();
  }
  function playBeep({ type="sine", freq=440, dur=0.14, gain=0.12, endFreq=null }) {
    if (!audioCtx || audioMuted) return;
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    if (endFreq != null) osc.frequency.linearRampToValueAtTime(endFreq, t0 + dur);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + dur);
  }
  function playEagleScreamSynth(){
    // Synthesized "eagle scream" (no external asset required)
    ensureAudio();
    if (!audioCtx || audioMuted) return;
    const t0 = audioCtx.currentTime;

    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const bp = audioCtx.createBiquadFilter();
    const lfo = audioCtx.createOscillator();
    const lfoG = audioCtx.createGain();

    osc.type = "sawtooth";
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(1800, t0);
    bp.Q.setValueAtTime(9, t0);

    // Pitch sweep + slight vibrato
    osc.frequency.setValueAtTime(900, t0);
    osc.frequency.exponentialRampToValueAtTime(2800, t0 + 0.12);
    osc.frequency.exponentialRampToValueAtTime(700,  t0 + 0.90);

    lfo.type = "sine";
    lfo.frequency.setValueAtTime(14, t0);
    lfoG.gain.setValueAtTime(35, t0);
    lfo.connect(lfoG);
    lfoG.connect(osc.frequency);

    // Envelope
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.22, t0 + 0.03);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.95);

    osc.connect(bp);
    bp.connect(g);
    g.connect(audioCtx.destination);

    lfo.start(t0);
    osc.start(t0);
    osc.stop(t0 + 0.96);

  lfo.stop(t0 + 0.96);
}

function playEagleScream(){
  // Prefer the user-provided file; fall back to synth if not available.
  ensureBossSFX();
  if (!audioMuted && sfxEagle) {
    playSFX(sfxEagle);
    return;
  }
  playEagleScreamSynth();
}

  function soundCorrect() {
    // Prefer the dedicated SFX file; fall back to a simple beep if audio loading fails.
    ensureSFX();
    if (sfxCorrect) { playCorrectSFX(); return; }
    ensureAudio();
    playBeep({ type:"triangle", freq:620, endFreq:880, dur:0.16, gain:0.14 });
    setTimeout(() => playBeep({ type:"triangle", freq:880, endFreq:980, dur:0.12, gain:0.10 }), 110);
  }
  function soundWrong() {
    ensureSFX();
    if (sfxWrong) { playWrongSFX(); return; }
    ensureAudio();
    playBeep({ type:"sawtooth", freq:220, endFreq:160, dur:0.22, gain:0.13 });
  }

  // ----------------------------
  // SCREEN FLASH
  // ----------------------------
  let flash = { t: 0, dur: 0, color: "rgba(0,0,0,0)" };
  function triggerFlash(color, dur=0.18) {
    flash.color = color;
    flash.t = dur;
    flash.dur = dur;
  }

  // ----------------------------
  // SIZES
  // ----------------------------
  const CHAR_W = 104, CHAR_H = 81;
  // Cropped GIF: no padding offsets required.
  const PLAYER_SPRITE_OFF_X = 0;
  const PLAYER_SPRITE_OFF_Y = 4;
  // Hitbox is separate from the visual sprite.
  // Adjust these to fine-tune platform interaction (feet alignment, edge drop-off).
  const HIT_W = 30;
  const HIT_H = 50;
  const HIT_OFF_X = Math.round((CHAR_W - HIT_W) / 2);
  const HIT_OFF_Y = CHAR_H - HIT_H;
  // Require a minimum horizontal overlap (in px) to count as standing on a platform.
  const MIN_FOOT_OVERLAP = 10;

  // Platform width should NOT scale with the player's sprite size.
  // Keep the original platform width to preserve the intended camera/perspective.
  const PLATFORM_W = 102;
  const PLATFORM_H = 18;

  // Thin ground, but ALWAYS at bottom
  const GROUND_H = 40;


// ----------------------------
// ENEMY SYSTEM
// ----------------------------
const ENEMY_CFG = {
  // Spawn intervals (seconds)
  groundSpawnMin: 3.2,
  groundSpawnMax: 5.6,
  flyingSpawnMin: 4.8,
  flyingSpawnMax: 6.6,

  // Speeds (px/sec)
  groundSpeed: 140,
  flyingSpeed: 115,

  // Visual sizes (target heights, px)
  groundH: 90,
  flyingH: 100,

  // Flying motion
  flyAmp: 34,
  flyOscSpeed: 2.2, // radians/sec
};

// Player stomping (ground enemies only)
const STOMP_TOL = 10;          // px: max "from-above" allowance using previous bottom vs enemy top
const STOMP_MIN_OVERLAP = 10;  // px: minimum horizontal overlap to count as a stomp
const STOMP_BOUNCE = 0.55;     // fraction of WORLD.jumpSpeed applied as bounce after stomp
const ENEMY_DEATH_DUR = 0.28;  // seconds (squash + fade)

let enemies = [];
let lastFlyingSpawnY = null;
let enemySpawn = {
  ground: { t: 0, next: 2.8 },
  flying: { t: 0, next: 3.6 },
};
let enemyHitCooldown = 0;

function randRange(a, b) { return a + Math.random() * (b - a); }

function getScaledDims(img, targetH) {
  const ih = (img && (img.naturalHeight || img.height)) || targetH;
  const iw = (img && (img.naturalWidth || img.width)) || (targetH * 0.9);
  const h = targetH;
  const w = (iw / ih) * h;
  return { w, h };
}

function resetEnemies() {
  // Remove any DOM sprite elements.
  for (const e of enemies) {
    if (e.el && e.el.remove) e.el.remove();
  }
  enemies = [];
  enemySpawn.ground.t = 0;
  enemySpawn.flying.t = 0;
  enemySpawn.ground.next = randRange(ENEMY_CFG.groundSpawnMin, ENEMY_CFG.groundSpawnMax);
  enemySpawn.flying.next = randRange(ENEMY_CFG.flyingSpawnMin, ENEMY_CFG.flyingSpawnMax);
  enemyHitCooldown = 0;
}

function spawnGroundEnemy() {
  const dims = getScaledDims(groundEnemyImg, ENEMY_CFG.groundH);
  const spawnX = camera.x + canvas.width + 160;
  const groundTop = canvas.height - GROUND_H;
  enemies.push({
    type: "ground",
    img: groundEnemyImg,
    x: spawnX,
    y: groundTop - dims.h + 20,
    w: dims.w,
    h: dims.h,
    vx: -ENEMY_CFG.groundSpeed,
    flipX: false,
    dead: false,
    deathT: 0,
    deathDur: ENEMY_DEATH_DUR,
  });
}

function spawnFlyingEnemy() {
  const dims = getScaledDims(flyingEnemyImg, ENEMY_CFG.flyingH);
  const spawnX = camera.x + canvas.width + 180;
  // Spawn at varied heights (avoid repeating the same band too often)
  const groundTop = canvas.height - GROUND_H;
  const minY = 60;
  const maxY = Math.max(minY + 120, groundTop - 320);
  let baseY = randRange(minY, maxY);
  if (lastFlyingSpawnY != null && Math.abs(baseY - lastFlyingSpawnY) < 80) {
    baseY = randRange(minY, maxY);
  }
  lastFlyingSpawnY = baseY;
  enemies.push({
    type: "flying",
    img: flyingEnemyImg,
    x: spawnX,
    y: baseY,
    baseY,
    w: dims.w,
    h: dims.h,
    vx: -ENEMY_CFG.flyingSpeed,
    oscT: 0,
    oscAmp: ENEMY_CFG.flyAmp * randRange(0.8, 1.25),
    oscSpeed: ENEMY_CFG.flyOscSpeed * randRange(0.8, 1.25),
    phase: randRange(0, Math.PI * 2),
    flipX: true,
    dead: false,
    deathT: 0,
    deathDur: ENEMY_DEATH_DUR,
  });
}

function updateEnemies(dt) {
  if (enemyHitCooldown > 0) enemyHitCooldown = Math.max(0, enemyHitCooldown - dt);

  // Spawn regulation
  enemySpawn.ground.t += dt;
  enemySpawn.flying.t += dt;

  if (enemySpawn.ground.t >= enemySpawn.ground.next) {
    enemySpawn.ground.t = 0;
    enemySpawn.ground.next = randRange(ENEMY_CFG.groundSpawnMin, ENEMY_CFG.groundSpawnMax);
    spawnGroundEnemy();
  }
  if (enemySpawn.flying.t >= enemySpawn.flying.next) {
    enemySpawn.flying.t = 0;
    enemySpawn.flying.next = randRange(ENEMY_CFG.flyingSpawnMin, ENEMY_CFG.flyingSpawnMax);
    spawnFlyingEnemy();
  }

  const despawnX = camera.x - 220;

  // Move enemies and advance death timers
  for (const e of enemies) {
    if (e.dead) {
      e.deathT = Math.max(0, (e.deathT || 0) - dt);
      continue;
    }
    e.x += e.vx * dt;
    if (e.type === "flying") {
      e.oscT += dt;
      e.y = e.baseY + Math.sin(e.oscT * e.oscSpeed + e.phase) * e.oscAmp;
    }
  }

  // Despawn (off-screen) and fully-dead enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    const offLeft = (e.x + e.w) < despawnX;
    const finishedDeath = e.dead && (e.deathT || 0) <= 0;
    if (offLeft || finishedDeath) {
      if (e.el && e.el.remove) e.el.remove();
      enemies.splice(i, 1);
    }
  }
}

function handleEnemyCollision() {
  const hb = playerHitRect(player);
  const prevHb = player.prevHb || hb;

  for (const e of enemies) {
    if (e.dead) continue;

    if (!aabb(hb.x, hb.y, hb.w, hb.h, e.x, e.y, e.w, e.h)) continue;

    const overlap = xOverlap(hb.x, hb.w, e.x, e.w);
    const prevBottom = prevHb.y + prevHb.h;

    // Stomp: only for ground enemies, only when falling onto them (vertical collision).
    const isStomp = (e.type === "ground") &&
                    (player.vy > 0) &&
                    (prevBottom <= e.y + STOMP_TOL) &&
                    (overlap >= STOMP_MIN_OVERLAP);

    if (isStomp) {
      e.dead = true;
      playCrushSFX();
      e.deathDur = e.deathDur || ENEMY_DEATH_DUR;
      e.deathT = e.deathDur;

      // Bounce the player upward a bit (classic stomp feel).
      player.vy = -WORLD.jumpSpeed * STOMP_BOUNCE;
      player.onGround = false;
      player.coyote = 0;
      player.jumpBuf = 0;

      // Small feedback flash (green) to reinforce successful stomp.
      triggerFlash("rgba(34,197,94,1)", 0.10);
      return;
    }

    // Otherwise treat as damage (horizontal collision or flying enemy).
    if (enemyHitCooldown > 0) return;
    enemyHitCooldown = 1.1;
    triggerFlash("rgba(239,68,68,1)", 0.18);
    playDeathSFX();
    loseLife();
    if (!gameOver) {
      setFeedback("Hit by an enemy. Respawning.", 1.0);
      player = makePlayer();
      // Re-center camera quickly so the respawn doesn't feel disorienting.
      camera.x = player.x - canvas.width * 0.35;
      camera.y = 0;
      // Clear enemies to avoid immediate re-hit.
      resetEnemies();
    }
    return;
  }
}

function drawEnemies() {
  if (!enemies.length) return;

  // Keep enemy layer aligned to the canvas in CSS pixels.
  syncEnemyLayerToCanvas();

  const r = canvas.getBoundingClientRect();
  const scaleX = r.width / canvas.width;
  const scaleY = r.height / canvas.height;

  function ensureEnemyEl(e) {
    if (!enemyLayer) return;
    if (e.el) return;
    const im = document.createElement('img');
    im.alt = '';
    im.draggable = false;
    im.decoding = 'sync';
    im.loading = 'eager';
    im.src = (e.img && e.img.src) ? e.img.src : '';
    enemyLayer.appendChild(im);
    e.el = im;
  }

  for (const e of enemies) {
    const sx = e.x - camera.x;
    const sy = e.y - camera.y;

    const off = (sx + e.w < -200 || sx > canvas.width + 200);

    // Draw only the shadow on the canvas (sprite itself is a DOM <img> so GIFs animate).
    if (!off && e.type === "ground") {
      ctx.save();
      ctx.globalAlpha = 0.28;
      ctx.fillStyle = "#000";
      const shW = e.w * 0.55;
      const shH = 8;
      const shX = sx + (e.w - shW) * 0.5;
      const shY = sy + e.h - 14;
      ctx.beginPath();
      ctx.ellipse(shX + shW/2, shY + shH/2, shW/2, shH/2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Update the DOM sprite.
    ensureEnemyEl(e);
    if (e.el) {
      if (off) {
        e.el.style.display = 'none';
      } else {
        e.el.style.display = 'block';
        e.el.style.left = (sx * scaleX) + 'px';
        e.el.style.top = (sy * scaleY) + 'px';
        e.el.style.width = (e.w * scaleX) + 'px';
        e.el.style.height = (e.h * scaleY) + 'px';

        // Kill animation (squash + fade)
        let sxMul = 1, syMul = 1, alpha = 1;
        if (e.dead) {
          const dur = (e.deathDur || ENEMY_DEATH_DUR);
          const t = Math.max(0, (e.deathT || 0));
          const p = dur > 0 ? (1 - (t / dur)) : 1; // 0..1
          syMul = Math.max(0.15, 1 - 0.75 * p);
          sxMul = 1 + 0.15 * p;
          alpha = Math.max(0, 1 - p);
        }
        const flip = e.flipX ? -1 : 1;
        e.el.style.transform = `scale(${flip * sxMul}, ${syMul})`;
        e.el.style.opacity = String(alpha);
      }
    }
  }
}

  // ----------------------------
  // LEVELS (50)
  // ----------------------------
  const LEVELS_BASE = [
    { prompt: "I bought ____ new backpack yesterday.", options: ["a","an","the","X"], correct: "a", why: "Use 'a' for a singular countable noun mentioned for the first time." },
    { prompt: "She wants ____ apple for lunch.", options: ["a","an","the","X"], correct: "an", why: "Use 'an' before a vowel sound (apple)." },
    { prompt: "Can you turn off ____ light, please?", options: ["a","an","the","X"], correct: "the", why: "Use 'the' when both speakers know which specific thing you mean." },
    { prompt: "We had ____ dinner at 7 o'clock.", options: ["a","an","the","X"], correct: "X", why: "Meals usually take no article when speaking generally (have dinner)." },
    { prompt: "____ honesty is important in a team.", options: ["a","an","the","X"], correct: "X", why: "Abstract nouns used generally take no article." },
    { prompt: "He is learning to play ____ guitar.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' with musical instruments (play the guitar)." },
    { prompt: "I need ____ umbrella because it’s raining.", options: ["a","an","the","X"], correct: "an", why: "Use 'an' before a vowel sound (umbrella)." },
    { prompt: "There’s ____ dog in our garden.", options: ["a","an","the","X"], correct: "a", why: "Use 'a' for first mention of a singular countable noun." },
    { prompt: "____ dog is barking loudly.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' to refer back to something already mentioned." },
    { prompt: "She goes to ____ school by bus.", options: ["a","an","the","X"], correct: "X", why: "Use no article with 'go to school' (institution/activity)." },
    { prompt: "He speaks ____ French at home.", options: ["a","an","the","X"], correct: "X", why: "Languages usually take no article." },
    { prompt: "____ Amazon is a very long river.", options: ["a","an","the","X"], correct: "the", why: "Most rivers take 'the' (the Amazon)." },
    { prompt: "We visited ____ Netherlands last summer.", options: ["a","an","the","X"], correct: "the", why: "Some country names take 'the' (the Netherlands)." },
    { prompt: "____ Berlin is the capital of Germany.", options: ["a","an","the","X"], correct: "X", why: "Most city names take no article." },
    { prompt: "I found ____ useful website for revision.", options: ["a","an","the","X"], correct: "a", why: "Use 'a' for a non-specific singular countable noun." },
    { prompt: "____ information is available on the school website.", options: ["a","an","the","X"], correct: "X", why: "Uncountable nouns used generally often take no article." },
    { prompt: "Please delete ____ information I sent you yesterday.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' for specific information already identified." },
    { prompt: "She has ____ hour to finish the test.", options: ["a","an","the","X"], correct: "an", why: "Use 'an' before a vowel sound; 'hour' starts with a silent 'h'." },
    { prompt: "He is ____ engineer.", options: ["a","an","the","X"], correct: "an", why: "Use 'an' before a vowel sound (engineer)." },
    { prompt: "I watched ____ movie last night.", options: ["a","an","the","X"], correct: "a", why: "Use 'a' for a non-specific singular countable noun." },
    { prompt: "We watched ____ movie you recommended.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' when the noun is specified (you recommended it)." },
    { prompt: "____ students need enough sleep.", options: ["a","an","the","X"], correct: "X", why: "Plural nouns used generally take no article." },
    { prompt: "The teacher gave us ____ homework for Monday.", options: ["a","an","the","X"], correct: "X", why: "Uncountable nouns like 'homework' usually take no article." },
    { prompt: "I left ____ homework on my desk.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' for a specific set of homework (yours, known context)." },
    { prompt: "She stayed at ____ home all weekend.", options: ["a","an","the","X"], correct: "X", why: "Use no article in fixed expressions like 'at home'." },
    { prompt: "He went to ____ bed early.", options: ["a","an","the","X"], correct: "X", why: "Use no article in fixed expressions like 'go to bed'." },
    { prompt: "We took ____ taxi to the hotel.", options: ["a","an","the","X"], correct: "a", why: "Use 'a' for a non-specific singular countable noun (one taxi)." },
    { prompt: "The taxi driver took ____ wrong turn.", options: ["a","an","the","X"], correct: "a", why: "Use 'a' in the expression 'take a wrong turn'." },
    { prompt: "Please open ____ window; it’s too warm.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' for a specific thing in the shared situation (the window in this room)." },
    { prompt: "She opened ____ bottle of water.", options: ["a","an","the","X"], correct: "a", why: "Use 'a' for first mention of a singular countable noun." },
    { prompt: "Could you hand me ____ bottle of water on the table?", options: ["a","an","the","X"], correct: "the", why: "Use 'the' when the noun is identified by a following phrase (on the table)." },
    { prompt: "I usually drink ____ coffee in the morning.", options: ["a","an","the","X"], correct: "X", why: "Uncountable nouns used generally (coffee as a drink) often take no article." },
    { prompt: "____ coffee in this cup is too strong for me.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' for something specific (the coffee in this cup)." },
    { prompt: "She plays ____ tennis every Saturday.", options: ["a","an","the","X"], correct: "X", why: "Sports usually take no article (play tennis)." },
    { prompt: "They visited ____ Eiffel Tower.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' with many famous buildings/monuments (the Eiffel Tower)." },
    { prompt: "____ Europe has many different cultures.", options: ["a","an","the","X"], correct: "X", why: "Continents usually take no article." },
    { prompt: "He went hiking in ____ Alps.", options: ["a","an","the","X"], correct: "the", why: "Mountain ranges usually take 'the' (the Alps)." },
    { prompt: "____ Alps are beautiful in winter.", options: ["a","an","the","X"], correct: "the", why: "Mountain ranges usually take 'the' (the Alps)." },
    { prompt: "I had ____ idea during the lesson.", options: ["a","an","the","X"], correct: "an", why: "Use 'an' before a vowel sound (idea)." },
    { prompt: "That was ____ best answer in the class.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' with superlatives (the best)." },
    { prompt: "She is ____ only person who knows the code.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' with 'only' when it means unique." },
    { prompt: "We listened to ____ music quietly.", options: ["a","an","the","X"], correct: "X", why: "Uncountable nouns used generally (music) often take no article." },
    { prompt: "We listened to ____ music from the film.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' for a specific set (the music from the film)." },
    { prompt: "I have to wear ____ uniform at school.", options: ["a","an","the","X"], correct: "a", why: "Use 'a' for a singular countable noun (a uniform) in general reference." },
    { prompt: "____ uniform in this shop is too expensive.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' when referring to a specific item in context (this shop)." },
    { prompt: "She wants to become ____ doctor.", options: ["a","an","the","X"], correct: "a", why: "Use 'a' for a profession (become a doctor)." },
    { prompt: "____ water is essential for life.", options: ["a","an","the","X"], correct: "X", why: "Uncountable nouns used generally take no article (water in general)." },
    { prompt: "The glass is filled with ____ water.", options: ["a","an","the","X"], correct: "X", why: "No article is needed before an uncountable noun when it is not made specific." },
    { prompt: "The nurse called ____ doctor immediately.", options: ["a","an","the","X"], correct: "the", why: "Use 'the' when the person is identifiable in context (the doctor on duty)." },
    { prompt: "She is studying ____ biology at university.", options: ["a","an","the","X"], correct: "X", why: "School subjects/fields of study usually take no article (study biology)." }
  ];

  // Active (shuffled) level order used by the game.
  let LEVELS = [...LEVELS_BASE];

  function shuffleLevels() {
    if (LEVELS_BASE.length <= 1) { LEVELS = [...LEVELS_BASE]; return; }
    let next;
    do {
      next = shuffle([...LEVELS_BASE]);
    } while (next[0].prompt === LEVELS[0].prompt);
    LEVELS = next;
  }

  // ----------------------------
  // INPUT (keyboard)
  // ----------------------------
  const keysDown = new Set();
  let jumpQueued = false;
  let restartQueued = false;

  function keyName(e) {
    if (e.code === "Space") return "space";
    if (e.key && e.key.startsWith("Arrow")) return e.key.toLowerCase();
    return (e.key || "").toLowerCase();
  }

  window.addEventListener("keydown", (e) => {
    ensureAudio();

    const k = keyName(e);

    // If a modal is open and/or the user is typing, do not hijack keys (especially Space).
    const ae = document.activeElement;
    const isTypingTarget = !!(ae && (
      ae.tagName === "INPUT" ||
      ae.tagName === "TEXTAREA" ||
      ae.isContentEditable ||
      (ae.getAttribute && ae.getAttribute("role") === "textbox")
    ));
    const bossOpen = !!(bossModalEl && bossModalEl.classList && bossModalEl.classList.contains("open"));
    const introOpen = !!(introModalEl && introModalEl.classList && introModalEl.classList.contains("open"));
    const reviewOpen = !!(reviewModalEl && reviewModalEl.classList && reviewModalEl.classList.contains("open"));

    if (bossOpen || introOpen || reviewOpen || isTypingTarget) {
      // Still prevent page scrolling with movement keys when not typing.
      if (!isTypingTarget && (k === "arrowleft" || k === "arrowright" || k === "arrowup" || k === "space")) {
        e.preventDefault();
      }
      return;
    }

    if (k === "arrowleft" || k === "arrowright" || k === "arrowup" || k === "space") e.preventDefault();
    if (!keysDown.has(k)) {
      if (k === "arrowup" || k === "space") jumpQueued = true;
    }
    keysDown.add(k);
  }, { passive: false });

  window.addEventListener("keyup", (e) => keysDown.delete(keyName(e)));
  canvas.addEventListener("pointerdown", () => ensureAudio());
  const isDown = (k) => keysDown.has(k);

  // ----------------------------
  // INPUT (buttons)
  // ----------------------------
  const touch = { left:false, right:false };
  const btnLeft  = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");
  const btnJump  = document.getElementById("btnJump");

  if (btnRestart) {
    btnRestart.addEventListener("pointerdown", (ev) => {
      ensureAudio();
      if (ev && ev.preventDefault) ev.preventDefault();
      restartQueued = true;
    }, { passive:false });
  }

  if (btnMute) {
    btnMute.addEventListener("pointerdown", (ev) => {
      ensureAudio();
      if (ev && ev.preventDefault) ev.preventDefault();
      setMuteState(!audioMuted);
      // Attempt to (re)start music on unmute
      if (!audioMuted) startBGM();
    }, { passive:false });
  }

  

if (btnReadout) {
  btnReadout.addEventListener("pointerdown", (ev) => {
    ensureAudio();
    if (ev && ev.preventDefault) ev.preventDefault();
    setReadoutState(!readoutEnabled);
  }, { passive:false });
}

function setPressed(el, on){ if (el) el.classList.toggle("pressed", !!on); }

  function bindHold(el, onDown, onUp){
    el.addEventListener("pointerdown", (ev) => {
      ensureAudio();
      ev.preventDefault();
      try { el.setPointerCapture(ev.pointerId); } catch(_) {}
      onDown();
      setPressed(el, true);
    }, { passive:false });

    const up = (ev) => {
      if (ev && ev.preventDefault) ev.preventDefault();
      onUp();
      setPressed(el, false);
    };

    el.addEventListener("pointerup", up, { passive:false });
    el.addEventListener("pointercancel", up, { passive:false });
    el.addEventListener("lostpointercapture", up, { passive:true });
  }

  bindHold(btnLeft,  () => { touch.left = true;  }, () => { touch.left = false; });
  bindHold(btnRight, () => { touch.right = true; }, () => { touch.right = false; });

  btnJump.addEventListener("pointerdown", (ev) => {
    ensureAudio();
    ev.preventDefault();
    try { btnJump.setPointerCapture(ev.pointerId); } catch(_) {}
    jumpQueued = true;
    setPressed(btnJump, true);
  }, { passive:false });

  const clearJump = (ev) => {
    if (ev && ev.preventDefault) ev.preventDefault();
    setPressed(btnJump, false);
  };
  btnJump.addEventListener("pointerup", clearJump, { passive:false });
  btnJump.addEventListener("pointercancel", clearJump, { passive:false });
  btnJump.addEventListener("lostpointercapture", clearJump, { passive:true });

  const controlsBar = document.querySelector(".controls-bar");
  controlsBar.addEventListener("touchstart", (e) => e.preventDefault(), { passive:false });
  controlsBar.addEventListener("touchmove",  (e) => e.preventDefault(), { passive:false });

  // ----------------------------
  // WORLD / PLAYER
  // ----------------------------
  const WORLD = {
    gravity: 2200,
    friction: 0.85,
    moveAccel: 2800,
    maxSpeed: 420,
    jumpSpeed: 820,
    coyoteTime: 0.10,
    jumpBuffer: 0.10,
    maxAirJumps: 1,
  };

  const camera = { x: 0, y: 0 };

  function makePlayer() {
    return {
      x: 80, y: 200, w: CHAR_W, h: CHAR_H,
      // Collision hitbox (used for platforms/enemies/collectibles)
      hbW: HIT_W, hbH: HIT_H,
      hbOx: HIT_OFF_X, hbOy: HIT_OFF_Y,
      vx: 0, vy: 0,
      onGround: false,
      coyote: 0,
      jumpBuf: 0,
      facing: 1,
      airJumpsLeft: WORLD.maxAirJumps,
    };
  }
  let player = makePlayer();

  // ----------------------------
  // SCORE / TIMER / LIVES
  // ----------------------------
  // Persistent high score (localStorage)
  const BEST_KEY = "articles_sidescroller_best";
  function safeGetBest(){
    try{
      const v = localStorage.getItem(BEST_KEY);
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    } catch(_){ return 0; }
  }
  function safeSetBest(v){
    try{ localStorage.setItem(BEST_KEY, String(v)); } catch(_){}
  }
  let bestScore = safeGetBest();
  function updateBestFromScore(){
    if (score > bestScore){
      bestScore = score;
      safeSetBest(bestScore);
    }
  }

  let score = 0;
  let lives = 5;
  const MAX_LIVES = 5;
  let gameOver = false;
  let gameStarted = false;


  

// ----------------------------
// READ OUT (TTS + gap sound)
// ----------------------------
let readoutEnabled = true;
let lastSpokenPrompt = "";
let ttsRunId = 0; // increments to cancel any in-flight sequence
let ttsPrimed = false;
let ttsVoice = null;

function pickAmericanEnglishVoice(){
  try {
    if (!window.speechSynthesis || !window.speechSynthesis.getVoices) return;
    const vs = window.speechSynthesis.getVoices() || [];
    // Prefer en-US; then any English voice.
    ttsVoice = vs.find(v => (v.lang || '').toLowerCase().startsWith('en-us'))
            || vs.find(v => (v.lang || '').toLowerCase().startsWith('en-us'.replace('-', '_')))
            || vs.find(v => (v.lang || '').toLowerCase().startsWith('en-'))
            || vs.find(v => (v.lang || '').toLowerCase().startsWith('en'))
            || null;
  } catch(_) { ttsVoice = null; }
}

const GAP_SOURCES = [
  "Images Sidescroller/Gap sound.mp3",
  "Images Sidescroller/Gap sound.MP3",
  "Images Sidescroller/Gap Sound.mp3",
  "Images Sidescroller/Gap Sound.MP3",
  "Images Sidescroller/Gap_sound.mp3",
  "Images Sidescroller/Gap_sound.MP3",
  "Gap sound.mp3",
  "Gap Sound.mp3"
];
let gapSoundSrc = null;
let gapProbe = null;

// Lead scheduling state (to eliminate the pause before the gap sound).
let ttsLeadTimers = [];
let ttsEstimateFactor = 1.25;

let gapAudioEl = null; // reused <audio> for lower-latency playback
let gapAudioSrcUsed = null;

function primeTts() {
  if (ttsPrimed) return;
  ttsPrimed = true;
  try { window.speechSynthesis && window.speechSynthesis.getVoices && window.speechSynthesis.getVoices(); } catch(_) {}
  // Ensure we use an American English voice when available.
  pickAmericanEnglishVoice();
  try { window.speechSynthesis && window.speechSynthesis.addEventListener && window.speechSynthesis.addEventListener('voiceschanged', pickAmericanEnglishVoice); } catch(_) {}
}

function ensureGapSound() {
  if (gapSoundSrc || gapProbe || audioMuted) return;
  gapProbe = new Audio();
  gapProbe.preload = "auto";
  let i = 0;

  const tryNext = () => {
    if (i >= GAP_SOURCES.length) return;
    gapProbe.src = GAP_SOURCES[i++];
    try { gapProbe.load(); } catch(_) {}
  };

  gapProbe.addEventListener("canplaythrough", () => {
    if (!gapSoundSrc) gapSoundSrc = gapProbe.src;
  }, { once: true });

  gapProbe.addEventListener("error", () => {
    tryNext();
  });

  tryNext();
}

function cancelReadoutSequence() {
  ttsRunId += 1;

  // Cancel speech.
  try { window.speechSynthesis && window.speechSynthesis.cancel && window.speechSynthesis.cancel(); } catch(_) {}

  // Cancel any scheduled lead callbacks.
  try {
    for (const t of (ttsLeadTimers || [])) { try { clearTimeout(t); } catch(_) {} }
  } catch(_) {}
  ttsLeadTimers = [];
}

function estimateUtteranceMs(t) {
  const s = String(t || "").trim();
  if (!s) return 0;
  const words = s.split(/\s+/).filter(Boolean).length;
  const punct = (s.match(/[\.,;:!?]/g) || []).length;
  // Heuristic: ~380ms per word at rate=1.0 plus small punctuation pauses.
  let ms = (words * 380) + (punct * 120);
  // Clamp to a sensible window to avoid extreme scheduling.
  ms = Math.max(240, Math.min(9000, ms));
  return ms;
}

// Play the gap sound with minimal latency (reused <audio> element).
function playGapSoundAsync(runId){
  if (audioMuted || !readoutEnabled) return;
  if (runId !== ttsRunId) return;
  if (!gapSoundSrc) return;

  try {
    if (!gapAudioEl || gapAudioSrcUsed !== gapSoundSrc) {
      gapAudioEl = new Audio(gapSoundSrc);
      gapAudioSrcUsed = gapSoundSrc;
      gapAudioEl.preload = "auto";
      gapAudioEl.volume = 0.95;
      gapAudioEl.muted = audioMuted;
    }
    gapAudioEl.muted = audioMuted;
    gapAudioEl.pause();
    gapAudioEl.currentTime = 0;
    const p = gapAudioEl.play();
    if (p && typeof p.catch === "function") p.catch(()=>{});
  } catch(_) {}
}

function speakUtteranceAsync(text, runId, opts) {
  return new Promise(resolve => {
    const t = String(text || "").replace(/\s+/g, " ").trim();
    if (!t) { resolve(); return; }
    if (!window.speechSynthesis || !window.SpeechSynthesisUtterance) { resolve(); return; }
    if (audioMuted || !readoutEnabled) { resolve(); return; }
    if (runId !== ttsRunId) { resolve(); return; }

    const options = opts || {};
    const leadMs = Number(options.leadMs || 0);
    const onLead = (typeof options.onLead === "function") ? options.onLead : null;

    let leadTimer = null;

    // Base estimate (ms) for adaptive scheduling.
    const estBase = estimateUtteranceMs(t);
    const startedAt = Date.now();

    try {
      const u = new SpeechSynthesisUtterance(t);
      u.rate = 1.0;
      u.pitch = 1.0;
      u.lang = 'en-US';
      if (ttsVoice) u.voice = ttsVoice;

      // Schedule a "lead" callback slightly before the utterance likely ends.
      // Uses an adaptive factor so we do not trigger the gap sound before speech finishes.
      if (onLead && leadMs > 0 && estBase > 0) {
        const estAdj = estBase * ttsEstimateFactor;
        const when = Math.max(0, estAdj - leadMs);
        leadTimer = setTimeout(() => {
          leadTimer = null;
          if (runId !== ttsRunId) return;
          try { onLead(); } catch(_) {}
        }, when);
        try { ttsLeadTimers.push(leadTimer); } catch(_) {}
      }

      const finish = () => {
        if (runId !== ttsRunId) { resolve(); return; }

        if (leadTimer) {
          // If the lead callback did not fire in time (e.g., very short utterance),
          // trigger it now so the gap sound is never skipped.
          try { clearTimeout(leadTimer); } catch(_) {}
          leadTimer = null;
          if (onLead) { try { onLead(); } catch(_) {} }
        }

        // Update the estimate correction factor based on observed duration.
        try {
          if (estBase > 0) {
            const actual = Math.max(0, Date.now() - startedAt);
            const ratio = actual / estBase;
            const blended = (ttsEstimateFactor * 0.85) + (ratio * 0.15);
            ttsEstimateFactor = Math.max(0.85, Math.min(1.60, blended));
          }
        } catch(_) {}

        resolve();
      };

      u.onend = finish;
      u.onerror = finish;

      // Ensure the speech engine is active (some browsers require this).
      try { window.speechSynthesis && window.speechSynthesis.resume && window.speechSynthesis.resume(); } catch(_) {}

      window.speechSynthesis.speak(u);
    } catch(_) {
      if (leadTimer) { try { clearTimeout(leadTimer); } catch(_) {} leadTimer = null; }
      resolve();
    }
  });
}

async function speakPromptWithGap(prompt) {
  const raw = String(prompt || "").trim();
  if (!raw) return;

  // Cancel any in-flight readout and start a new sequence.
  cancelReadoutSequence();
  const runId = ttsRunId;

  // Do not speak while overlays are open.
  const bossOpen = !!(bossModalEl && bossModalEl.classList && bossModalEl.classList.contains("open"));
  const introOpen = !!(introModalEl && introModalEl.classList && introModalEl.classList.contains("open"));
  const reviewOpen = !!(reviewModalEl && reviewModalEl.classList && reviewModalEl.classList.contains("open"));
  if (bossOpen || introOpen || reviewOpen) return;

  if (audioMuted || !readoutEnabled || !gameStarted) return;

  // Split on any run of 2+ underscores (the gap marker).
  const parts = raw.split(/_{2,}/g);

  for (let i = 0; i < parts.length; i += 1) {
    if (runId !== ttsRunId) return;

    const part = String(parts[i] || "").replace(/\s+/g, " ").trim();
    const hasNextGap = (i < parts.length - 1);

    // If this segment is empty but a gap follows, trigger the gap sound immediately.
    if (!part && hasNextGap) {
      playGapSoundAsync(runId);
      continue;
    }

    if (part) {
      if (hasNextGap) {
        // Start the gap sound slightly BEFORE speech end to eliminate the "pre-gap" pause.
        await speakUtteranceAsync(part, runId, {
          leadMs: 120,
          onLead: () => { playGapSoundAsync(runId); }
        });
      } else {
        await speakUtteranceAsync(part, runId);
      }
    }
  }
}

function maybeSpeakCurrentPrompt(force = false) {
  if (!gameStarted) return;
  if (audioMuted || !readoutEnabled) return;
  const prompt = (LEVELS[levelIndex] ? LEVELS[levelIndex].prompt : "");
  if (!prompt) return;
  if (!force && prompt === lastSpokenPrompt) return;
  lastSpokenPrompt = prompt;
  // Prime resources
  primeTts();
  ensureGapSound();
  // Slight delay gives the DOM a beat to update and avoids speaking during frame churn.
  setTimeout(() => speakPromptWithGap(prompt), 90);
}

function setReadoutState(on) {
  readoutEnabled = !!on;
  if (btnReadout) btnReadout.textContent = readoutEnabled ? "Read Out: On" : "Read Out: Off";
  if (!readoutEnabled) cancelReadoutSequence();
}




      // Initialize readout toggle UI
      setReadoutState(true);
// Record first wrong attempt per sentence (keeps the end-of-run review concise)
  let mistakeLog = [];
  let mistakeSeenByLevel = new Set();

  function getCorrectArray(lvl){
    return Array.isArray(lvl.correct) ? lvl.correct : [lvl.correct];
  }

  function recordMistake(levelIdx, chosenLabel){
    if (mistakeSeenByLevel.has(levelIdx)) return;
    mistakeSeenByLevel.add(levelIdx);
    const lvl = LEVELS[levelIdx];
    mistakeLog.push({
      level: levelIdx + 1,
      prompt: lvl.prompt,
      chosen: chosenLabel,
      corrects: getCorrectArray(lvl),
      why: lvl.why || ''
    });
  }

  let runStartMs = performance.now();
  function elapsedSeconds() {
    if (!gameStarted) return 0;
    return Math.max(0, (performance.now() - runStartMs) / 1000);
  }
  function fmtTime(sec) {
    const s = Math.floor(sec);
    const mm = String(Math.floor(s / 60)).padStart(2, "0");
    const ss = String(s % 60).padStart(2, "0");
    return `${mm}:${ss}`;
  }

  // ----------------------------
  // HELPERS
  // ----------------------------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const randi = (a, b) => Math.floor(rand(a, b + 1));
  const shuffle = (arr) => arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

  function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }


  function playerHitRect(p) {
    if (p && p.hbW != null && p.hbH != null) {
      return { x: p.x + (p.hbOx || 0), y: p.y + (p.hbOy || 0), w: p.hbW, h: p.hbH };
    }
    return { x: p.x, y: p.y, w: p.w, h: p.h };
  }

  function xOverlap(ax, aw, bx, bw) {
    return Math.max(0, Math.min(ax + aw, bx + bw) - Math.max(ax, bx));
  }
  // ----------------------------
  // PLATFORMS
  // ----------------------------
  let platforms = [];

  const GEN = {
    groundX: -900,
    groundW: 5200,

    minCount: 13,
    maxCount: 26,

    w: PLATFORM_W,
    h: PLATFORM_H,

    gapMin: 110,
    gapMax: 170,


    seamGapMin: 110,
    seamGapMax: 140,
    stepUpMax: 105,
    stepDownMax: 140,

    yMin: 170,
    yMax: 350,
  };

  // ----------------------------
  // WORLD LOOPING (seamless, fully repeating stage)
//
// Goal: the *entire stage* repeats endlessly (platforms + ground), not only the background.
// We treat the platform layout as one repeating segment of length LOOP_LEN.
// For rendering + collision, we consider platform instances in the current segment and its neighbors.
// To keep coordinates bounded (and prevent precision drift), we wrap the player/camera/collectibles
// back by exactly one segment length when approaching the segment edge.
const LOOP_LEN = GEN.groundW;
const LOOP_TRIGGER_PAD = 260;

// Keeps an "unwrapped" camera coordinate for parallax layers.
// When we wrap player/camera by +/- LOOP_LEN, this offset is adjusted so that
// (camera.x + worldWrapOffset) stays continuous. This prevents background jumps.
let worldWrapOffset = 0;

// Offscreen buffers used to produce a stable crossfade at background tile seams.
// We intentionally avoid per-frame canvas allocation to reduce shimmer/jitter.
let seamBufA = null, seamBufB = null;
let seamCtxA = null, seamCtxB = null;
function ensureSeamBuffers(w, h){
  if (!seamBufA) {
    seamBufA = document.createElement('canvas');
    seamBufB = document.createElement('canvas');
    seamCtxA = seamBufA.getContext('2d');
    seamCtxB = seamBufB.getContext('2d');
  }
  if (seamBufA.width !== w || seamBufA.height !== h) {
    seamBufA.width = w; seamBufA.height = h;
    seamBufB.width = w; seamBufB.height = h;
    // Re-acquire contexts after resize (some browsers reset state).
    seamCtxA = seamBufA.getContext('2d');
    seamCtxB = seamBufB.getContext('2d');
  }
}

// Segment origin for the repeating layout (matches the generated ground start).
const loopStartX = GEN.groundX;

function loopOffsetsForX(x){
  const seg = Math.floor((x - loopStartX) / LOOP_LEN);
  return [(seg - 1) * LOOP_LEN, seg * LOOP_LEN, (seg + 1) * LOOP_LEN];
}

function shiftWorld(dx){
  player.x += dx;
  camera.x += dx;
  // Keep unwrapped camera continuous.
  worldWrapOffset -= dx;
  // Keep dynamic entities aligned with the wrapped world.
  for (const e of enemies) e.x += dx;
}

function wrapWorldIfNeeded(){
  const localX = player.x - loopStartX;

  // Wrap right
  if (localX > (LOOP_LEN - LOOP_TRIGGER_PAD)) {
    shiftWorld(-LOOP_LEN);
  }
  // Wrap left
  else if ((player.x + player.w - loopStartX) < LOOP_TRIGGER_PAD) {
    shiftWorld(+LOOP_LEN);
  }
}


function reachableFromGround(platformY) {
    return platformY >= 320 && platformY <= GEN.yMax;
  }
  function generatePlatforms() {
    const list = [];
    const groundY = canvas.height - GROUND_H;
    list.push({ x: GEN.groundX, y: groundY, w: GEN.groundW, h: GROUND_H });

    // First floating platform position (defines the seam reference)
    const firstX = loopStartX + 280;
    let x = firstX;

    let y0 = randi(320, 350);
    if (!reachableFromGround(y0)) y0 = 330;
    list.push({ x, y: y0, w: GEN.w, h: GEN.h });

    // Second platform
    x += GEN.w + randi(GEN.gapMin, GEN.gapMax);
    let y1 = clamp(y0 + randi(-60, 80), GEN.yMin, GEN.yMax);
    list.push({ x, y: y1, w: GEN.w, h: GEN.h });

    // --- Seam control: enforce a bounded gap between segments at the loop seam.
    const seamMin = (GEN.seamGapMin ?? GEN.gapMin);
    const seamMax = (GEN.seamGapMax ?? GEN.gapMax);
    const seamGap = randi(seamMin, seamMax);

    // Want: (firstX + LOOP_LEN) - (lastX + GEN.w) == seamGap
    const forcedLastX = firstX + LOOP_LEN - seamGap - GEN.w;

    // Preserve a small safety margin near the segment end.
    const hardEnd = (loopStartX + LOOP_LEN) - 120;
    let endLimit = Math.min(forcedLastX, hardEnd);
    // If randomization pushes early platforms beyond the desired endLimit, clamp.
    // (This can slightly reduce the seam gap, but avoids empty stretches.)
    if (endLimit < x) endLimit = x;

    function nextPlatformY(prevY) {
      let rawTarget = (Math.random() < 0.5) ? randi(190, 250) : randi(280, 350);
      rawTarget = clamp(rawTarget, GEN.yMin, GEN.yMax);

      let y = rawTarget;
      const dy = y - prevY;
      if (dy < -GEN.stepUpMax) y = prevY - GEN.stepUpMax;
      if (dy >  GEN.stepDownMax) y = prevY + GEN.stepDownMax;

      y = clamp(y + randi(-14, 14), GEN.yMin, GEN.yMax);

      const dy2 = y - prevY;
      if (dy2 < -GEN.stepUpMax) y = prevY - GEN.stepUpMax;
      if (dy2 >  GEN.stepDownMax) y = prevY + GEN.stepDownMax;

      return y;
    }

    // Fill the whole loop segment up to endLimit so there are no long "empty" stretches.
    // Cap iterations defensively.
    let iters = 0;
    const maxIters = Math.max(40, (GEN.maxCount ?? 12) * 4);
    while (iters++ < maxIters) {
      const prev = list[list.length - 1];

      // If we're already at (or extremely near) endLimit, stop.
      if (prev.x >= endLimit - 1) break;

      // Normal next step.
      let nextX = prev.x + GEN.w + randi(GEN.gapMin, GEN.gapMax);

      // Minimum separation between platform left edges (prevents near-duplicate platforms at the segment end).
      const minStartSep = GEN.w + GEN.gapMin;

      // If we'd overshoot endLimit, snap the final candidate to endLimit.
      if (nextX > endLimit) nextX = endLimit;

      // If snapping would create an almost-overlapping "double platform",
      // move the previous platform to endLimit instead of adding a new one.
      if (nextX === endLimit && (endLimit - prev.x) < minStartSep) {
        prev.x = endLimit;
        break;
      }

      // Guard against accidental duplicates.
      if (nextX <= prev.x + 1) break;

      const y = nextPlatformY(prev.y);
      list.push({ x: nextX, y, w: GEN.w, h: GEN.h });
      x = nextX;
    }

    platforms = list;
  }


  // ----------------------------
  // COLLISIONS
  // ----------------------------
  function resolveCollisions(p, dt) {
    // NOTE: physics state is stored on p.x/p.y, but collisions use the hitbox rect.
    // This prevents the sprite's transparent padding from affecting gameplay.
    // Horizontal
    // IMPORTANT: Platforms are treated as "one-way" (land from above). We intentionally do NOT
    // resolve horizontal (side) collisions against platforms because this can cause edge-snapping
    // artifacts when the hitbox barely overlaps a platform while walking off an edge.
    p.x += p.vx * dt;

    // Vertical
    p.y += p.vy * dt;
    p.onGround = false;
    for (const off of loopOffsetsForX(p.x + (p.hbOx || 0))) {
      for (const plat of platforms) {
        const px = plat.x + off;
        const hx = p.x + (p.hbOx || 0);
        const hy = p.y + (p.hbOy || 0);
        const hw = p.hbW != null ? p.hbW : p.w;
        const hh = p.hbH != null ? p.hbH : p.h;
        if (aabb(hx, hy, hw, hh, px, plat.y, plat.w, plat.h)) {
          if (p.vy > 0) {
            // Require a minimum overlap so you drop when only a small corner is still touching.
            const overlap = xOverlap(hx, hw, px, plat.w);
            if (overlap >= MIN_FOOT_OVERLAP) {
              p.y = (plat.y - hh) - (p.hbOy || 0);
              p.vy = 0;
              p.onGround = true;
              p.coyote = WORLD.coyoteTime;
              p.airJumpsLeft = WORLD.maxAirJumps;
            }
          } else if (p.vy < 0) {
            p.y = (plat.y + plat.h) - (p.hbOy || 0);
            p.vy = 0;
          }
        }
      }
    }
  }

  // ----------------------------
  // COLLECTIBLES / FLOW
  // ----------------------------
  let levelIndex = 0;
  let collectibles = [];
  let feedback = { text: "", timer: 0 };
  let transition = { active: false, t: 0, nextLevel: 0 };



// ----------------------------
// MEDKIT (spawns every 3 correct answers)
// ----------------------------
const MEDKIT_W = 56;
const MEDKIT_H = 56;
let medkit = null;            // {x,y,w,h,active}
let medkitPending = false;    // spawn at the start of the next round
let correctAnsweredCount = 0; // total correct answers in the current run
let answersSinceMedkitSpawn = 0; // completed answers since the current medkit spawned
// ----------------------------
// BOSS ENCOUNTER (every 10 correct answers)
// ----------------------------
const BOSS_EVERY = 10;
const BOSS_INTRO_DELAY = 3.0; // seconds before quiz modal opens
const BOSS_QUIZ_TIME_LIMIT = 30.0; // seconds to answer
let nextBossAt = BOSS_EVERY;

const BOSS_SRC_CANDIDATES = ["Images Sidescroller/Boss.gif", "Boss.gif"];
const FEATHER_SRC_CANDIDATES = ["Images Sidescroller/Feather.gif", "Feather.gif"];

let bossEncounterInProgress = false;
let bossPhase = "idle"; // "intro" | "quiz" | "attack" | "idle"
let pendingAfterBoss = null;

let bossSpriteEl = null;
let bossState = null; // { x,y,w,h } in world coords
let bossFeathers = []; // {x,y,vx,vy,life,el}

let bossQuizItems = [];
let bossUsedPromptIdx = new Set();

let bossIntroT = 0;
let bossQuizT = 0;
let bossQuizAutoSubmitted = false;
let bossQuizHudTick = 0;
let bossAttackFallbackT = 0;

function setImgSrcWithFallback(imgEl, candidates){
  let idx = 0;
  imgEl.src = candidates[idx];
  imgEl.onerror = () => {
    idx += 1;
    if (idx < candidates.length) imgEl.src = candidates[idx];
  };
}

function ensureBossSprite(){
  if (!enemyLayer) return null;
  if (bossSpriteEl) return bossSpriteEl;
  const im = document.createElement('img');
  im.alt = '';
  im.draggable = false;
  im.decoding = 'sync';
  im.loading = 'eager';
  im.style.zIndex = '21';
  im.style.transformOrigin = 'center center';
  setImgSrcWithFallback(im, BOSS_SRC_CANDIDATES);
  enemyLayer.appendChild(im);
  bossSpriteEl = im;
  return bossSpriteEl;
}

function despawnBossSprite(){
  if (bossSpriteEl && bossSpriteEl.remove) bossSpriteEl.remove();
  bossSpriteEl = null;
  bossState = null;
}

function despawnBossFeathers(){
  for (const f of bossFeathers) {
    if (f.el && f.el.remove) f.el.remove();
  }
  bossFeathers = [];
}

function shouldTriggerBoss(){
  return gameStarted && !gameOver && (correctAnsweredCount > 0) && (correctAnsweredCount === nextBossAt);
}

function pickBossQuizItems(){
  // Choose 3 random prompts from the pool (avoid repeating within a run when possible).
  const total = LEVELS.length;
  const candidates = [];
  for (let i = 0; i < total; i++) {
    if (!bossUsedPromptIdx.has(i)) candidates.push(i);
  }
  const pool = candidates.length >= 3 ? candidates : [...Array(total).keys()];
  const picked = shuffle(pool).slice(0, 3);
  for (const i of picked) bossUsedPromptIdx.add(i);

  bossQuizItems = picked.map(i => {
    const lvl = LEVELS[i];
    return {
      prompt: lvl.prompt,
      corrects: getCorrectArray(lvl).map(s => String(s).trim()),
    };
  });
}

function renderBossQuiz(){
  if (!bossQuizBodyEl) return;
  bossQuizBodyEl.innerHTML = bossQuizItems.map((it, idx) => {
    const q = escapeHtml(it.prompt);
    return `
      <div class="boss-item">
        <div class="boss-num">${idx + 1}</div>
        <div class="boss-qwrap">
          <div class="boss-q">${q}</div>
          <input class="boss-input" type="text" inputmode="text" autocomplete="off" spellcheck="false" data-boss-idx="${idx}" placeholder="a / an / the / X…" />
        </div>
      </div>`;
  }).join('');

  // Focus first input (best-effort).
  const first = bossQuizBodyEl.querySelector('input.boss-input');
  if (first) setTimeout(() => { try { first.focus(); } catch(_) {} }, 30);
}

function computeBossWrongCount(){
  if (!bossQuizBodyEl) return 0;
  let wrong = 0;
  for (let i = 0; i < bossQuizItems.length; i++) {
    const it = bossQuizItems[i];
    const inp = bossQuizBodyEl.querySelector(`input[data-boss-idx="${i}"]`);
    const val = (inp ? inp.value : '').trim().toLowerCase();
    const ok = it.corrects.some(c => c.trim().toLowerCase() === val);
    if (!ok) wrong += 1;
  }
  return wrong;
}


function setBossTimerDisplay(seconds){
  if (!bossTimerEl) return;
  const s = Math.max(0, Math.ceil(seconds));
  bossTimerEl.textContent = `Time left: ${s}s`;
}

function beginBossQuizPhase(){
  bossPhase = "quiz";
  bossQuizT = BOSS_QUIZ_TIME_LIMIT;
  bossQuizAutoSubmitted = false;
  bossQuizHudTick = 0;

  pickBossQuizItems();
  renderBossQuiz();
  openBossModal();
  setBossTimerDisplay(bossQuizT);
  setFeedback("Boss challenge! Answer within 30 seconds.", 2.0);
}

function startBossEncounter(afterBoss){
  // afterBoss: { kind:"next", idx:Number } (future-safe)
  pendingAfterBoss = afterBoss || null;
  bossEncounterInProgress = true;
  bossPhase = "intro";
  bossIntroT = BOSS_INTRO_DELAY;
  bossQuizT = 0;
  bossQuizAutoSubmitted = false;
  bossQuizHudTick = 0;
  closeBossModal();

  // Next boss milestone
  nextBossAt += BOSS_EVERY;

  // Spawn boss in the middle of the visible gameplay area (screen center).
  const targetH = 400; // doubled size (+100%)
  // Scale boss to a consistent on-screen height, preserving aspect ratio if possible.
  const refEl = ensureBossSprite();
  const iw = (refEl && refEl.naturalWidth) ? refEl.naturalWidth : 520;
  const ih = (refEl && refEl.naturalHeight) ? refEl.naturalHeight : 360;
  const h = targetH;
  const w = (iw / ih) * h;

  bossState = {
    x: camera.x + (canvas.width / 2) - (w / 2),
    y: camera.y + (canvas.height / 2) - (h / 2) - 20,
    w, h
  };

  ensureBossSprite();

  // Intro: show boss for a moment, play an eagle scream, then open the quiz.
  setFeedback("Boss incoming...", 1.8);
  startBossLoops();
  playEagleScream();
}

function fireBossFeathers(count){
  if (count <= 0) return;
  const pcx = player.x + player.w / 2;
  const pcy = player.y + player.h / 2;

  for (let i = 0; i < count; i++) {
    const fEl = document.createElement('img');
    fEl.alt = '';
    fEl.draggable = false;
    fEl.decoding = 'sync';
    fEl.loading = 'eager';
    fEl.style.zIndex = '24';
    fEl.style.transformOrigin = 'center center';
    setImgSrcWithFallback(fEl, FEATHER_SRC_CANDIDATES);
    enemyLayer.appendChild(fEl);

    const sx = bossState.x + rand(0.15, 0.85) * bossState.w;
    const sy = bossState.y + rand(0.20, 0.80) * bossState.h;

    const dx = pcx - sx;
    const dy = pcy - sy;
    const dist = Math.max(1, Math.hypot(dx, dy));
    const speed = 260; // px/sec (reduced)
    const vx = (dx / dist) * speed;
    const vy = (dy / dist) * speed;

    bossFeathers.push({
      x: sx, y: sy,
      vx, vy,
      ttl: dist / speed,
      el: fEl
    });
  }
}

function endBossEncounter(){
  closeBossModal();
  stopBossLoops();
  despawnBossFeathers();
  despawnBossSprite();
  bossEncounterInProgress = false;
  bossPhase = "idle";
  bossQuizItems = [];

  // Proceed to the next round if the run is still active.
  if (!gameOver && pendingAfterBoss && pendingAfterBoss.kind === "next") {
    beginNextLevelDelay(pendingAfterBoss.idx, 0.55, "Boss defeated. Continue!");
  }
  pendingAfterBoss = null;
}

function updateBoss(dt){
  // Keep overlays aligned (boss + feathers are DOM-based).
  if (bossEncounterInProgress) syncEnemyLayerToCanvas();

  if (!bossEncounterInProgress) return;

  if (gameOver) {
    endBossEncounter();
    return;
  }

    // Intro delay -> then show quiz
  if (bossPhase === "intro") {
    bossIntroT -= dt;
    if (bossIntroT <= 0) {
      beginBossQuizPhase();
    }
  }

  // Quiz timer (auto-submit on timeout; blanks count as wrong)
  if (bossPhase === "quiz") {
    bossQuizT -= dt;
    bossQuizHudTick -= dt;
    if (bossQuizHudTick <= 0) {
      setBossTimerDisplay(bossQuizT);
      bossQuizHudTick = 0.15;
    }
    if (bossQuizT <= 0 && !bossQuizAutoSubmitted) {
      bossQuizAutoSubmitted = true;
      setFeedback("Time's up!", 1.0);
      try { bossSubmitEl && bossSubmitEl.click(); } catch(_) {}
    }
  }

// Feathers fly even while the "world" is paused.
  if (bossPhase === "attack") {
    if (bossFeathers.length) {
      for (let i = bossFeathers.length - 1; i >= 0; i--) {
        const f = bossFeathers[i];
        f.x += f.vx * dt;
        f.y += f.vy * dt;
        f.ttl -= dt;

        if (f.ttl <= 0) {
          // Hit: subtract a life once per feather.
          triggerFlash("rgba(239,68,68,1)", 0.16);
          playDeathSFX();
          loseLife();

          if (f.el && f.el.remove) f.el.remove();
          bossFeathers.splice(i, 1);
        }
      }

      if (!bossFeathers.length) {
        endBossEncounter();
      }
    } else {
      // Safety: if feathers could not spawn, never freeze the run.
      bossAttackFallbackT -= dt;
      if (bossAttackFallbackT <= 0) {
        endBossEncounter();
      }
    }
  }
}

function updateBossOverlays(){
  if (!bossEncounterInProgress || !bossState || !enemyLayer) return;

  syncEnemyLayerToCanvas();

  const r = canvas.getBoundingClientRect();
  const scaleX = r.width / canvas.width;
  const scaleY = r.height / canvas.height;

  // Boss sprite in screen space
  if (bossSpriteEl) {
    const sx = bossState.x - camera.x;
    const sy = bossState.y - camera.y;
    bossSpriteEl.style.display = 'block';
    bossSpriteEl.style.left = (sx * scaleX) + 'px';
    bossSpriteEl.style.top  = (sy * scaleY) + 'px';
    bossSpriteEl.style.width  = (bossState.w * scaleX) + 'px';
    bossSpriteEl.style.height = (bossState.h * scaleY) + 'px';
  }

  // Feather sprites
  for (const f of bossFeathers) {
    if (!f.el) continue;
    const sx = f.x - camera.x;
    const sy = f.y - camera.y;

    f.el.style.display = 'block';
    f.el.style.left = (sx * scaleX) + 'px';
    f.el.style.top  = (sy * scaleY) + 'px';
    // visual size relative to player
    const fw = 56, fh = 56;
    f.el.style.width  = (fw * scaleX) + 'px';
    f.el.style.height = (fh * scaleY) + 'px';
  }
}



function despawnMedkit() {
  if (medkit) medkit.active = false;
  answersSinceMedkitSpawn = 0;
}

function placeMedkitForCurrentLevel(resetCounter) {
  // Place (or re-place) the medkit using the same platform-based spawn rules as the article boxes,
  // but never at the same position as a box.
  medkit = medkit || { x: 0, y: 0, w: MEDKIT_W, h: MEDKIT_H, active: true };
  medkit.w = MEDKIT_W;
  medkit.h = MEDKIT_H;

  const spawnPlats = pickSpawnPlatforms();
  const candidates = shuffle([...(spawnPlats.length ? spawnPlats : platforms)]);
  let placed = false;

  for (const p of candidates) {
    if (!p) continue;
    const x = p.x + Math.floor((p.w - MEDKIT_W) / 2);
    const y = (p.y - AIR_OFFSET) - MEDKIT_H;

    let ok = true;
    for (const c of collectibles) {
      if (!c.active) continue;
      if (aabb(x, y, MEDKIT_W, MEDKIT_H, c.x, c.y, c.w, c.h)) { ok = false; break; }
    }
    if (!ok) continue;

    medkit.x = x;
    medkit.y = y;
    placed = true;
    break;
  }

  if (!placed) {
    // Fallback: place near the first available platform and rely on collision checks.
    const p = spawnPlats[0] || platforms[0];
    medkit.x = p ? (p.x + 12) : (loopStartX + 760);
    medkit.y = p ? ((p.y - AIR_OFFSET) - MEDKIT_H) : 220;
  }

  medkit.active = true;
  if (resetCounter) answersSinceMedkitSpawn = 0;
}

function spawnMedkit() {
  placeMedkitForCurrentLevel(true);
  playHealthSFX();
}

function handleMedkitCollision() {
  if (!medkit || !medkit.active) return;
  const hb = playerHitRect(player);
  const offs = loopOffsetsForX(hb.x);
  for (const off of offs) {
    const mx = medkit.x + off;
    if (aabb(hb.x, hb.y, hb.w, hb.h, mx, medkit.y, medkit.w, medkit.h)) {
      medkit.active = false;
      answersSinceMedkitSpawn = 0;
      lives = MAX_LIVES; // medkits restore full health
      triggerFlash("rgba(34,197,94,1)", 0.14);
      return;
    }
  }
}

  const BOX_W = 110;
  const BOX_H = 48;
  const AIR_OFFSET = 120;

  function pickSpawnPlatforms() {
    const floats = platforms.filter(p => p.h === GEN.h).sort((a,b)=>a.x-b.x);
    const usable = floats.slice(Math.min(2, floats.length));
    const base = (usable.length >= 4) ? usable : floats;

    if (!base.length) return [];
    const n = base.length;
    const q = (a,b) => base.slice(Math.floor(n*a), Math.max(Math.floor(n*a)+1, Math.floor(n*b)));
    const q1=q(0.00,0.25), q2=q(0.25,0.50), q3=q(0.50,0.75), q4=q(0.75,1.00);
    const pick = (bucket) => bucket[Math.floor(Math.random()*bucket.length)];

    if (n >= 4) return [pick(q1), pick(q2), pick(q3), pick(q4)];
    const out = [];
    for (let i=0;i<4;i++) out.push(base[i % n]);
    return out;
  }

  function buildCollectiblesForLevel(i) {
    const lvl = LEVELS[i];
    const opts = shuffle([...lvl.options]);
    const spawnPlats = pickSpawnPlatforms();

    collectibles = opts.map((label, idx) => {
      const p = spawnPlats[idx % spawnPlats.length];
      const x = p ? (p.x + Math.floor((p.w - BOX_W) / 2)) : (loopStartX + 520 + idx*140);
      const y = p ? ((p.y - AIR_OFFSET) - BOX_H) : 220;
            const corrects = Array.isArray(lvl.correct) ? lvl.correct : [lvl.correct];
      return { x, y, w: BOX_W, h: BOX_H, label, isCorrect: corrects.includes(label), active: true };
    });
  }

  function setFeedback(text, seconds = 1.2) {
    feedback.text = text;
    feedback.timer = seconds;
  }

  function beginNextLevelDelay(nextIdx, seconds, message) {
    transition.active = true;
    transition.t = seconds;
    transition.nextLevel = nextIdx;
    setFeedback(message, seconds);
  }

  function finishGame() {
    collectibles = [];
    updateBestFromScore();
    setFeedback("All done. Tap Restart to play again.", 999);
  }

  function loseLife() {
    lives = Math.max(0, lives - 1);
    if (lives <= 0) {
      gameOver = true;
            updateBestFromScore();
setFeedback("Game over. Tap Restart to try again.", 999);
      // End-of-run review (shows mistakes + explanations)
      setTimeout(() => showReviewModal(), 180);
    }
  }

  
function onCorrectPick() {
  const hadMedkit = !!(medkit && medkit.active);

  soundCorrect();
  triggerFlash("rgba(34,197,94,1)", 0.18);
  score += 100;

        updateBestFromScore();
correctAnsweredCount += 1;
    if (correctAnsweredCount % 3 === 0 && !(medkit && medkit.active) && !medkitPending) {
      medkitPending = true;
    }
  // Medkit despawns if not collected after 2 completed answers (count starts after it spawns).
  if (hadMedkit && medkit && medkit.active) {
    answersSinceMedkitSpawn += 1;
    if (answersSinceMedkitSpawn >= 2) despawnMedkit();
  }

  if (levelIndex < LEVELS.length - 1) {
    // Every 10 completed (correct) sentences, pause and run a boss mini-quiz.
    if (shouldTriggerBoss()) {
      startBossEncounter({ kind: "next", idx: levelIndex + 1 });
    } else {
      beginNextLevelDelay(levelIndex + 1, 1.1, "Correct (+100).");
    }
  } else {
    setFeedback("Correct (+100).", 1.2);
    setTimeout(() => finishGame(), 700);
  }
}

  
function onWrongPick(chosenLabel) {
  const hadMedkit = !!(medkit && medkit.active);

  // Record the first wrong attempt for this sentence (for the end-of-run review)
  recordMistake(levelIndex, chosenLabel);
  soundWrong();
  triggerFlash("rgba(239,68,68,1)", 0.22);
  loseLife();
  if (!gameOver) setFeedback("Incorrect. Try again.", 1.4);

  // Medkit despawns if not collected after 2 completed answers.
  if (hadMedkit && medkit && medkit.active) {
    answersSinceMedkitSpawn += 1;
    if (answersSinceMedkitSpawn >= 2) despawnMedkit();
  }
}

  function handleCollectibleCollision() {
    // Collectibles repeat with the looped stage: test against the instance in the
    // current segment and its neighbors.
    const hb = playerHitRect(player);
    const offs = loopOffsetsForX(hb.x);
    for (const c of collectibles) {
      if (!c.active) continue;
      for (const off of offs) {
        const cx = c.x + off;
        if (aabb(hb.x, hb.y, hb.w, hb.h, cx, c.y, c.w, c.h)) {
          c.active = false;
          if (c.isCorrect) onCorrectPick();
          else onWrongPick(c.label);
          return;
        }
      }
    }
  }

  // ----------------------------
  // DRAW HELPERS
  // ----------------------------
  function roundRect(x, y, w, h, r, fill) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if (fill) ctx.fill(); else ctx.stroke();
  }

  function drawWrappedText(text, x, y, maxWidth, lineHeight) {
    const words = String(text || "").split(/\s+/);
    let line = "";
    let yy = y;
    for (let n = 0; n < words.length; n++) {
      const test = line + words[n] + " ";
      const w = ctx.measureText(test).width;
      if (w > maxWidth && n > 0) {
        ctx.fillText(line.trimEnd(), x, yy);
        line = words[n] + " ";
        yy += lineHeight;
      } else {
        line = test;
      }
    }
    if (line) ctx.fillText(line.trimEnd(), x, yy);
  }

  // ----------------------------
  // DRAWING
  // ----------------------------
  function drawBackground() {
    // Sky base (keeps the same clean look as before)
    ctx.save();
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, "#bfe9ff");
    g.addColorStop(0.55, "#d9f4ff");
    g.addColorStop(1, "#f4fbff");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();

    // In-game background image (adapted 'background_side') with parallax scrolling.
    // The image scrolls slower than the camera for depth.
    if (bgReady) {
      const parallax = 0.20;
      const iw = bgImg.naturalWidth || bgImg.width;
      const ih = bgImg.naturalHeight || bgImg.height;

      // Scale image to fill the canvas height (maintains aspect ratio).
      const scale = canvas.height / ih;
      const dw = iw * scale;
      const dh = canvas.height;

      // Parallax tiling in X with a *soft crossfade* at the seam.
      // This avoids visible hard edges when the artwork is not perfectly tileable.
      // Use an unwrapped camera value so parallax does not jump when the world wraps.
      const camXUnwrapped = (typeof worldWrapOffset === 'number') ? (camera.x + worldWrapOffset) : camera.x;
      const raw = -camXUnwrapped * parallax;
      let offsetX = raw % dw;
      if (offsetX > 0) offsetX -= dw;

      // Width of the blended seam region (in screen pixels).
      const blend = Math.max(40, Math.min(140, dw * 0.14));
      const steps = 24; // more steps = smoother blend (costs a few more draw calls)
      const stripW = blend / steps;

      ctx.save();
      const _prevSmooth = ctx.imageSmoothingEnabled;
      ctx.imageSmoothingEnabled = true;
      ctx.globalAlpha = 0.95;

      // 1) Draw the base tiles.
      for (let x = offsetX; x < canvas.width + dw; x += dw) {
        ctx.drawImage(bgImg, x, 0, dw, dh);
      }

      // 2) Crossfade the seam between adjacent tiles.
      // We overlay the *start* of the next tile over the *end* of the current tile
      // with an alpha ramp, creating a smooth transition.
      for (let x = offsetX; x < canvas.width + dw; x += dw) {
        const seamStart = x + dw - blend;
        const nextTileX = x + dw - blend; // shift next tile left so its left edge aligns with seamStart

        for (let i = 0; i < steps; i++) {
          const a = i / (steps - 1);
          const sx = seamStart + i * stripW;

          ctx.save();
          ctx.globalAlpha = 0.95 * a;
          ctx.beginPath();
          ctx.rect(sx, 0, stripW + 0.5, dh);
          ctx.clip();

          // Draw the next tile, shifted left by `blend`, so only its left edge occupies the seam region.
          ctx.drawImage(bgImg, nextTileX, 0, dw, dh);
          ctx.restore();
        }
      }

      ctx.imageSmoothingEnabled = _prevSmooth;
      ctx.restore();

      ctx.save();

      // Overlay: subtle atmospheric haze
      const haze = ctx.createLinearGradient(0, 0, 0, canvas.height);
      haze.addColorStop(0, "rgba(255,255,255,0.20)");
      haze.addColorStop(0.55, "rgba(255,255,255,0.08)");
      haze.addColorStop(1, "rgba(255,255,255,0.00)");
      ctx.fillStyle = haze;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const v = ctx.createRadialGradient(canvas.width*0.5, canvas.height*0.45, 40, canvas.width*0.5, canvas.height*0.45, canvas.width*0.9);
      v.addColorStop(0, "rgba(0,0,0,0)");
      v.addColorStop(1, "rgba(0,0,0,0.10)");
      ctx.fillStyle = v;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    // Moving clouds (independent parallax, keeps motion even if player stands still)
    function puff(x, y, s=1) {
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.16)";
      ctx.shadowBlur = 10;
      ctx.shadowOffsetY = 6;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(x, y, 56*s, 30*s, 0, 0, Math.PI*2);
      ctx.ellipse(x + 42*s, y - 10*s, 48*s, 26*s, 0, 0, Math.PI*2);
      ctx.ellipse(x + 92*s, y, 60*s, 32*s, 0, 0, Math.PI*2);
      ctx.ellipse(x + 52*s, y + 16*s, 68*s, 32*s, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowColor = "transparent";
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(x + 18*s, y - 10*s, 22*s, 12*s, 0, 0, Math.PI*2);
      ctx.ellipse(x + 62*s, y - 16*s, 18*s, 10*s, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Reduce sub-pixel jitter in the cloud layer.
    // Use unwrapped camera for stable looping parallax.
    let cloudOffset = ((camera.x + worldWrapOffset) * 0.35) % 720;
    cloudOffset = Math.round(cloudOffset);
    ctx.save();
    ctx.translate(-cloudOffset, 0);
    for (let i = -1; i < 7; i++) {
      const cx = i * 720 + 120;
      const cy = 90 + (i % 2) * 24;
      puff(cx, cy, 0.95);
      puff(cx + 280, cy + 34, 0.78);
    }
    ctx.restore();
  }



  function drawPlatforms() {
    // Ground keeps the 3D soil/grass look; floating platforms become wooden planks.
    const grassTop = "#63d36f";
    const grassTop2 = "#54c862";
    const dirt = "#b1683d";
    const dirt2 = "#9f5b34";

    function tileFace(x, y, w, h, alpha=0.12) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      const step = 26;
      for (let xx = x + step; xx < x + w; xx += step) {
        ctx.beginPath();
        ctx.moveTo(xx, y + 8);
        ctx.lineTo(xx, y + h - 8);
        ctx.stroke();
      }
      for (let yy = y + step; yy < y + h; yy += step) {
        ctx.beginPath();
        ctx.moveTo(x + 8, yy);
        ctx.lineTo(x + w - 8, yy);
        ctx.stroke();
      }
      ctx.restore();
    }

    function groundBlock(sx, sy, w, h) {
      const capH = Math.max(10, Math.min(16, h));
      const bevel = 10;

      // Drop shadow
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.22)";
      ctx.shadowBlur = 14;
      ctx.shadowOffsetY = 10;
      ctx.fillStyle = dirt2;
      roundRect(sx, sy, w, h, 10, true);
      ctx.restore();

      // Dirt body
      ctx.fillStyle = dirt;
      roundRect(sx, sy, w, h, 10, true);

      // Facet shade
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.moveTo(sx + w, sy + 10);
      ctx.lineTo(sx + w - bevel, sy + 18);
      ctx.lineTo(sx + w - bevel, sy + h - 14);
      ctx.lineTo(sx + w, sy + h - 8);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // Inner band
      ctx.fillStyle = dirt2;
      ctx.fillRect(sx + 2, sy + capH + 2, w - 4, Math.max(0, h - capH - 4));

      // Seams
      tileFace(sx + 6, sy + capH + 6, w - 12, h - capH - 12, 0.10);

      // Grass cap
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.18)";
      ctx.shadowBlur = 10;
      ctx.shadowOffsetY = 6;
      ctx.fillStyle = grassTop;
      roundRect(sx - 2, sy - 2, w + 4, capH + 6, 12, true);
      ctx.restore();

      // Grass highlight
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#fff";
      roundRect(sx + 6, sy + 2, w - 12, Math.max(6, capH*0.45), 10, true);
      ctx.restore();

      // Grass underside shade
      ctx.fillStyle = grassTop2;
      ctx.fillRect(sx - 2, sy + capH + 1, w + 4, 6);

      // Outline
      ctx.strokeStyle = "rgba(15,23,42,0.18)";
      ctx.lineWidth = 2;
      roundRect(sx, sy, w, h, 10, false);
    }

    function woodPlatform(sx, sy, w, h) {
      // render as a chunky plank with plank seams + subtle grain
      const r = 12;
      const topH = Math.max(10, Math.min(16, h));

      // shadow
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = 14;
      ctx.shadowOffsetY = 10;
      ctx.fillStyle = "rgba(0,0,0,0.10)";
      roundRect(sx, sy, w, h, r, true);
      ctx.restore();

      // body gradient
      const grad = ctx.createLinearGradient(sx, sy, sx, sy + h);
      grad.addColorStop(0, "#c98a55");
      grad.addColorStop(0.55, "#b77745");
      grad.addColorStop(1, "#9f643a");
      ctx.fillStyle = grad;
      roundRect(sx, sy, w, h, r, true);

      // top highlight strip
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#fff";
      roundRect(sx + 6, sy + 4, w - 12, Math.min(10, topH), 10, true);
      ctx.restore();

      // plank seams (vertical)
      const plankCount = Math.max(2, Math.round(w / 90));
      const plankW = w / plankCount;
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.strokeStyle = "rgba(15,23,42,0.35)";
      ctx.lineWidth = 2;
      for (let i = 1; i < plankCount; i++) {
        const x = sx + i * plankW;
        ctx.beginPath();
        ctx.moveTo(x, sy + 6);
        ctx.lineTo(x, sy + h - 6);
        ctx.stroke();
      }
      ctx.restore();

      // wood grain (subtle wavy lines)
      ctx.save();
      ctx.globalAlpha = 0.10;
      ctx.strokeStyle = "rgba(15,23,42,0.45)";
      ctx.lineWidth = 2;
      const lines = Math.max(2, Math.round(h / 10));
      for (let i = 0; i < lines; i++) {
        const yy = sy + 10 + i * (h - 20) / Math.max(1, lines - 1);
        ctx.beginPath();
        ctx.moveTo(sx + 10, yy);
        const amp = 4;
        for (let xx = sx + 10; xx <= sx + w - 10; xx += 30) {
          ctx.quadraticCurveTo(xx + 15, yy + (i % 2 ? amp : -amp), xx + 30, yy);
        }
        ctx.stroke();
      }
      ctx.restore();

      // nails
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "rgba(15,23,42,0.65)";
      for (let i = 0; i < plankCount; i++) {
        const nx1 = sx + i * plankW + 14;
        const nx2 = sx + (i + 1) * plankW - 14;
        const ny = sy + topH + 10;
        for (const nx of [nx1, nx2]) {
          ctx.beginPath();
          ctx.ellipse(nx, ny, 3.2, 3.2, 0, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.restore();

      // underside shade band
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#000";
      roundRect(sx + 4, sy + h - 12, w - 8, 10, 8, true);
      ctx.restore();

      // outline
      ctx.strokeStyle = "rgba(15,23,42,0.22)";
      ctx.lineWidth = 2;
      roundRect(sx, sy, w, h, r, false);

      // optional simple supports on thicker platforms
      if (h >= 26 && w >= 90) {
        ctx.save();
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = "rgba(0,0,0,0.20)";
        const postW = 10;
        const postH = Math.min(26, h - 6);
        const left = sx + 18;
        const right = sx + w - 18 - postW;
        roundRect(left, sy + h - postH, postW, postH, 6, true);
        roundRect(right, sy + h - postH, postW, postH, 6, true);
        ctx.restore();
      }
    }

    for (const off of loopOffsetsForX(camera.x + canvas.width * 0.5)) {
      for (const plat of platforms) {
        const sx = (plat.x + off) - camera.x;
        const sy = plat.y - camera.y;
        // quick cull
        if (sx + plat.w < -80 || sx > canvas.width + 80) continue;
        const isGround = plat.h === GROUND_H;
        if (isGround) groundBlock(sx, sy, plat.w, plat.h);
        else woodPlatform(sx, sy, plat.w, plat.h);
      }
    }
  }
  function drawPlayer(p) {
    const sx = p.x - camera.x;
    const sy = p.y - camera.y;


    // DOM sprite overlay for reliable animated GIF playback.
    if (!enemyLayer) {
      // Fallback: if the DOM layer is missing, render a simple placeholder.
      ctx.fillStyle = "rgba(30, 41, 59, 0.95)";
      roundRect(sx, sy, p.w, p.h, 8, true);
      ctx.strokeStyle = "rgba(15,23,42,0.35)";
      ctx.lineWidth = 2;
      roundRect(sx, sy, p.w, p.h, 8, false);
      return;
    }

    // Keep the overlay layer aligned even if there are no enemies.
    syncEnemyLayerToCanvas();

    const r = canvas.getBoundingClientRect();
    const scaleX = r.width / canvas.width;
    const scaleY = r.height / canvas.height;

    const im = ensurePlayerEl();
    if (!im) return;

// During a boss encounter, keep the player sprite in the foreground (DOM layer),
// using the idle still so it doesn't look like the character is running in place.
if (bossEncounterInProgress) {
  // Prefer the still PNG; fallback to the last known animated source.
  const stillSrc = (playerIdleReady && playerIdleImg && playerIdleImg.src) ? playerIdleImg.src : "";
  const useSrc = stillSrc || playerSpriteAnimatedSrc || im.src;
  if (useSrc && im.src !== useSrc) im.src = useSrc;

  im.style.display = 'block';
  im.style.left = ((sx + PLAYER_SPRITE_OFF_X) * scaleX) + 'px';
  im.style.top = ((sy + PLAYER_SPRITE_OFF_Y) * scaleY) + 'px';
  im.style.width = (p.w * scaleX) + 'px';
  im.style.height = (p.h * scaleY) + 'px';
  im.style.transform = (p.facing === -1) ? 'scaleX(-1)' : '';
  return;
}


    // Show the animated GIF only while left/right input is held.
    // When idle, hide the DOM <img> (so the GIF cannot continue animating on-screen)
    // and draw the last frozen frame onto the canvas.
    if (playerMoveInput) {
      if (playerSpriteReady && playerSpriteAnimatedSrc && im.src !== playerSpriteAnimatedSrc) {
        im.src = playerSpriteAnimatedSrc;
      }

      im.style.display = 'block';
      im.style.left = ((sx + PLAYER_SPRITE_OFF_X) * scaleX) + 'px';
      im.style.top = ((sy + PLAYER_SPRITE_OFF_Y) * scaleY) + 'px';
      im.style.width = (p.w * scaleX) + 'px';
      im.style.height = (p.h * scaleY) + 'px';
      im.style.transform = (p.facing === -1) ? 'scaleX(-1)' : '';
    } else {
      // Ensure the animated element is not visible while idle.
      im.style.display = 'none';

      // Draw idle still sprite on the canvas.
      if (playerIdleReady) {
        const dx = sx + PLAYER_SPRITE_OFF_X;
        const dy = sy + PLAYER_SPRITE_OFF_Y;

        ctx.save();
        if (p.facing === -1) {
          // Mirror around the sprite center
          ctx.translate(dx + p.w / 2, dy + p.h / 2);
          ctx.scale(-1, 1);
          ctx.drawImage(playerIdleImg, -p.w / 2, -p.h / 2, p.w, p.h);
        } else {
          ctx.drawImage(playerIdleImg, dx, dy, p.w, p.h);
        }
        ctx.restore();
      } else if (playerFrozenReady) {
        // Fallback: if the Stil image cannot be loaded, use the last frozen GIF frame.
        const dx = sx + PLAYER_SPRITE_OFF_X;
        const dy = sy + PLAYER_SPRITE_OFF_Y;

        ctx.save();
        if (p.facing === -1) {
          ctx.translate(dx + p.w / 2, dy + p.h / 2);
          ctx.scale(-1, 1);
          ctx.drawImage(playerFrozenCanvas, -p.w / 2, -p.h / 2, p.w, p.h);
        } else {
          ctx.drawImage(playerFrozenCanvas, dx, dy, p.w, p.h);
        }
        ctx.restore();
      } else {
        // Fallback placeholder
        ctx.fillStyle = "rgba(30, 41, 59, 0.95)";
        roundRect(sx, sy, p.w, p.h, 8, true);
        ctx.strokeStyle = "rgba(15,23,42,0.35)";
        ctx.lineWidth = 2;
        roundRect(sx, sy, p.w, p.h, 8, false);
      }
    }
  }

  function drawCollectibles() {
    for (const off of loopOffsetsForX(camera.x + canvas.width * 0.5)) {
      for (const c of collectibles) {
        if (!c.active) continue;
        const x = (c.x + off) - camera.x;
        const y = c.y - camera.y;

        // quick cull
        if (x + c.w < -120 || x > canvas.width + 120) continue;

        // Soft shadow
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.22)";
        ctx.shadowBlur = 16;
        ctx.shadowOffsetY = 10;
        ctx.fillStyle = "rgba(255,255,255,0.96)";
        roundRect(x, y, c.w, c.h, 14, true);
        ctx.restore();

        // Face
        ctx.fillStyle = "rgba(255,255,255,0.98)";
        roundRect(x, y, c.w, c.h, 14, true);

        // Top lip (subtle 3D cue)
        ctx.save();
        ctx.globalAlpha = 0.10;
        ctx.fillStyle = "#000";
        roundRect(x + 2, y + 2, c.w - 4, 12, 12, true);
        ctx.restore();

        // Border
        ctx.strokeStyle = "rgba(15,23,42,0.22)";
        ctx.lineWidth = 2;
        roundRect(x, y, c.w, c.h, 14, false);

        // Label
        ctx.fillStyle = "rgba(15,23,42,0.92)";
        ctx.font = "800 17px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(c.label, x + c.w/2, y + c.h/2 + 1);
      }
    }
// MedKit (if active)
if (medkit && medkit.active) {
  for (const off of loopOffsetsForX(camera.x + canvas.width * 0.5)) {
    const x = (medkit.x + off) - camera.x;
    const y = medkit.y - camera.y;

    // quick cull
    if (x + medkit.w < -120 || x > canvas.width + 120) continue;

    ctx.save();
    ctx.shadowColor = "rgba(0,0,0,0.22)";
    ctx.shadowBlur = 14;
    ctx.shadowOffsetY = 10;

    if (medkitReady) {
      ctx.drawImage(medkitImg, x, y, medkit.w, medkit.h);
    } else {
      // Placeholder if the image is missing
      ctx.fillStyle = "rgba(255,255,255,0.96)";
      roundRect(x, y, medkit.w, medkit.h, 14, true);
      ctx.strokeStyle = "rgba(15,23,42,0.22)";
      ctx.lineWidth = 2;
      roundRect(x, y, medkit.w, medkit.h, 14, false);
      ctx.fillStyle = "rgba(15,23,42,0.92)";
      ctx.font = "900 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("+", x + medkit.w/2, y + medkit.h/2);
    }
    ctx.restore();
  }
}


  }


    function updateHud() {
    if (!hudLevelEl || !hudHeartsEl || !hudScoreEl || !hudBestEl || !hudTimeEl || !hudPromptEl || !hudFeedbackEl) return;

    const finished = (levelIndex >= LEVELS.length - 1) && collectibles.length === 0 && feedback.timer > 100;
    hudLevelEl.textContent = finished ? "Finished" : `Level ${levelIndex + 1} / ${LEVELS.length}`;

    const heartsFull = "♥".repeat(lives);
    const heartsEmpty = "♡".repeat(MAX_LIVES - lives);
    hudHeartsEl.textContent = `${heartsFull}${heartsEmpty}`;

    hudScoreEl.textContent = `Score: ${score}`;
        hudBestEl.textContent = `Best: ${bestScore}`;
hudTimeEl.textContent = `Time: ${fmtTime(elapsedSeconds())}`;

    hudPromptEl.textContent = finished ? "You completed all sentences." : (LEVELS[levelIndex] ? LEVELS[levelIndex].prompt : "");

    

    // Read out the sentence whenever it changes.
    if (!finished) {
      maybeSpeakCurrentPrompt(false);
    }
const showFeedback = (feedback.timer > 0 && feedback.text);

    hudFeedbackEl.textContent = showFeedback ? feedback.text : "";
    hudFeedbackEl.style.display = showFeedback ? "block" : "none";
    if (hudHintEl) hudHintEl.style.display = showFeedback ? "none" : "";

    // If HUD height changed (e.g., feedback appears), refit the canvas.
    if (hudEl) {
      const h = hudEl.offsetHeight;
      if (Math.abs(h - lastHudHeight) > 1) {
        lastHudHeight = h;
        fitCanvasToViewport();
      }
    }
  }

  function drawTopUI() {
    const pad = 14;
    const boxW = canvas.width - pad * 2;
    const boxH = 70;
    const x = pad;
    const y = pad;

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.88)";
    roundRect(x, y, boxW, boxH, 14, true);

    ctx.strokeStyle = "rgba(15,23,42,0.20)";
    ctx.lineWidth = 2;
    roundRect(x, y, boxW, boxH, 14, false);

    const finished = (levelIndex >= LEVELS.length - 1) && collectibles.length === 0 && feedback.timer > 100;

    ctx.fillStyle = "rgba(15,23,42,0.85)";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(finished ? "Finished" : `Level ${levelIndex + 1} / ${LEVELS.length}`, x + 16, y + 10);

    ctx.font = "600 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textBaseline = "bottom";
    ctx.fillText(finished ? "You completed all sentences." : LEVELS[levelIndex].prompt, x + 16, y + boxH - 12);

    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Score: ${score}   Time: ${fmtTime(elapsedSeconds())}`, x + boxW - 16, y + 10);

    const heartsFull = "♥".repeat(lives);
    const heartsEmpty = "♡".repeat(MAX_LIVES - lives);
    ctx.font = "700 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(15,23,42,0.85)";
    ctx.fillText(`${heartsFull}${heartsEmpty}`, x + boxW - 16, y + 30);

    ctx.font = "500 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(15,23,42,0.65)";
    ctx.textBaseline = "bottom";
    ctx.fillText("←/→ move  •  ↑/Space jump (double jump)  •  Restart button", x + boxW - 16, y + boxH - 14);

    if (feedback.timer > 0 && feedback.text) {
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.font = "600 15px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillStyle = "rgba(15,23,42,0.88)";
      drawWrappedText(feedback.text, x + 16, y + boxH + 8, boxW - 32, 18);
    }

    ctx.restore();
  }

  // ----------------------------
  // GAME FLOW
  // ----------------------------
  function spawnRound(i, resetRun = false) {
    levelIndex = clamp(i, 0, LEVELS.length - 1);
    generatePlatforms();
    buildCollectiblesForLevel(levelIndex);

// MedKit spawns are tied to the round start so they survive level transitions.
if (medkitPending) {
      medkitPending = false;
      if (!(medkit && medkit.active)) spawnMedkit();
    } else if (medkit && medkit.active) {
  // Re-place active medkit using the current level's spawn points.
  placeMedkitForCurrentLevel(false);
}
    resetEnemies();
    player = makePlayer();
    camera.x = 0;
    camera.y = 0; // locked
    jumpQueued = false;
    restartQueued = false;
    transition.active = false;
    transition.t = 0;

    if (resetRun) {
      score = 0;
      lives = MAX_LIVES;
      gameOver = false;
      runStartMs = performance.now();
      feedback = { text: "", timer: 0 };
      mistakeLog = [];
      mistakeSeenByLevel = new Set();

medkit = null;
medkitPending = false;
correctAnsweredCount = 0;
answersSinceMedkitSpawn = 0;
nextBossAt = BOSS_EVERY;
bossEncounterInProgress = false;
bossPhase = "idle";
pendingAfterBoss = null;
bossQuizItems = [];
bossUsedPromptIdx = new Set();
closeBossModal();
stopBossLoops();
despawnBossFeathers();
despawnBossSprite();

      closeReviewModal();
    }
  }

  // ----------------------------
  // UPDATE / RENDER LOOP
  // ----------------------------
  function update(dt) {
        if (restartQueued) {
      restartQueued = false;
      // Restart always randomizes the sentence order for the next run and resets run state.
      shuffleLevels();
      closeReviewModal();
      spawnRound(0, true);
      return;
    }

    if (flash.t > 0) flash.t = Math.max(0, flash.t - dt);

    if (feedback.timer > 0 && feedback.timer < 900) {
      feedback.timer = Math.max(0, feedback.timer - dt);
      if (feedback.timer === 0) feedback.text = "";
    }

    // Pause the simulation until the player presses Start on the intro screen.
    if (!gameStarted) return;

    if (gameOver) return;

    if (transition.active) {
      transition.t = Math.max(0, transition.t - dt);
      if (transition.t === 0) {
        const next = transition.nextLevel;
        transition.active = false;
        spawnRound(next, false);
      }
      return;
    }

    // Boss encounter: pause the world simulation, but keep boss/feathers updating.
    if (bossEncounterInProgress) {
      playerMoveInput = false;
      updateBoss(dt);
      return;
    }

    const leftPressed  = isDown("arrowleft")  || touch.left;
    const rightPressed = isDown("arrowright") || touch.right;

    let ax = 0;
    if (leftPressed) ax -= WORLD.moveAccel;
    if (rightPressed) ax += WORLD.moveAccel;
    if (ax !== 0) player.facing = ax > 0 ? 1 : -1;

    player.vx += ax * dt;
    player.vx = clamp(player.vx, -WORLD.maxSpeed, WORLD.maxSpeed);

    if (ax === 0) {
      const fr = Math.pow(WORLD.friction, dt * 60);
      player.vx *= fr;
      if (Math.abs(player.vx) < 10) player.vx = 0;
    }

    // Track whether the player is actively pressing left/right (used to gate GIF animation).
    playerMoveInput = leftPressed || rightPressed;

    // Freeze the current GIF frame when movement input stops.
    if (playerWasMoving && !playerMoveInput) freezePlayerSpriteFrame();
    playerWasMoving = playerMoveInput;

    player.coyote = Math.max(0, player.coyote - dt);
    player.jumpBuf = Math.max(0, player.jumpBuf - dt);

    if (jumpQueued) { player.jumpBuf = WORLD.jumpBuffer; jumpQueued = false; }

    player.vy += WORLD.gravity * dt;
    player.vy = clamp(player.vy, -2000, 2000);

    if (player.jumpBuf > 0) {
      const canGroundJump = player.onGround || player.coyote > 0;
      const canAirJump = !canGroundJump && player.airJumpsLeft > 0;
      if (canGroundJump || canAirJump) {
        player.vy = -WORLD.jumpSpeed;
        playJumpSFX();
        player.onGround = false;
        player.coyote = 0;
        player.jumpBuf = 0;
        if (canAirJump) player.airJumpsLeft -= 1;
      }
    }

    player.prevHb = playerHitRect(player);

    resolveCollisions(player, dt);
    if (collectibles.length) handleCollectibleCollision();

    if (medkit && medkit.active) handleMedkitCollision();
    // Seamless horizontal looping (prevents running off the end of the ground).
    wrapWorldIfNeeded();

    if (player.y > 1200) { setFeedback("Fell. Respawning.", 0.9); spawnRound(levelIndex, false); }

    // Horizontal camera follow only (vertical locked)
    const targetX = player.x - canvas.width * 0.35;
    camera.x += (targetX - camera.x) * (1 - Math.pow(0.001, dt));
    // No hard camera clamp: required for seamless wrapping.
    camera.y = 0;

    // Enemies (time-regulated spawns, move right->left)
    updateEnemies(dt);
    handleEnemyCollision();
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();
    drawPlatforms();
    drawEnemies();
    drawCollectibles();
    drawPlayer(player);
    updateBossOverlays();
    updateHud();

    if (flash.t > 0) {
      const a = (flash.t / flash.dur) * 0.30;
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = flash.color;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
  }

  let lastTs = 0;
  function loop(ts) {
    const t = ts / 1000;
    const dt = Math.min(0.033, (t - lastTs) || 0);
    lastTs = t;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // Prepare an initial randomized order and preload the first round.
  shuffleLevels();
  spawnRound(0, true);
  // Show the instructions before the first run begins.
  openIntroModal();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
