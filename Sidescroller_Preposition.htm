<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Preposition Side-Scroller (Desktop + Touch Controls)</title>
  <style>
    :root{
      --bg1:#cfe9ff; --bg2:#e8f6ff;
      --ground:#5c8a3a; --ground2:#4a732f;
      --btn:#1f2f67;
      --btn2:#23357a;
    }

    html,body{
      height:100%;
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(900px 520px at 20% 15%, rgba(255,255,255,0.90), rgba(255,255,255,0) 60%),
                  radial-gradient(800px 520px at 80% 10%, rgba(255,255,255,0.75), rgba(255,255,255,0) 60%),
                  linear-gradient(var(--bg1), var(--bg2));
      overflow:hidden;
    }

    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      opacity:0.55;
      background:
        radial-gradient(110px 60px at 12% 18%, rgba(255,255,255,0.95), rgba(255,255,255,0) 70%),
        radial-gradient(140px 70px at 18% 16%, rgba(255,255,255,0.90), rgba(255,255,255,0) 70%),
        radial-gradient(120px 60px at 24% 19%, rgba(255,255,255,0.92), rgba(255,255,255,0) 70%),
        radial-gradient(120px 60px at 62% 14%, rgba(255,255,255,0.92), rgba(255,255,255,0) 70%),
        radial-gradient(160px 80px at 70% 12%, rgba(255,255,255,0.90), rgba(255,255,255,0) 70%),
        radial-gradient(120px 60px at 78% 15%, rgba(255,255,255,0.92), rgba(255,255,255,0) 70%),
        radial-gradient(520px 220px at 15% 78%, rgba(45,120,90,0.22), rgba(45,120,90,0) 70%),
        radial-gradient(560px 240px at 55% 82%, rgba(45,120,90,0.20), rgba(45,120,90,0) 72%),
        radial-gradient(520px 220px at 90% 80%, rgba(45,120,90,0.18), rgba(45,120,90,0) 72%);
    }
    body::after{
      content:"";
      position:fixed;
      inset:-2px;
      pointer-events:none;
      background: radial-gradient(1200px 800px at 50% 35%, rgba(0,0,0,0), rgba(0,0,0,0.10) 70%, rgba(0,0,0,0.16) 100%);
      mix-blend-mode:multiply;
      opacity:0.55;
    }

    .wrap{
      height:100%;
      display:grid;
      place-items:center;
      padding:22px;
      box-sizing:border-box;
    }

    .frame{
      width:min(1040px, 96vw);
      padding:16px;
      border-radius:18px;
      background: rgba(255,255,255,0.32);
      border:1px solid rgba(255,255,255,0.55);
      box-shadow: 0 18px 55px rgba(0,0,0,0.18);
      backdrop-filter: blur(8px);
    }

    canvas{
      width:100%;
      aspect-ratio:16/9;
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.15);
      outline:1px solid rgba(15,23,42,0.10);
      display:block;
      background:transparent;
    }

    .controls-bar{
      margin-top:8px; /* slightly tighter */
      display:flex;
      gap:14px;
      align-items:stretch;
      justify-content:space-between;
      user-select:none;
      -webkit-user-select:none;
    }

    .ctrl{
      flex:1 1 0;
      height:64px;
      border-radius:14px;
      background:linear-gradient(180deg, var(--btn2), var(--btn));
      border:1px solid rgba(255,255,255,0.14);
      box-shadow:0 10px 24px rgba(0,0,0,0.18);
      color:#fff;
      font-weight:800;
      font-size:20px;
      letter-spacing:0.2px;
      display:grid;
      place-items:center;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      cursor:pointer;
    }
    .ctrl.smalltxt{ font-size:18px; }
    .ctrl:active, .ctrl.pressed{
      transform: translateY(1px);
      filter: brightness(1.07);
      box-shadow:0 7px 18px rgba(0,0,0,0.18);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="frame">
      <canvas id="game" width="960" height="540"></canvas>

      <div class="controls-bar" aria-label="Controls">
        <div class="ctrl" id="btnLeft" role="button" aria-label="Move left">◀</div>
        <div class="ctrl smalltxt" id="btnJump" role="button" aria-label="Jump">Jump</div>
        <div class="ctrl" id="btnRight" role="button" aria-label="Move right">▶</div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  // ----------------------------
  // AUDIO (WebAudio)
  // ----------------------------
  let audioCtx = null;
  function ensureAudio() {
    if (audioCtx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return;
    audioCtx = new AC();
  }
  function playBeep({ type="sine", freq=440, dur=0.14, gain=0.12, endFreq=null }) {
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t0);
    if (endFreq != null) osc.frequency.linearRampToValueAtTime(endFreq, t0 + dur);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + dur);
  }
  function soundCorrect() {
    playBeep({ type:"triangle", freq:620, endFreq:880, dur:0.16, gain:0.14 });
    setTimeout(() => playBeep({ type:"triangle", freq:880, endFreq:980, dur:0.12, gain:0.10 }), 110);
  }
  function soundWrong() {
    playBeep({ type:"sawtooth", freq:220, endFreq:160, dur:0.22, gain:0.13 });
  }

  // ----------------------------
  // SCREEN FLASH
  // ----------------------------
  let flash = { t: 0, dur: 0, color: "rgba(0,0,0,0)" };
  function triggerFlash(color, dur=0.18) {
    flash.color = color;
    flash.t = dur;
    flash.dur = dur;
  }

  // ----------------------------
  // SIZES
  // ----------------------------
  const CHAR_W = 34, CHAR_H = 44;
  const PLATFORM_W = CHAR_W * 3;
  const PLATFORM_H = 18;

  // Thin ground, but ALWAYS at bottom
  const GROUND_H = 40;

  // ----------------------------
  // LEVELS (30)
  // ----------------------------
  const LEVELS = [
    { prompt: "He's surfing ____ the internet.", options: ["on","in","at","to"], correct: "on" },
    { prompt: "We arrived ____ the station at 6.", options: ["at","to","in","on"], correct: "at" },
    { prompt: "I was born ____ 2008.", options: ["in","on","at","since"], correct: "in" },
    { prompt: "The keys are ____ the table.", options: ["on","in","at","to"], correct: "on" },
    { prompt: "She is interested ____ biology.", options: ["in","on","at","for"], correct: "in" },
    { prompt: "He apologized ____ being late.", options: ["for","about","to","with"], correct: "for" },
    { prompt: "I’m good ____ math.", options: ["at","in","on","to"], correct: "at" },
    { prompt: "We depend ____ public transport.", options: ["on","in","at","from"], correct: "on" },
    { prompt: "They are afraid ____ spiders.", options: ["of","from","about","for"], correct: "of" },
    { prompt: "Please write ____ pen, not pencil.", options: ["with","by","in","on"], correct: "with" },
    { prompt: "This book belongs ____ my sister.", options: ["to","for","with","at"], correct: "to" },
    { prompt: "She arrived ____ time for the lesson.", options: ["on","in","at","to"], correct: "on" },
    { prompt: "We met ____ Monday morning.", options: ["on","in","at","by"], correct: "on" },
    { prompt: "He lives ____ Bavaria.", options: ["in","at","on","to"], correct: "in" },
    { prompt: "I’ll call you ____ the evening.", options: ["in","on","at","to"], correct: "in" },
    { prompt: "The cat is hiding ____ the bed.", options: ["under","over","between","through"], correct: "under" },
    { prompt: "The supermarket is ____ the bank.", options: ["next to","between","behind","across"], correct: "next to" },
    { prompt: "She walked ____ the street carefully.", options: ["across","through","over","along"], correct: "across" },
    { prompt: "We drove ____ the tunnel.", options: ["through","across","between","beside"], correct: "through" },
    { prompt: "I’ve lived here ____ 2019.", options: ["since","for","during","until"], correct: "since" },
    { prompt: "I’ve lived here ____ three years.", options: ["for","since","until","during"], correct: "for" },
    { prompt: "He has been ill ____ the weekend.", options: ["since","for","at","on"], correct: "since" },
    { prompt: "They talked ____ the test results.", options: ["about","of","for","with"], correct: "about" },
    { prompt: "He’s responsible ____ the project.", options: ["for","of","to","with"], correct: "for" },
    { prompt: "Don’t worry ____ it.", options: ["about","for","of","to"], correct: "about" },
    { prompt: "She is married ____ a doctor.", options: ["to","with","for","at"], correct: "to" },
    { prompt: "I’m looking ____ my phone.", options: ["for","at","to","with"], correct: "for" },
    { prompt: "He looked ____ the picture and smiled.", options: ["at","for","to","in"], correct: "at" },
    { prompt: "The train goes ____ Berlin at 7.", options: ["to","at","in","on"], correct: "to" },
    { prompt: "Please translate this ____ English.", options: ["into","to","in","at"], correct: "into" },
  ];

  // ----------------------------
  // INPUT (keyboard)
  // ----------------------------
  const keysDown = new Set();
  let jumpQueued = false;
  let restartQueued = false;

  function keyName(e) {
    if (e.code === "Space") return "space";
    if (e.key && e.key.startsWith("Arrow")) return e.key.toLowerCase();
    return (e.key || "").toLowerCase();
  }

  window.addEventListener("keydown", (e) => {
    ensureAudio();
    const k = keyName(e);
    if (k === "arrowleft" || k === "arrowright" || k === "arrowup" || k === "space") e.preventDefault();
    if (!keysDown.has(k)) {
      if (k === "arrowup" || k === "space") jumpQueued = true;
      if (k === "r") restartQueued = true;
    }
    keysDown.add(k);
  }, { passive: false });

  window.addEventListener("keyup", (e) => keysDown.delete(keyName(e)));
  canvas.addEventListener("pointerdown", () => ensureAudio());
  const isDown = (k) => keysDown.has(k);

  // ----------------------------
  // INPUT (buttons)
  // ----------------------------
  const touch = { left:false, right:false };
  const btnLeft  = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");
  const btnJump  = document.getElementById("btnJump");

  function setPressed(el, on){ if (el) el.classList.toggle("pressed", !!on); }

  function bindHold(el, onDown, onUp){
    el.addEventListener("pointerdown", (ev) => {
      ensureAudio();
      ev.preventDefault();
      try { el.setPointerCapture(ev.pointerId); } catch(_) {}
      onDown();
      setPressed(el, true);
    }, { passive:false });

    const up = (ev) => {
      if (ev && ev.preventDefault) ev.preventDefault();
      onUp();
      setPressed(el, false);
    };

    el.addEventListener("pointerup", up, { passive:false });
    el.addEventListener("pointercancel", up, { passive:false });
    el.addEventListener("lostpointercapture", up, { passive:true });
  }

  bindHold(btnLeft,  () => { touch.left = true;  }, () => { touch.left = false; });
  bindHold(btnRight, () => { touch.right = true; }, () => { touch.right = false; });

  btnJump.addEventListener("pointerdown", (ev) => {
    ensureAudio();
    ev.preventDefault();
    try { btnJump.setPointerCapture(ev.pointerId); } catch(_) {}
    jumpQueued = true;
    setPressed(btnJump, true);
  }, { passive:false });

  const clearJump = (ev) => {
    if (ev && ev.preventDefault) ev.preventDefault();
    setPressed(btnJump, false);
  };
  btnJump.addEventListener("pointerup", clearJump, { passive:false });
  btnJump.addEventListener("pointercancel", clearJump, { passive:false });
  btnJump.addEventListener("lostpointercapture", clearJump, { passive:true });

  const controlsBar = document.querySelector(".controls-bar");
  controlsBar.addEventListener("touchstart", (e) => e.preventDefault(), { passive:false });
  controlsBar.addEventListener("touchmove",  (e) => e.preventDefault(), { passive:false });

  // ----------------------------
  // WORLD / PLAYER
  // ----------------------------
  const WORLD = {
    gravity: 2200,
    friction: 0.85,
    moveAccel: 2800,
    maxSpeed: 420,
    jumpSpeed: 820,
    coyoteTime: 0.10,
    jumpBuffer: 0.10,
    maxAirJumps: 1,
  };

  const camera = { x: 0, y: 0 };

  function makePlayer() {
    return {
      x: 80, y: 200, w: CHAR_W, h: CHAR_H,
      vx: 0, vy: 0,
      onGround: false,
      coyote: 0,
      jumpBuf: 0,
      facing: 1,
      airJumpsLeft: WORLD.maxAirJumps,
    };
  }
  let player = makePlayer();

  // ----------------------------
  // SCORE / TIMER / LIVES
  // ----------------------------
  let score = 0;
  let lives = 3;
  const MAX_LIVES = 3;
  let gameOver = false;

  let runStartMs = performance.now();
  function elapsedSeconds() { return Math.max(0, (performance.now() - runStartMs) / 1000); }
  function fmtTime(sec) {
    const s = Math.floor(sec);
    const mm = String(Math.floor(s / 60)).padStart(2, "0");
    const ss = String(s % 60).padStart(2, "0");
    return `${mm}:${ss}`;
  }

  // ----------------------------
  // HELPERS
  // ----------------------------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const randi = (a, b) => Math.floor(rand(a, b + 1));
  const shuffle = (arr) => arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);

  function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  // ----------------------------
  // PLATFORMS
  // ----------------------------
  let platforms = [];

  const GEN = {
    groundX: -900,
    groundW: 5200,

    minCount: 13,
    maxCount: 26,

    w: PLATFORM_W,
    h: PLATFORM_H,

    gapMin: 110,
    gapMax: 170,

    stepUpMax: 105,
    stepDownMax: 140,

    yMin: 170,
    yMax: 350,
  };

  function reachableFromGround(platformY) {
    return platformY >= 320 && platformY <= GEN.yMax;
  }

  function generatePlatforms() {
    const list = [];
    const groundY = canvas.height - GROUND_H;      // ground always flush to bottom
    list.push({ x: GEN.groundX, y: groundY, w: GEN.groundW, h: GROUND_H });

    const count = randi(GEN.minCount, GEN.maxCount);

    let x = 280;
    let y0 = randi(320, 350);
    if (!reachableFromGround(y0)) y0 = 330;
    list.push({ x, y: y0, w: GEN.w, h: GEN.h });

    x += GEN.w + randi(GEN.gapMin, GEN.gapMax);
    let y1 = clamp(y0 + randi(-60, 80), GEN.yMin, GEN.yMax);
    list.push({ x, y: y1, w: GEN.w, h: GEN.h });

    for (let i = 2; i < count; i++) {
      const prev = list[list.length - 1];
      x += GEN.w + randi(GEN.gapMin, GEN.gapMax);

      let rawTarget = (Math.random() < 0.5) ? randi(190, 250) : randi(280, 350);
      rawTarget = clamp(rawTarget, GEN.yMin, GEN.yMax);

      let y = rawTarget;
      const dy = y - prev.y;
      if (dy < -GEN.stepUpMax) y = prev.y - GEN.stepUpMax;
      if (dy >  GEN.stepDownMax) y = prev.y + GEN.stepDownMax;

      y = clamp(y + randi(-14, 14), GEN.yMin, GEN.yMax);

      const dy2 = y - prev.y;
      if (dy2 < -GEN.stepUpMax) y = prev.y - GEN.stepUpMax;
      if (dy2 >  GEN.stepDownMax) y = prev.y + GEN.stepDownMax;

      list.push({ x, y, w: GEN.w, h: GEN.h });
    }

    platforms = list;
  }

  // ----------------------------
  // COLLISIONS
  // ----------------------------
  function resolveCollisions(p, dt) {
    p.x += p.vx * dt;
    for (const plat of platforms) {
      if (aabb(p.x, p.y, p.w, p.h, plat.x, plat.y, plat.w, plat.h)) {
        if (p.vx > 0) p.x = plat.x - p.w;
        else if (p.vx < 0) p.x = plat.x + plat.w;
        p.vx = 0;
      }
    }

    p.y += p.vy * dt;
    p.onGround = false;
    for (const plat of platforms) {
      if (aabb(p.x, p.y, p.w, p.h, plat.x, plat.y, plat.w, plat.h)) {
        if (p.vy > 0) {
          p.y = plat.y - p.h;
          p.vy = 0;
          p.onGround = true;
          p.coyote = WORLD.coyoteTime;
          p.airJumpsLeft = WORLD.maxAirJumps;
        } else if (p.vy < 0) {
          p.y = plat.y + plat.h;
          p.vy = 0;
        }
      }
    }
  }

  // ----------------------------
  // COLLECTIBLES / FLOW
  // ----------------------------
  let levelIndex = 0;
  let collectibles = [];
  let feedback = { text: "", timer: 0 };
  let transition = { active: false, t: 0, nextLevel: 0 };

  const BOX_W = 110;
  const BOX_H = 48;
  const AIR_OFFSET = 120;

  function pickSpawnPlatforms() {
    const floats = platforms.filter(p => p.h === GEN.h).sort((a,b)=>a.x-b.x);
    const usable = floats.slice(Math.min(2, floats.length));
    const base = (usable.length >= 4) ? usable : floats;

    if (!base.length) return [];
    const n = base.length;
    const q = (a,b) => base.slice(Math.floor(n*a), Math.max(Math.floor(n*a)+1, Math.floor(n*b)));
    const q1=q(0.00,0.25), q2=q(0.25,0.50), q3=q(0.50,0.75), q4=q(0.75,1.00);
    const pick = (bucket) => bucket[Math.floor(Math.random()*bucket.length)];

    if (n >= 4) return [pick(q1), pick(q2), pick(q3), pick(q4)];
    const out = [];
    for (let i=0;i<4;i++) out.push(base[i % n]);
    return out;
  }

  function buildCollectiblesForLevel(i) {
    const lvl = LEVELS[i];
    const opts = shuffle([...lvl.options]);
    const spawnPlats = pickSpawnPlatforms();

    collectibles = opts.map((label, idx) => {
      const p = spawnPlats[idx % spawnPlats.length];
      const x = p ? (p.x + Math.floor((p.w - BOX_W) / 2)) : (520 + idx*140);
      const y = p ? ((p.y - AIR_OFFSET) - BOX_H) : 220;
      return { x, y, w: BOX_W, h: BOX_H, label, isCorrect: label === lvl.correct, active: true };
    });
  }

  function setFeedback(text, seconds = 1.2) {
    feedback.text = text;
    feedback.timer = seconds;
  }

  function beginNextLevelDelay(nextIdx, seconds, message) {
    transition.active = true;
    transition.t = seconds;
    transition.nextLevel = nextIdx;
    setFeedback(message, seconds);
  }

  function finishGame() {
    collectibles = [];
    setFeedback("All done. Press R to restart.", 999);
  }

  function loseLife() {
    lives = Math.max(0, lives - 1);
    if (lives <= 0) {
      gameOver = true;
      setFeedback("Game over. Press R to restart.", 999);
    }
  }

  function onCorrectPick() {
    soundCorrect();
    triggerFlash("rgba(34,197,94,1)", 0.18);
    score += 100;
    if (levelIndex < LEVELS.length - 1) beginNextLevelDelay(levelIndex + 1, 1.1, "Correct (+100).");
    else { setFeedback("Correct (+100).", 1.2); setTimeout(() => finishGame(), 700); }
  }

  function onWrongPick() {
    soundWrong();
    triggerFlash("rgba(239,68,68,1)", 0.22);
    loseLife();
    if (!gameOver) setFeedback("Incorrect. Try again.", 1.4);
  }

  function handleCollectibleCollision() {
    for (const c of collectibles) {
      if (!c.active) continue;
      if (aabb(player.x, player.y, player.w, player.h, c.x, c.y, c.w, c.h)) {
        c.active = false;
        if (c.isCorrect) onCorrectPick();
        else onWrongPick();
        break;
      }
    }
  }

  // ----------------------------
  // DRAW HELPERS
  // ----------------------------
  function roundRect(x, y, w, h, r, fill) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if (fill) ctx.fill(); else ctx.stroke();
  }

  function drawWrappedText(text, x, y, maxWidth, lineHeight) {
    const words = String(text || "").split(/\s+/);
    let line = "";
    let yy = y;
    for (let n = 0; n < words.length; n++) {
      const test = line + words[n] + " ";
      const w = ctx.measureText(test).width;
      if (w > maxWidth && n > 0) {
        ctx.fillText(line.trimEnd(), x, yy);
        line = words[n] + " ";
        yy += lineHeight;
      } else {
        line = test;
      }
    }
    if (line) ctx.fillText(line.trimEnd(), x, yy);
  }

  // ----------------------------
  // DRAWING
  // ----------------------------
  function drawBackground() {
    const hillY = 420;
    const hillOffset = (camera.x * 0.25) % 800;

    ctx.save();
    ctx.translate(-hillOffset, 0);
    for (let i = -1; i < 6; i++) {
      const baseX = i * 800;
      ctx.beginPath();
      ctx.fillStyle = "rgba(45, 120, 90, 0.18)";
      ctx.ellipse(baseX + 260, hillY + 60, 340, 150, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = "rgba(45, 120, 90, 0.28)";
      ctx.ellipse(baseX + 540, hillY + 80, 380, 170, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    const cloudOffset = (camera.x * 0.45) % 700;
    ctx.save();
    ctx.translate(-cloudOffset, 0);
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    for (let i = -1; i < 6; i++) {
      const x = i * 700 + 140;
      const y = 90 + (i % 2) * 30;
      cloud(x, y, 1.0);
      cloud(x + 260, y + 40, 0.85);
    }
    ctx.restore();

    function cloud(x, y, s) {
      ctx.beginPath();
      ctx.ellipse(x, y, 52*s, 28*s, 0, 0, Math.PI*2);
      ctx.ellipse(x+40*s, y-10*s, 46*s, 26*s, 0, 0, Math.PI*2);
      ctx.ellipse(x+85*s, y, 56*s, 30*s, 0, 0, Math.PI*2);
      ctx.ellipse(x+45*s, y+15*s, 64*s, 30*s, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawPlatforms() {
    const root = getComputedStyle(document.documentElement);
    const ground = root.getPropertyValue("--ground").trim();
    const ground2 = root.getPropertyValue("--ground2").trim();

    for (const plat of platforms) {
      const sx = plat.x - camera.x;
      const sy = plat.y - camera.y;

      ctx.fillStyle = ground;
      ctx.fillRect(sx, sy, plat.w, plat.h);

      ctx.fillStyle = ground2;
      const stripe = Math.max(6, plat.h * 0.35);
      ctx.fillRect(sx, sy + stripe, plat.w, plat.h - stripe);

      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 2;
      ctx.strokeRect(sx + 1, sy + 1, plat.w - 2, plat.h - 2);
    }
  }

  function drawPlayer(p) {
    const x = p.x - camera.x;
    const y = p.y - camera.y;

    ctx.fillStyle = "rgba(30, 41, 59, 0.95)";
    roundRect(x, y, p.w, p.h, 8, true);

    ctx.fillStyle = "rgba(255,255,255,0.35)";
    const visorW = p.w * 0.55;
    const visorH = p.h * 0.22;
    const visorX = x + (p.facing === 1 ? p.w*0.30 : p.w*0.15);
    const visorY = y + p.h*0.20;
    roundRect(visorX, visorY, visorW, visorH, 6, true);

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(x + 5, y + p.h - 6, p.w - 10, 6);

    ctx.strokeStyle = "rgba(15,23,42,0.35)";
    ctx.lineWidth = 2;
    roundRect(x, y, p.w, p.h, 8, false);
  }

  function drawCollectibles() {
    for (const c of collectibles) {
      if (!c.active) continue;
      const x = c.x - camera.x;
      const y = c.y - camera.y;

      ctx.fillStyle = "rgba(255,255,255,0.92)";
      roundRect(x, y, c.w, c.h, 12, true);

      ctx.strokeStyle = "rgba(15,23,42,0.25)";
      ctx.lineWidth = 2;
      roundRect(x, y, c.w, c.h, 12, false);

      ctx.fillStyle = "rgba(15,23,42,0.92)";
      ctx.font = "700 17px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(c.label, x + c.w/2, y + c.h/2 + 1);
    }
  }

  function drawTopUI() {
    const pad = 14;
    const boxW = canvas.width - pad * 2;
    const boxH = 70;
    const x = pad;
    const y = pad;

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.88)";
    roundRect(x, y, boxW, boxH, 14, true);

    ctx.strokeStyle = "rgba(15,23,42,0.20)";
    ctx.lineWidth = 2;
    roundRect(x, y, boxW, boxH, 14, false);

    const finished = (levelIndex >= LEVELS.length - 1) && collectibles.length === 0 && feedback.timer > 100;

    ctx.fillStyle = "rgba(15,23,42,0.85)";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(finished ? "Finished" : `Level ${levelIndex + 1} / ${LEVELS.length}`, x + 16, y + 10);

    ctx.font = "600 18px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textBaseline = "bottom";
    ctx.fillText(finished ? "You completed all sentences." : LEVELS[levelIndex].prompt, x + 16, y + boxH - 12);

    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Score: ${score}   Time: ${fmtTime(elapsedSeconds())}`, x + boxW - 16, y + 10);

    const heartsFull = "♥".repeat(lives);
    const heartsEmpty = "♡".repeat(MAX_LIVES - lives);
    ctx.font = "700 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(15,23,42,0.85)";
    ctx.fillText(`${heartsFull}${heartsEmpty}`, x + boxW - 16, y + 30);

    ctx.font = "500 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(15,23,42,0.65)";
    ctx.textBaseline = "bottom";
    ctx.fillText("←/→ move  •  ↑/Space jump (double jump)  •  R restart", x + boxW - 16, y + boxH - 14);

    if (feedback.timer > 0 && feedback.text) {
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.font = "600 15px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillStyle = "rgba(15,23,42,0.88)";
      drawWrappedText(feedback.text, x + 16, y + boxH + 8, boxW - 32, 18);
    }

    ctx.restore();
  }

  // ----------------------------
  // GAME FLOW
  // ----------------------------
  function spawnRound(i, resetRun = false) {
    levelIndex = clamp(i, 0, LEVELS.length - 1);
    generatePlatforms();
    buildCollectiblesForLevel(levelIndex);
    player = makePlayer();
    camera.x = 0;
    camera.y = 0; // locked
    jumpQueued = false;
    restartQueued = false;
    transition.active = false;
    transition.t = 0;

    if (resetRun) {
      score = 0;
      lives = MAX_LIVES;
      gameOver = false;
      runStartMs = performance.now();
      feedback = { text: "", timer: 0 };
    }
  }

  // ----------------------------
  // UPDATE / RENDER LOOP
  // ----------------------------
  function update(dt) {
    if (restartQueued) { restartQueued = false; spawnRound(0, true); return; }

    if (flash.t > 0) flash.t = Math.max(0, flash.t - dt);

    if (feedback.timer > 0 && feedback.timer < 900) {
      feedback.timer = Math.max(0, feedback.timer - dt);
      if (feedback.timer === 0) feedback.text = "";
    }

    if (gameOver) return;

    if (transition.active) {
      transition.t = Math.max(0, transition.t - dt);
      if (transition.t === 0) {
        const next = transition.nextLevel;
        transition.active = false;
        spawnRound(next, false);
      }
      return;
    }

    const leftPressed  = isDown("arrowleft")  || touch.left;
    const rightPressed = isDown("arrowright") || touch.right;

    let ax = 0;
    if (leftPressed) ax -= WORLD.moveAccel;
    if (rightPressed) ax += WORLD.moveAccel;
    if (ax !== 0) player.facing = ax > 0 ? 1 : -1;

    player.vx += ax * dt;
    player.vx = clamp(player.vx, -WORLD.maxSpeed, WORLD.maxSpeed);

    if (ax === 0) {
      const fr = Math.pow(WORLD.friction, dt * 60);
      player.vx *= fr;
      if (Math.abs(player.vx) < 10) player.vx = 0;
    }

    player.coyote = Math.max(0, player.coyote - dt);
    player.jumpBuf = Math.max(0, player.jumpBuf - dt);

    if (jumpQueued) { player.jumpBuf = WORLD.jumpBuffer; jumpQueued = false; }

    player.vy += WORLD.gravity * dt;
    player.vy = clamp(player.vy, -2000, 2000);

    if (player.jumpBuf > 0) {
      const canGroundJump = player.onGround || player.coyote > 0;
      const canAirJump = !canGroundJump && player.airJumpsLeft > 0;
      if (canGroundJump || canAirJump) {
        player.vy = -WORLD.jumpSpeed;
        player.onGround = false;
        player.coyote = 0;
        player.jumpBuf = 0;
        if (canAirJump) player.airJumpsLeft -= 1;
      }
    }

    resolveCollisions(player, dt);
    if (collectibles.length) handleCollectibleCollision();

    if (player.y > 1200) { setFeedback("Fell. Respawning.", 0.9); spawnRound(levelIndex, false); }

    // Horizontal camera follow only (vertical locked)
    const targetX = player.x - canvas.width * 0.35;
    camera.x += (targetX - camera.x) * (1 - Math.pow(0.001, dt));
    camera.x = Math.max(-300, camera.x);
    camera.y = 0;
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();
    drawPlatforms();
    drawCollectibles();
    drawPlayer(player);
    drawTopUI();

    if (flash.t > 0) {
      const a = (flash.t / flash.dur) * 0.30;
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = flash.color;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
  }

  let lastTs = 0;
  function loop(ts) {
    const t = ts / 1000;
    const dt = Math.min(0.033, (t - lastTs) || 0);
    lastTs = t;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  spawnRound(0, true);
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
