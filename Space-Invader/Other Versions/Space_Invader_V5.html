<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Space Past Tense Invaders</title>
  <style>
    :root { font-family: system-ui, Arial, sans-serif; }

    *,*::before,*::after{ box-sizing:border-box; }

    html,body{
      height: 100%;
      height: calc(var(--vh, 1vh) * 100);
      min-height: 100vh;
      min-height: 100dvh;
    }

    body {
      margin: 0;
      display: grid;
      place-items: center;
      overflow: hidden;
      padding-top: calc(10px + env(safe-area-inset-top));
      padding-right: calc(10px + env(safe-area-inset-right));
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
      padding-left: calc(10px + env(safe-area-inset-left));
      color: #e8eefc;
      background:
        url('Space Invaders_Images/outside.png') center / cover no-repeat fixed,
        #050814;
    }

    .wrap {
      width: min(1040px, 100%);
      padding: 14px 14px 10px;
      border-radius: 14px;
      background: rgba(7, 10, 25, 0.55);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }

    canvas {
      width: 100%;
      height: auto;
      margin: 0 auto;
      border: 2px solid #2a3566;
      border-radius: 10px;
      display: block;
      background: transparent;
    }

    /* Responsive sizing: keep the whole game visible in landscape phones */
    .wrap {
      max-height: calc(var(--vh, 1vh) * 100);
      overflow: hidden;
    }

    canvas {
      /* JS will fine-tune width/height to fit the viewport; these are safe fallbacks */
      max-height: 70svh;
      touch-action: none;
    }

    @media (orientation: landscape) and (max-height: 520px) {
      .wrap { padding: 10px 10px 8px; }
      .hud { font-size: 12px; margin: 4px 2px 6px; }
      .question { font-size: 14px; margin: 6px 2px 8px; padding: 8px 10px; }
      .controls { margin: 8px 2px 4px; gap: 10px; }
      .controls button { font-size: 16px; padding: 10px 10px; }
      .hint { display: none; }
    }


    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 6px 2px 10px;
      font-size: 14px;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      background: #23306a;
      color: #e8eefc;
      border: 1px solid #2a3566;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
    }
    button:hover { filter: brightness(1.1); }

    .question {
      margin: 8px 2px 12px;
      padding: 10px 12px;
      background: rgba(11, 16, 38, 0.78);
      border: 1px solid rgba(42, 53, 102, 0.95);
      border-radius: 10px;
      color: #e8eefc;
      font-size: 16px;
      text-align: center;
      min-height: 22px;
    }

    .hint {
      opacity: 0.88;
      font-size: 13px;
      margin-top: 10px;
      line-height: 1.35;
    }
    .kbd {
      border: 1px solid #2a3566;
      border-bottom-width: 2px;
      padding: 0 6px;
      border-radius: 6px;
      background: rgba(11, 16, 38, 0.75);
    }

    .controls{
      display:flex;
      justify-content:space-between;
      gap:12px;
      margin: 12px 2px 6px;
      user-select:none;
      touch-action: manipulation;
    }
    .controls button{
      flex:1;
      font-size: 18px;
      padding: 14px 12px;
      border-radius: 12px;
    }
    #btnShoot{ flex: 1.2; font-weight: 700; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div><strong>Score:</strong> <span id="score">0</span> <span style="opacity:.9">|</span> <strong>High:</strong> <span id="highscore">0</span></div>
      <div><strong>Lives:</strong> <span id="lives">3</span></div>
      <div><strong>Time:</strong> <span id="timer">0:00.0</span></div>
      <div><strong>Question:</strong> <span id="qnum">1</span></div>
      <div style="display:flex; gap:8px; align-items:center;"><button id="restart" type="button">Restart</button><button id="mute" type="button">Mute</button></div>
    </div>

    <div id="question" class="question" aria-live="polite"></div>

    <canvas id="game" width="720" height="480" aria-label="Past Tense Game"></canvas>

    <div class="controls" aria-label="Touch controls">
      <button id="btnLeft" type="button" aria-label="Move left">◀</button>
      <button id="btnShoot" type="button" aria-label="Shoot">Shoot</button>
      <button id="btnRight" type="button" aria-label="Move right">▶</button>
    </div>

    <div class="hint">
      Controls: <span class="kbd">←</span>/<span class="kbd">→</span> move, <span class="kbd">Space</span> shoot.<br />
      Task: Shoot the <strong>correct simple past</strong> form.
    </div>
  </div>

  <script>
    'use strict';

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highscore');
    const livesEl = document.getElementById('lives');
    const timerEl = document.getElementById('timer');
    const qnumEl = document.getElementById('qnum');
    const questionEl = document.getElementById('question');
    const restartBtn = document.getElementById('restart');
    const muteBtn = document.getElementById('mute');

    // Fit the canvas into the available viewport height (important on landscape phones).
    // Uses a JS-driven --vh and visualViewport (when available) to handle iOS/Android browser chrome.
    const wrapEl = document.querySelector('.wrap');
    const hudEl = document.querySelector('.hud');
    const controlsEl = document.querySelector('.controls');
    const hintEl = document.querySelector('.hint');

    const W = canvas.width;
    const H = canvas.height;

    function setVhVar(){
      const vv = window.visualViewport;
      const vh = (vv ? vv.height : window.innerHeight) * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }

    function getViewportSize(){
      const vv = window.visualViewport;
      if (vv) return { w: vv.width, h: vv.height };
      return { w: window.innerWidth, h: window.innerHeight };
    }

    let fitRaf = 0;
    function fitCanvasToViewport() {
      if (!wrapEl) return;

      const vp = getViewportSize();

      // Width: wrap content width (exclude padding)
      const ws = getComputedStyle(wrapEl);
      const padX = (parseFloat(ws.paddingLeft) || 0) + (parseFloat(ws.paddingRight) || 0);
      const availableW = Math.max(160, wrapEl.clientWidth - padX);

      // Height: viewport height minus UI elements and wrap padding
      const hintVisible = hintEl && window.getComputedStyle(hintEl).display !== 'none';
      const uiH = (hudEl?.offsetHeight || 0)
        + (questionEl?.offsetHeight || 0)
        + (controlsEl?.offsetHeight || 0)
        + (hintVisible ? (hintEl.offsetHeight || 0) : 0);

      const padY = (parseFloat(ws.paddingTop) || 0) + (parseFloat(ws.paddingBottom) || 0);
      const buffer = 18;
      const availableH = Math.max(160, vp.h - uiH - padY - buffer);

      // Keep the original game aspect ratio (720x480 = 3:2).
      const scale = Math.min(availableW / W, availableH / H);
      const cssW = Math.max(1, Math.floor(W * scale));
      const cssH = Math.max(1, Math.floor(H * scale));

      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.style.margin = '0 auto';
    }

    function scheduleFitCanvas() {
      if (fitRaf) cancelAnimationFrame(fitRaf);
      fitRaf = requestAnimationFrame(() => {
        fitRaf = 0;
        setVhVar();
        fitCanvasToViewport();
      });
    }

    // Initial sizing and resize/orientation handling
    setVhVar();
    scheduleFitCanvas();
    window.addEventListener('resize', scheduleFitCanvas, { passive: true });
    window.addEventListener('orientationchange', () => setTimeout(scheduleFitCanvas, 120), { passive: true });
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', scheduleFitCanvas, { passive: true });
      window.visualViewport.addEventListener('scroll', scheduleFitCanvas, { passive: true });
    }

    const IMG_DIR = 'Space Invaders_Images/';
    const bgImg = new Image(); bgImg.src = IMG_DIR + 'ingame.jpg';
    const shipImg = new Image(); shipImg.src = IMG_DIR + 'ship.png';
    const missileImg = new Image(); missileImg.src = IMG_DIR + 'Missile.png';
    const alienImg = new Image(); alienImg.src = IMG_DIR + 'Alien.png';
    const explosionImg = new Image(); explosionImg.src = IMG_DIR + 'Explosion.png';

    const PLAYER = { w: 60, h: 60, speed: 6 };
    const BULLET = { w: 14, h: 30, speed: 9, cooldownMs: 250 };

    // Verb list (unchanged)
    const VERBS = [
      {"base":"be","past":"was","pastForms":["was","were"],"pp":"been","ppForms":["been"]},
      {"base":"become","past":"became","pastForms":["became"],"pp":"become","ppForms":["become"]},
      {"base":"begin","past":"began","pastForms":["began"],"pp":"begun","ppForms":["begun"]},
      {"base":"bet","past":"bet","pastForms":["bet"],"pp":"bet","ppForms":["bet"]},
      {"base":"bite","past":"bit","pastForms":["bit"],"pp":"bitten","ppForms":["bitten"]},
      {"base":"blow","past":"blew","pastForms":["blew"],"pp":"blown","ppForms":["blown"]},
      {"base":"break","past":"broke","pastForms":["broke"],"pp":"broken","ppForms":["broken"]},
      {"base":"bring","past":"brought","pastForms":["brought"],"pp":"brought","ppForms":["brought"]},
      {"base":"build","past":"built","pastForms":["built"],"pp":"built","ppForms":["built"]},
      {"base":"burn","past":"burnt","pastForms":["burnt","burned"],"pp":"burnt","ppForms":["burnt","burned"]},
      {"base":"burst","past":"burst","pastForms":["burst"],"pp":"burst","ppForms":["burst"]},
      {"base":"buy","past":"bought","pastForms":["bought"],"pp":"bought","ppForms":["bought"]},
      {"base":"catch","past":"caught","pastForms":["caught"],"pp":"caught","ppForms":["caught"]},
      {"base":"choose","past":"chose","pastForms":["chose"],"pp":"chosen","ppForms":["chosen"]},
      {"base":"come","past":"came","pastForms":["came"],"pp":"come","ppForms":["come"]},
      {"base":"cost","past":"cost","pastForms":["cost"],"pp":"cost","ppForms":["cost"]},
      {"base":"creep","past":"crept","pastForms":["crept"],"pp":"crept","ppForms":["crept"]},
      {"base":"cut","past":"cut","pastForms":["cut"],"pp":"cut","ppForms":["cut"]},
      {"base":"deal","past":"dealt","pastForms":["dealt"],"pp":"dealt","ppForms":["dealt"]},
      {"base":"dig","past":"dug","pastForms":["dug"],"pp":"dug","ppForms":["dug"]},
      {"base":"do","past":"did","pastForms":["did"],"pp":"done","ppForms":["done"]},
      {"base":"draw","past":"drew","pastForms":["drew"],"pp":"drawn","ppForms":["drawn"]},
      {"base":"dream","past":"dreamt","pastForms":["dreamt","dreamed"],"pp":"dreamt","ppForms":["dreamt","dreamed"]},
      {"base":"drink","past":"drank","pastForms":["drank"],"pp":"drunk","ppForms":["drunk"]},
      {"base":"drive","past":"drove","pastForms":["drove"],"pp":"driven","ppForms":["driven"]},
      {"base":"eat","past":"ate","pastForms":["ate"],"pp":"eaten","ppForms":["eaten"]},
      {"base":"fall","past":"fell","pastForms":["fell"],"pp":"fallen","ppForms":["fallen"]},
      {"base":"feed","past":"fed","pastForms":["fed"],"pp":"fed","ppForms":["fed"]},
      {"base":"feel","past":"felt","pastForms":["felt"],"pp":"felt","ppForms":["felt"]},
      {"base":"fight","past":"fought","pastForms":["fought"],"pp":"fought","ppForms":["fought"]},
      {"base":"find","past":"found","pastForms":["found"],"pp":"found","ppForms":["found"]},
      {"base":"fit","past":"fit","pastForms":["fit","fitted"],"pp":"fit","ppForms":["fit","fitted"]},
      {"base":"fly","past":"flew","pastForms":["flew"],"pp":"flown","ppForms":["flown"]},
      {"base":"forget","past":"forgot","pastForms":["forgot"],"pp":"forgotten","ppForms":["forgotten"]},
      {"base":"forgive","past":"forgave","pastForms":["forgave"],"pp":"forgiven","ppForms":["forgiven"]},
      {"base":"freeze","past":"froze","pastForms":["froze"],"pp":"frozen","ppForms":["frozen"]},
      {"base":"get","past":"got","pastForms":["got"],"pp":"got","ppForms":["got","gotten"]},
      {"base":"give","past":"gave","pastForms":["gave"],"pp":"given","ppForms":["given"]},
      {"base":"go","past":"went","pastForms":["went"],"pp":"gone","ppForms":["gone"]},
      {"base":"grow","past":"grew","pastForms":["grew"],"pp":"grown","ppForms":["grown"]},
      {"base":"hang","past":"hung","pastForms":["hung"],"pp":"hung","ppForms":["hung"]},
      {"base":"have","past":"had","pastForms":["had"],"pp":"had","ppForms":["had"]},
      {"base":"hear","past":"heard","pastForms":["heard"],"pp":"heard","ppForms":["heard"]},
      {"base":"hide","past":"hid","pastForms":["hid"],"pp":"hidden","ppForms":["hidden"]},
      {"base":"hit","past":"hit","pastForms":["hit"],"pp":"hit","ppForms":["hit"]},
      {"base":"hold","past":"held","pastForms":["held"],"pp":"held","ppForms":["held"]},
      {"base":"hurt","past":"hurt","pastForms":["hurt"],"pp":"hurt","ppForms":["hurt"]},
      {"base":"keep","past":"kept","pastForms":["kept"],"pp":"kept","ppForms":["kept"]},
      {"base":"know","past":"knew","pastForms":["knew"],"pp":"known","ppForms":["known"]},
      {"base":"lay","past":"laid","pastForms":["laid"],"pp":"laid","ppForms":["laid"]},
      {"base":"lead","past":"led","pastForms":["led"],"pp":"led","ppForms":["led"]},
      {"base":"learn","past":"learnt","pastForms":["learnt","learned"],"pp":"learnt","ppForms":["learnt","learned"]},
      {"base":"leave","past":"left","pastForms":["left"],"pp":"left","ppForms":["left"]},
      {"base":"lend","past":"lent","pastForms":["lent"],"pp":"lent","ppForms":["lent"]},
      {"base":"let","past":"let","pastForms":["let"],"pp":"let","ppForms":["let"]},
      {"base":"lie","past":"lay","pastForms":["lay"],"pp":"lain","ppForms":["lain"]},
      {"base":"lose","past":"lost","pastForms":["lost"],"pp":"lost","ppForms":["lost"]},
      {"base":"make","past":"made","pastForms":["made"],"pp":"made","ppForms":["made"]},
      {"base":"mean","past":"meant","pastForms":["meant"],"pp":"meant","ppForms":["meant"]},
      {"base":"meet","past":"met","pastForms":["met"],"pp":"met","ppForms":["met"]},
      {"base":"pay","past":"paid","pastForms":["paid"],"pp":"paid","ppForms":["paid"]},
      {"base":"put","past":"put","pastForms":["put"],"pp":"put","ppForms":["put"]},
      {"base":"read","past":"read","pastForms":["read"],"pp":"read","ppForms":["read"]},
      {"base":"ride","past":"rode","pastForms":["rode"],"pp":"ridden","ppForms":["ridden"]},
      {"base":"ring","past":"rang","pastForms":["rang"],"pp":"rung","ppForms":["rung"]},
      {"base":"rise","past":"rose","pastForms":["rose"],"pp":"risen","ppForms":["risen"]},
      {"base":"run","past":"ran","pastForms":["ran"],"pp":"run","ppForms":["run"]},
      {"base":"say","past":"said","pastForms":["said"],"pp":"said","ppForms":["said"]},
      {"base":"see","past":"saw","pastForms":["saw"],"pp":"seen","ppForms":["seen"]},
      {"base":"sell","past":"sold","pastForms":["sold"],"pp":"sold","ppForms":["sold"]},
      {"base":"send","past":"sent","pastForms":["sent"],"pp":"sent","ppForms":["sent"]},
      {"base":"set","past":"set","pastForms":["set"],"pp":"set","ppForms":["set"]},
      {"base":"sew","past":"sewed","pastForms":["sewed"],"pp":"sewn","ppForms":["sewn","sewed"]},
      {"base":"shake","past":"shook","pastForms":["shook"],"pp":"shaken","ppForms":["shaken"]},
      {"base":"shine","past":"shone","pastForms":["shone"],"pp":"shone","ppForms":["shone"]},
      {"base":"shoot","past":"shot","pastForms":["shot"],"pp":"shot","ppForms":["shot"]},
      {"base":"show","past":"showed","pastForms":["showed"],"pp":"shown","ppForms":["shown","showed"]},
      {"base":"sing","past":"sang","pastForms":["sang"],"pp":"sung","ppForms":["sung"]},
      {"base":"sink","past":"sank","pastForms":["sank"],"pp":"sunk","ppForms":["sunk"]},
      {"base":"sit","past":"sat","pastForms":["sat"],"pp":"sat","ppForms":["sat"]},
      {"base":"sleep","past":"slept","pastForms":["slept"],"pp":"slept","ppForms":["slept"]},
      {"base":"slide","past":"slid","pastForms":["slid"],"pp":"slid","ppForms":["slid"]},
      {"base":"smell","past":"smelt","pastForms":["smelt","smelled"],"pp":"smelt","ppForms":["smelt","smelled"]},
      {"base":"speak","past":"spoke","pastForms":["spoke"],"pp":"spoken","ppForms":["spoken"]},
      {"base":"spell","past":"spelt","pastForms":["spelt","spelled"],"pp":"spelt","ppForms":["spelt","spelled"]},
      {"base":"spend","past":"spent","pastForms":["spent"],"pp":"spent","ppForms":["spent"]},
      {"base":"spit","past":"spat","pastForms":["spat"],"pp":"spat","ppForms":["spat"]},
      {"base":"stand","past":"stood","pastForms":["stood"],"pp":"stood","ppForms":["stood"]},
      {"base":"steal","past":"stole","pastForms":["stole"],"pp":"stolen","ppForms":["stolen"]},
      {"base":"sting","past":"stung","pastForms":["stung"],"pp":"stung","ppForms":["stung"]},
      {"base":"swim","past":"swam","pastForms":["swam"],"pp":"swum","ppForms":["swum"]},
      {"base":"take","past":"took","pastForms":["took"],"pp":"taken","ppForms":["taken"]},
      {"base":"teach","past":"taught","pastForms":["taught"],"pp":"taught","ppForms":["taught"]},
      {"base":"tell","past":"told","pastForms":["told"],"pp":"told","ppForms":["told"]},
      {"base":"think","past":"thought","pastForms":["thought"],"pp":"thought","ppForms":["thought"]},
      {"base":"throw","past":"threw","pastForms":["threw"],"pp":"thrown","ppForms":["thrown"]},
      {"base":"understand","past":"understood","pastForms":["understood"],"pp":"understood","ppForms":["understood"]},
      {"base":"wake","past":"woke","pastForms":["woke"],"pp":"woken","ppForms":["woken"]},
      {"base":"wear","past":"wore","pastForms":["wore"],"pp":"worn","ppForms":["worn"]},
      {"base":"win","past":"won","pastForms":["won"],"pp":"won","ppForms":["won"]},
      {"base":"write","past":"wrote","pastForms":["wrote"],"pp":"written","ppForms":["written"]}
    ];

    // Alien (answer) hitbox size. Slightly taller to avoid image distortion.
    const BOX = { w: 170, h: 56, gapX: 18 };
    const BOX_MOVE = { stepX: 16, stepY: 18, intervalMs: 520 };
    const TOTAL_QUESTIONS = VERBS.length;

    let keys = new Set();
    let player, bullets, boxes, boxDir, boxLastMoveAt;
    let score, lives, highScore;
    let lastShotAt = 0;
    let running = true;

    let startTimeMs = 0;
    let endTimeMs = 0;
    let finished = false;

    let bag = [];
    let qNum = 0;
    let current = null;

    let correctAnswer = '';

    let feedbackText = '';
    let feedbackUntil = 0;

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function safeLower(s) { return String(s || '').trim().toLowerCase(); }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y &&
        a.alive !== false &&
        b.alive !== false
      );
    }

    function showFeedback(text, ms = 800) {
      feedbackText = text;
      feedbackUntil = performance.now() + ms;
    }

    function shuffle(arr) {
      const a = Array.from(arr);
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function formatTime(ms) {
      const total = Math.max(0, ms);
      const minutes = Math.floor(total / 60000);
      const seconds = Math.floor((total % 60000) / 1000);
      const tenths = Math.floor((total % 1000) / 100);
      return `${minutes}:${String(seconds).padStart(2,'0')}.${tenths}`;
    }

    function updateTimer(now) {
      const t = (running ? (now - startTimeMs) : (endTimeMs - startTimeMs));
      timerEl.textContent = formatTime(t);
    }

    function drawCover(img) {
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      if (!iw || !ih) return;

      const scale = Math.max(W / iw, H / ih);
      const dw = iw * scale;
      const dh = ih * scale;
      const dx = (W - dw) / 2;
      const dy = (H - dh) / 2;
      ctx.drawImage(img, dx, dy, dw, dh);
    }

    // Regularised "-ed" with common learner-relevant spelling rules (no vowel swap):
    // - e -> +d
    // - consonant+y -> -y + ied
    // - short CVC -> double final consonant + ed (fit->fitted, stop->stopped)
    // else +ed
    function regularEdSmart(base) {
      const b = String(base || '').trim();
      if (!b) return 'ed';
      if (b.endsWith('e')) return b + 'd';
      if (/[^aeiou]y$/i.test(b)) return b.slice(0, -1) + 'ied';
      if (/[^aeiou][aeiou][^aeiou]$/i.test(b) && b.length <= 4 && !/[wxy]$/i.test(b)) {
        return b + b.slice(-1) + 'ed';
      }
      return b + 'ed';
    }

    function simpleEd(base) {
      const b = String(base || '').trim();
      if (!b) return 'ed';
      return b.endsWith('e') ? (b + 'd') : (b + 'ed');
    }

    // OPTIONS RULE (your rule) with duplicate handling for invariant verbs:
    // Base 3: [past], [regular -ed], [pp]
    // If pp duplicates => try alternate forms from ppForms/pastForms.
    // If still duplicates => use simple +ed (if different from the regularised form).
    // Final fallback => base + "en".
    function makeOptionsForVerb(v) {
      const base = String(v.base || '').trim();
      let canonical = String(v.past || '').trim();
      const pp = String(v.pp || '').trim();

      // Keep "be" unambiguous as "was"
      if (safeLower(base) === 'be') canonical = 'was';

      const edMain = regularEdSmart(base);
      const edSimple = simpleEd(base);

      const options = [];
      const used = new Set();

      function add(s) {
        const t = String(s || '').trim();
        if (!t) return false;
        const k = safeLower(t);
        if (used.has(k)) return false;
        used.add(k);
        options.push(t);
        return true;
      }

      add(canonical); // correct
      add(edMain);    // -ed form

      // Try pp as 3rd
      let thirdOk = add(pp);

      // If pp duplicated, try alternates (still meaningful, still "pp/past family")
      if (!thirdOk) {
        const ppForms = Array.isArray(v.ppForms) ? v.ppForms : [];
        const pastForms = Array.isArray(v.pastForms) ? v.pastForms : [];

        // Prefer alternate pp forms first (e.g., fit -> fitted)
        for (const f of ppForms) {
          if (add(f)) { thirdOk = true; break; }
        }

        // Then alternate past forms (if any distinct)
        if (!thirdOk) {
          for (const f of pastForms) {
            if (add(f)) { thirdOk = true; break; }
          }
        }

        // Then a simple "base+ed" variant if it differs from the main -ed (e.g., fitted vs fited)
        if (!thirdOk && safeLower(edSimple) !== safeLower(edMain)) {
          if (add(edSimple)) thirdOk = true;
        }

        // Final fallback (rare): base + "en"
        if (!thirdOk) {
          add(base + 'en');
        }
      }

      // Safety: if something extremely unusual happens, force 3 items
      while (options.length < 3) options.push(options[0]);

      return { canonical, options: shuffle(options) };
    }

    function updateHud() {
      scoreEl.textContent = String(score);

      if (typeof highScore !== 'number') {
        highScore = Number(sessionStorage.getItem('sp_inv_high') || 0);
      }
      if (score > highScore) {
        highScore = score;
        sessionStorage.setItem('sp_inv_high', String(highScore));
      }
      if (highScoreEl) highScoreEl.textContent = String(highScore);

      livesEl.textContent = String(lives);
      qnumEl.textContent = `${qNum}/${TOTAL_QUESTIONS}`;
    }

    function setQuestionText() {
      if (safeLower(current.base) === 'be') {
        questionEl.textContent = `Which is the correct simple past form of “be” (I/he/she/it)?`;
      } else {
        questionEl.textContent = `Which is the correct simple past form of “${current.base}”?`;
      }
    }

    function buildBoxes(options) {
      boxes = [];
      const totalW = options.length * BOX.w + (options.length - 1) * BOX.gapX;
      const startX = (W - totalW) / 2;
      const startY = 70;

      for (let i = 0; i < options.length; i++) {
        boxes.push({
          x: startX + i * (BOX.w + BOX.gapX),
          y: startY,
          w: BOX.w,
          h: BOX.h,
          text: options[i],
          alive: true
        });
      }

      boxDir = 1;
      boxLastMoveAt = performance.now();
    }

    function boxesBounds() {
      let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const bx of boxes) {
        if (!bx.alive) continue;
        minX = Math.min(minX, bx.x);
        maxX = Math.max(maxX, bx.x + bx.w);
        maxY = Math.max(maxY, bx.y + bx.h);
      }
      return { minX, maxX, maxY };
    }

    function refillBag() { bag = shuffle(VERBS); }

    function nextQuestion() {
      if (!bag.length) refillBag();
      current = bag.pop();
      qNum += 1;

      const built = makeOptionsForVerb(current);
      correctAnswer = built.canonical;

      buildBoxes(built.options);
      bullets.length = 0;

      setQuestionText();
      updateHud();
      scheduleFitCanvas();
    }

    function restartQuestionSameVerb() {
      const built = makeOptionsForVerb(current);
      correctAnswer = built.canonical;

      buildBoxes(built.options);
      bullets.length = 0;

      setQuestionText();
      updateHud();
      scheduleFitCanvas();
    }

    function resetGame() {
      if (typeof highScore !== 'number') {
        highScore = Number(sessionStorage.getItem('sp_inv_high') || 0);
      }
      if (highScoreEl) highScoreEl.textContent = String(highScore);
      if (muteBtn && muteBtn.textContent !== 'Mute' && muteBtn.textContent !== 'Unmute') {
        // no-op
      }
      setMuted(muted);

      score = 0;
      lives = 3;
      qNum = 0;
      running = true;
      finished = false;
      startTimeMs = performance.now();
      endTimeMs = startTimeMs;

      player = {
        x: (W - PLAYER.w) / 2,
        y: H - PLAYER.h - 14,
        w: PLAYER.w,
        h: PLAYER.h
      };

      bullets = [];
      refillBag();
      nextQuestion();

      feedbackText = '';
      feedbackUntil = 0;

      scheduleFitCanvas();
    }

    // Input
    window.addEventListener('keydown', (e) => {
      if (['ArrowLeft', 'ArrowRight', ' '].includes(e.key)) e.preventDefault();
      keys.add(e.key);
    }, { passive: false });

    window.addEventListener('keyup', (e) => keys.delete(e.key));
    restartBtn.addEventListener('click', resetGame);

    if (muteBtn) {
      muteBtn.addEventListener('click', () => {
        // Creating/resuming audio context must happen in a user gesture
        ensureAudio();
        resumeAudioIfNeeded();
        setMuted(!muted);
      });
      setMuted(false);
    }

    // Touch controls
    let moveDir = 0;
    const btnLeft = document.getElementById('btnLeft');
    const btnRight = document.getElementById('btnRight');
    const btnShoot = document.getElementById('btnShoot');

    function bindHoldButton(btn, dir) {
      const down = (e) => { e.preventDefault(); moveDir = dir; };
      const up = (e) => { e.preventDefault(); if (moveDir === dir) moveDir = 0; };

      btn.addEventListener('pointerdown', down, { passive: false });
      btn.addEventListener('pointerup', up, { passive: false });
      btn.addEventListener('pointercancel', up, { passive: false });
      btn.addEventListener('pointerleave', up, { passive: false });

      btn.addEventListener('touchstart', down, { passive: false });
      btn.addEventListener('touchend', up, { passive: false });
      btn.addEventListener('touchcancel', up, { passive: false });

      btn.addEventListener('mousedown', down);
      btn.addEventListener('mouseup', up);
      btn.addEventListener('mouseleave', up);
    }

    bindHoldButton(btnLeft, -1);
    bindHoldButton(btnRight, +1);

    if (btnShoot) {
      const shootNow = (e) => { e.preventDefault(); tryShoot(performance.now()); };
      btnShoot.addEventListener('pointerdown', shootNow, { passive: false });
      btnShoot.addEventListener('touchstart', shootNow, { passive: false });
      btnShoot.addEventListener('mousedown', shootNow);
    }

    canvas.style.touchAction = 'none';

    // Audio (procedural explosion) + mute
    var muted = false;
    var audioCtx = null;
    var masterGain = null;

    function ensureAudio() {
      if (audioCtx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return;
      audioCtx = new Ctx();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 1;
      masterGain.connect(audioCtx.destination);
    }

    function resumeAudioIfNeeded() {
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});
    }

    function setMuted(v) {
      muted = !!v;
      if (masterGain) masterGain.gain.value = muted ? 0 : 1;
      if (muteBtn) muteBtn.textContent = muted ? 'Unmute' : 'Mute';
    }

    function playExplosionSound() {
      if (muted) return;
      ensureAudio();
      if (!audioCtx || !masterGain) return;
      resumeAudioIfNeeded();

      const t0 = audioCtx.currentTime;
      const dur = 0.38;

      // A deeper, more "explosive" sound: sub-thump + mid body + filtered noise burst.
      // Keep it lightweight and fully procedural (no external audio files).

      // Gentle dynamics control
      const comp = audioCtx.createDynamicsCompressor();
      comp.threshold.setValueAtTime(-22, t0);
      comp.knee.setValueAtTime(18, t0);
      comp.ratio.setValueAtTime(6, t0);
      comp.attack.setValueAtTime(0.003, t0);
      comp.release.setValueAtTime(0.18, t0);
      comp.connect(masterGain);

      // Noise burst (air/impact)
      const bufferSize = Math.floor(audioCtx.sampleRate * dur);
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        const x = i / bufferSize;
        // fast decay + slight emphasis at the start
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - x, 2.6);
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;

      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.setValueAtTime(700, t0);
      lp.frequency.exponentialRampToValueAtTime(140, t0 + dur);

      const hp = audioCtx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.setValueAtTime(60, t0);

      const nGain = audioCtx.createGain();
      nGain.gain.setValueAtTime(0.70, t0);
      nGain.gain.exponentialRampToValueAtTime(0.001, t0 + dur);

      noise.connect(lp);
      lp.connect(hp);
      hp.connect(nGain);
      nGain.connect(comp);

      // Sub thump
      const sub = audioCtx.createOscillator();
      sub.type = 'sine';
      sub.frequency.setValueAtTime(95, t0);
      sub.frequency.exponentialRampToValueAtTime(34, t0 + dur);

      const subGain = audioCtx.createGain();
      subGain.gain.setValueAtTime(0.95, t0);
      subGain.gain.exponentialRampToValueAtTime(0.001, t0 + dur);

      sub.connect(subGain);
      subGain.connect(comp);

      // Mid body (adds "crack" without being sharp)
      const body = audioCtx.createOscillator();
      body.type = 'triangle';
      body.frequency.setValueAtTime(160, t0);
      body.frequency.exponentialRampToValueAtTime(58, t0 + dur);

      const bodyGain = audioCtx.createGain();
      bodyGain.gain.setValueAtTime(0.40, t0);
      bodyGain.gain.exponentialRampToValueAtTime(0.001, t0 + dur);

      body.connect(bodyGain);
      bodyGain.connect(comp);

      noise.start(t0);
      sub.start(t0);
      body.start(t0);

      noise.stop(t0 + dur);
      sub.stop(t0 + dur);
      body.stop(t0 + dur);
    }

    // Explosions (visual)
    const EXPLOSION = { durationMs: 360 };
    let explosions = [];

    // baseSize is typically derived from the hit alien's size so the explosion replaces the alien visually.
    function spawnExplosion(x, y, baseSize) {
      const base = Number(baseSize) || 70;
      explosions.push({ x, y, base, start: performance.now() });
      playExplosionSound();
    }

    // Mechanics
    function tryShoot(now) {
      ensureAudio();
      resumeAudioIfNeeded();

      if (now - lastShotAt < BULLET.cooldownMs) return;

      bullets.push({
        x: player.x + player.w / 2 - BULLET.w / 2,
        y: player.y - BULLET.h,
        w: BULLET.w,
        h: BULLET.h,
        alive: true
      });

      lastShotAt = now;
    }

    function movePlayer() {
      const left = keys.has('ArrowLeft') || moveDir === -1;
      const right = keys.has('ArrowRight') || moveDir === 1;
      if (left) player.x -= PLAYER.speed;
      if (right) player.x += PLAYER.speed;
      player.x = clamp(player.x, 8, W - player.w - 8);
    }

    function moveBullets() {
      for (const b of bullets) b.y -= BULLET.speed;
      bullets = bullets.filter(b => b.y + b.h > 0 && !b._dead);
    }

    function moveBoxes(now) {
      if (now - boxLastMoveAt < BOX_MOVE.intervalMs) return;
      boxLastMoveAt = now;

      const { minX, maxX } = boxesBounds();
      if (!isFinite(minX) || !isFinite(maxX)) return;

      const hitRight = maxX + BOX_MOVE.stepX >= W - 10;
      const hitLeft = minX - BOX_MOVE.stepX <= 10;

      if ((boxDir === 1 && hitRight) || (boxDir === -1 && hitLeft)) {
        for (const bx of boxes) bx.y += BOX_MOVE.stepY;
        boxDir *= -1;
      } else {
        for (const bx of boxes) bx.x += BOX_MOVE.stepX * boxDir;
      }
    }

    function loseLife(reasonText) {
      lives -= 1;
      updateHud();

      if (lives <= 0) {
        running = false;
        finished = false;
        endTimeMs = performance.now();
        return;
      }

      showFeedback(reasonText, 900);
      restartQuestionSameVerb();
    }

    function handleCollisions() {
      for (const b of bullets) {
        if (b._dead) continue;

        for (const bx of boxes) {
          if (!bx.alive) continue;

          if (rectsOverlap(b, bx)) {
            b._dead = true;

            // Replace the hit alien with an explosion (not the missile).
            bx.alive = false;
            spawnExplosion(bx.x + bx.w / 2, bx.y + bx.h / 2, Math.max(bx.w, bx.h));

            const hitText = safeLower(bx.text);
            const isCorrect = hitText === safeLower(correctAnswer);

            if (isCorrect) {
              score += 10;
              updateHud();
              showFeedback('Correct!', 700);

              if (qNum >= TOTAL_QUESTIONS) {
                running = false;
                finished = true;
                endTimeMs = performance.now();
              } else {
                nextQuestion();
              }
            } else {
              loseLife('Wrong! -1 life');
            }
            break;
          }
        }
      }

      const { maxY } = boxesBounds();
      if (running && isFinite(maxY) && maxY >= player.y) {
        loseLife('Too late! -1 life');
      }
    }

    // Rendering
    function drawBackground() {
      ctx.clearRect(0, 0, W, H);

      if (bgImg.complete && bgImg.naturalWidth) {
        drawCover(bgImg);
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(0, 0, W, H);
      } else {
        ctx.fillStyle = '#060914';
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 0.55;
        ctx.fillStyle = '#9bb3ff';
        for (let i = 0; i < 70; i++) {
          const x = (i * 97) % W;
          const y = (i * 53) % H;
          ctx.fillRect(x, y, 2, 2);
        }
        ctx.globalAlpha = 1;
      }
    }

    function drawPlayer() {
      const x = player.x;
      const y = player.y;

      if (shipImg.complete && shipImg.naturalWidth) {
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(shipImg, x, y, player.w, player.h);
        ctx.restore();
      } else {
        ctx.fillStyle = '#e8eefc';
        ctx.fillRect(x, y + player.h*0.65, player.w, player.h*0.35);
        ctx.fillRect(x + player.w/2 - 6, y + player.h*0.35, 12, player.h*0.30);
      }
    }

    function drawBullets() {
      for (const b of bullets) {
        if (missileImg.complete && missileImg.naturalWidth) {
          ctx.save();
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(missileImg, b.x, b.y, b.w, b.h);
          ctx.restore();
        } else {
          ctx.fillStyle = '#ffd66b';
          ctx.fillRect(b.x, b.y, b.w, b.h);
        }
      }
    }

    function drawExplosions(now) {
      if (!explosions.length) return;

      const alive = [];
      for (const ex of explosions) {
        const p = (now - ex.start) / EXPLOSION.durationMs;
        if (p >= 1) continue;
        alive.push(ex);

        const scale = 0.35 + p * 1.25;
        const alpha = 1 - p;
        const s = ex.base * scale;

        if (explosionImg.complete && explosionImg.naturalWidth) {
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(explosionImg, ex.x - s / 2, ex.y - s / 2, s, s);
          ctx.restore();
        } else {
          // Fallback: simple expanding ring
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = '#ffd66b';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(ex.x, ex.y, s / 2, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
      }
      explosions = alive;
    }

    function drawBoxes() {
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Bold, white verbs for better readability on the alien background.
      ctx.font = 'bold 18px system-ui, Arial';

      for (const bx of boxes) {
        if (!bx.alive) continue;

        if (alienImg.complete && alienImg.naturalWidth) {
          ctx.save();
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(alienImg, bx.x, bx.y, bx.w, bx.h);
          ctx.restore();
        } else {
          ctx.fillStyle = '#7ee081';
          ctx.fillRect(bx.x, bx.y, bx.w, bx.h);

          ctx.strokeStyle = '#e8eefc';
          ctx.lineWidth = 2;
          ctx.strokeRect(bx.x, bx.y, bx.w, bx.h);
        }

        // Text readability: outline + fill
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#060914';
        ctx.strokeText(bx.text, bx.x + bx.w / 2, bx.y + bx.h / 2);
        ctx.fillStyle = '#ffffff';
        ctx.fillText(bx.text, bx.x + bx.w / 2, bx.y + bx.h / 2);
      }
    }

    function drawFeedback(now) {
      if (!feedbackText || now > feedbackUntil) return;

      ctx.fillStyle = 'rgba(0,0,0,0.60)';
      ctx.fillRect(0, H - 70, W, 70);

      ctx.fillStyle = '#e8eefc';
      ctx.font = '18px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(feedbackText, W / 2, H - 35);
    }

    function drawOverlay() {
      ctx.fillStyle = 'rgba(0,0,0,0.62)';
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = '#e8eefc';
      ctx.font = '28px system-ui, Arial';
      ctx.textAlign = 'center';

      const title = finished ? 'Finished!' : 'Game Over';
      ctx.fillText(title, W / 2, H / 2 - 28);

      ctx.font = '18px system-ui, Arial';
      const t = formatTime(endTimeMs - startTimeMs);
      ctx.fillText(`Time: ${t}`, W / 2, H / 2 + 6);

      ctx.font = '16px system-ui, Arial';
      ctx.fillText('Press Restart to play again', W / 2, H / 2 + 34);
    }

    function loop(now) {
      updateTimer(now);

      if (running) {
        movePlayer();
        if (keys.has(' ')) tryShoot(now);
        moveBullets();
        moveBoxes(now);
        handleCollisions();
      }

      drawBackground();
      drawBoxes();
      drawExplosions(now);
      drawPlayer();
      drawBullets();
      drawFeedback(now);

      if (!running) drawOverlay();

      requestAnimationFrame(loop);
    }

    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
