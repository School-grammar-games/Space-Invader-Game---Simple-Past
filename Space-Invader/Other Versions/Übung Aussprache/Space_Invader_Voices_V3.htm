<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Word Boxes Shooter (Listening Pronunciation)</title>
  <style>
    :root { font-family: system-ui, Arial, sans-serif; }
    body { margin: 0; display: grid; place-items: center; min-height: 100vh; background: #0b1020; color: #e8eefc; }
    .wrap { width: min(720px, 95vw); }
    canvas { width: 100%; height: auto; background: #060914; border: 2px solid #2a3566; border-radius: 10px; display: block; }
    .hud { display: flex; justify-content: space-between; align-items: center; margin: 10px 2px 12px; font-size: 14px; gap: 10px; flex-wrap: wrap; }
    .hint { opacity: 0.85; font-size: 13px; margin-top: 10px; line-height: 1.35; }
    button {
      background: #23306a; color: #e8eefc; border: 1px solid #2a3566; padding: 8px 12px; border-radius: 8px;
      cursor: pointer;
    }
    button:hover { filter: brightness(1.1); }

    .prompt {
      margin-top: 10px;
      padding: 10px 12px;
      background: #0b1026;
      border: 1px solid #2a3566;
      border-radius: 10px;
      color: #e8eefc;
      font-size: 14px;
      min-height: 22px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div><strong>Score:</strong> <span id="score">0</span></div>
      <div><strong>Lives:</strong> <span id="lives">3</span></div>
      <div><strong>Set:</strong> <span id="set">1</span>/25</div>

      <div>
        <label><strong>Mode:</strong>
          <select id="mode">
            <option value="audio_prompt">Audio prompt (shoot what you hear)</option>
            <option value="mismatch_audio">Wrong pronunciation (shoot the mispronounced word)</option>
          </select>
        </label>
      </div>

      <div><button id="playPrompt" type="button">Hear prompt</button></div>

      <div>
        <label>
          <input id="showText" type="checkbox" />
          Show target word in audio mode
        </label>
      </div>

      <div><button id="restart">Restart</button></div>
    </div>

    <canvas id="game" width="720" height="480" aria-label="Word Boxes Game"></canvas>

    <div id="prompt" class="prompt" aria-live="polite"></div>

    <div class="hint">
      Controls: <strong>←</strong>/<strong>→</strong> move, <strong>Space</strong> shoot, <strong>H</strong> replay audio.<br />
      Use <strong>Mode</strong> to switch between (1) Audio prompt (shoot what you hear) and (2) Wrong pronunciation (one word is pronounced incorrectly).
      You can also click a box to hear its individual audio.
    </div>
  </div>

  <script>
    'use strict';

    // ----------------------------
    // Canvas setup
    // ----------------------------
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const setEl = document.getElementById('set');
    const restartBtn = document.getElementById('restart');
    const modeSel = document.getElementById('mode');
    const playPromptBtn = document.getElementById('playPrompt');
    const showTextChk = document.getElementById('showText');
    const promptEl = document.getElementById('prompt');

    // ----------------------------
    // Game constants
    // ----------------------------
    const W = canvas.width;
    const H = canvas.height;

    const PLAYER = { w: 44, h: 14, speed: 5 };
    const BULLET = { w: 4, h: 10, speed: 7, cooldownMs: 250 };

    // 25 sets of 5 A2-friendly words (mixed vocabulary; the target is identified by pronunciation).
    const WORD_SETS = [["clothes", "garden", "window", "swim", "happy"], ["chocolate", "teacher", "river", "quiet", "write"], ["because", "notebook", "market", "listen", "tired"], ["wednesday", "sister", "station", "always", "clean"], ["answer", "father", "museum", "early", "dance"], ["restaurant", "mother", "hotel", "never", "draw"], ["people", "cousin", "airport", "often", "sing"], ["vegetable", "doctor", "cinema", "sometimes", "run"], ["usually", "nurse", "library", "quickly", "read"], ["camera", "farmer", "office", "slowly", "sleep"], ["comfortable", "driver", "bridge", "careful", "play"], ["computer", "student", "lake", "danger", "laugh"], ["mountain", "friend", "ticket", "strong", "climb"], ["island", "neighbour", "beach", "bright", "watch"], ["money", "police", "forest", "dark", "walk"], ["weather", "artist", "city", "warm", "talk"], ["favourite", "engineer", "street", "cold", "help"], ["breakfast", "baker", "kitchen", "hungry", "cook"], ["beautiful", "waiter", "bedroom", "thirsty", "drink"], ["different", "pilot", "bathroom", "angry", "open"], ["question", "shop", "corner", "afraid", "close"], ["practice", "school", "village", "ready", "start"], ["biscuit", "park", "passport", "late", "finish"], ["holiday", "phone", "music", "game", "computer"], ["guitar", "piano", "drum", "song", "dance"]];

    // Teacher key (target word) for each set in the same order as WORD_SETS:
    const ANSWERS = ["clothes", "chocolate", "because", "wednesday", "answer", "restaurant", "people", "vegetable", "usually", "camera", "comfortable", "computer", "mountain", "island", "money", "weather", "favourite", "breakfast", "beautiful", "different", "question", "practice", "biscuit", "holiday", "guitar"];

    const BOX = { w: 112, h: 34, gapX: 14 };
    const BOX_MOVE = { stepX: 16, stepY: 18, intervalMs: 520 };

    // ----------------------------
    // State
    // ----------------------------
    let keys = new Set();

    let player, bullets, boxes, boxDir, boxLastMoveAt;
    let score, lives, setIndex;
    let lastShotAt = 0;
    let running = true;

    // Learning modes
    const MODES = {
      AUDIO_PROMPT: 'audio_prompt',
      MISMATCH_AUDIO: 'mismatch_audio'
    };
    let mode = MODES.AUDIO_PROMPT;
    let audioUnlocked = false;
    let speechOk = ('speechSynthesis' in window) && ('SpeechSynthesisUtterance' in window);
    let speechVoice = null;

    // message feedback (brief)
    let feedbackText = '';
    let feedbackUntil = 0;

    // ----------------------------
    // Helpers
    // ----------------------------
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function showFeedback(text, ms = 700) {
      feedbackText = text;
      feedbackUntil = performance.now() + ms;
    }

    // ----------------------------
    // Speech (TTS) helpers
    // ----------------------------
    function initVoices() {
      if (!speechOk) return;
      const voices = window.speechSynthesis.getVoices() || [];
      // Prefer an English voice (GB/US), otherwise fall back to the first available.
      speechVoice =
        voices.find(v => /^en(-|_)?GB/i.test(v.lang)) ||
        voices.find(v => /^en(-|_)?US/i.test(v.lang)) ||
        voices.find(v => /^en/i.test(v.lang)) ||
        voices[0] ||
        null;
    }

    if (speechOk) {
      initVoices();
      window.speechSynthesis.onvoiceschanged = () => initVoices();
    }

    function unlockAudio() {
      audioUnlocked = true;
      // Some browsers require a user gesture before speech output.
    }

    function speakText(text, opts = {}) {
      if (!speechOk) {
        showFeedback('Text-to-speech not available in this browser', 1200);
        return;
      }
      if (!audioUnlocked) {
        showFeedback('Click “Hear prompt” once to enable audio', 1200);
        return;
      }
      // Ensure voices are initialized (some browsers load voices lazily)
      initVoices();
      const t = String(text || '').trim();
      if (!t) return;

      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(t);
      if (speechVoice) u.voice = speechVoice;
      u.lang = (speechVoice && speechVoice.lang) ? speechVoice.lang : 'en-US';
      u.rate = opts.rate ?? 1.0;
      u.pitch = opts.pitch ?? 1.0;
      u.volume = opts.volume ?? 1.0;
      window.speechSynthesis.speak(u);
    }

    function speakSequence(texts) {
      if (!speechOk) {
        showFeedback('Text-to-speech not available in this browser', 1200);
        return;
      }
      if (!audioUnlocked) {
        showFeedback('Click “Hear prompt” once to enable audio', 1200);
        return;
      }
      initVoices();

      const list = (texts || []).map(t => String(t || '').trim()).filter(Boolean);
      if (!list.length) return;

      // Robust sequential playback: cancel any prior queue and chain via onend.
      window.speechSynthesis.cancel();

      // Bump a run id so stale onend handlers cannot continue an old queue.
      speakSequence._runId = (speakSequence._runId || 0) + 1;
      const runId = speakSequence._runId;

      let i = 0;
      const speakNext = () => {
        if (runId !== speakSequence._runId) return; // superseded
        if (i >= list.length) return;

        const u = new SpeechSynthesisUtterance(list[i]);
        if (speechVoice) u.voice = speechVoice;
        u.lang = (speechVoice && speechVoice.lang) ? speechVoice.lang : 'en-US';
        u.rate = 1.0;
        u.pitch = 1.0;
        u.volume = 1.0;

        u.onend = () => {
          i += 1;
          // Slight delay helps Safari/Chrome avoid skipping the last item.
          setTimeout(speakNext, 60);
        };
        u.onerror = () => {
          i += 1;
          setTimeout(speakNext, 60);
        };

        window.speechSynthesis.speak(u);
      };

      speakNext();
    }

    function updateHud() {
      scoreEl.textContent = String(score);
      livesEl.textContent = String(lives);
      setEl.textContent = String(setIndex + 1);
      updatePrompt();
    }

    function updatePrompt() {
      if (!promptEl) return;

      const correctWord = ANSWERS[setIndex] || '';
      const noTts = !speechOk;

      if (mode === MODES.AUDIO_PROMPT) {
        const show = !!(showTextChk && showTextChk.checked);
        if (noTts) {
          promptEl.textContent = 'Audio mode selected, but text-to-speech is not available in this browser.';
          return;
        }
        promptEl.textContent = show
          ? `Listen and shoot: ${correctWord}  (press H to replay)`
          : 'Listen and shoot the word you hear (press H to replay).';
        return;
      }

      if (mode === MODES.MISMATCH_AUDIO) {
        if (noTts) {
          promptEl.textContent = 'Mismatch-audio mode selected, but text-to-speech is not available in this browser.';
          return;
        }
        promptEl.textContent = 'One box will be pronounced incorrectly (phonics spelling). Shoot the mispronounced one (press H to replay all).';
        return;
      }
    }

    function configureSetForMode() {
      const targetWord = (ANSWERS[setIndex] || '').toLowerCase();

      // Default: audioText matches the displayed text
      for (const bx of boxes) {
        bx.audioText = bx.text;
        bx.isMismatch = false;
      }

      if (mode === MODES.MISMATCH_AUDIO) {
        // The target is the box whose word is pronounced incorrectly (but it is still the SAME word).
        const target = boxes.find(b => String(b.text).toLowerCase() === targetWord) || boxes[0];
        if (target) {
          target.audioText = mispronounce(String(target.text));
          target.isMismatch = true;
        }
      }
    }

    // Create a deliberately "wrong" pronunciation using phonics-like spellings.
// Note: Web Speech TTS does not consistently support SSML <phoneme> across browsers, so we use robust text approximations.
const MISPRONUNCIATIONS = {
  "clothes": "clo,thes",
  "chocolate": "cho,co,late",
  "because": "be,cause",
  "wednesday": "wet,nes,day",
  "answer": "ans,wer",
  "restaurant": "res,tau,rant",
  "people": "pee,pole",
  "vegetable": "veg,e,ta,ble",
  "usually": "you,su,al,ly",
  "camera": "cam,er,ah",
  "comfortable": "com,for,ta,ble",
  "computer": "kom,pyoo,ter",
  "mountain": "mown,tayn",
  "island": "is,land",
  "money": "mo,ney",
  "weather": "wee,ther",
  "favourite": "fav,or,ite",
  "breakfast": "break,fast",
  "beautiful": "byoo,ti,ful",
  "different": "dif,fer,ent",
  "question": "kwe,stion",
  "practice": "prak,tice",
  "biscuit": "bis,kwee",
  "holiday": "ho,li,day",
  "guitar": "goo,ih,tar"
};

    function mispronounce(word) {
      const w = String(word || '').trim().toLowerCase();
      if (!w) return w;

      // Preferred: specific phonics-like misspellings (most reliable / most distinct).
      if (MISPRONUNCIATIONS[w]) return MISPRONUNCIATIONS[w];

      // Fallback (rare): chunk into vowel-groups (not letters) to avoid "spelling out".
      // Example: "pencil" -> "pen,cil" (still different rhythm than normal)
      const chunks = [];
      let cur = '';
      const vowels = new Set(['a','e','i','o','u','y']);
      for (let i = 0; i < w.length; i++) {
        const ch = w[i];
        const prev = i > 0 ? w[i-1] : '';
        const isV = vowels.has(ch);
        const wasV = vowels.has(prev);

        // Start a new chunk at consonant->vowel boundaries when the current chunk is already long enough.
        if (cur && isV && !wasV && cur.length >= 2) {
          chunks.push(cur);
          cur = ch;
        } else {
          cur += ch;
        }

        // Push chunk near the end
        if (i === w.length - 1 && cur) chunks.push(cur);
      }

      // If the heuristic failed, just return the word (better than spelling).
      if (chunks.length < 2) return w;

      return chunks.join(',');
    }

    function playSetAudio() {
      const correctWord = ANSWERS[setIndex] || '';

      if (mode === MODES.AUDIO_PROMPT) {
        window.speechSynthesis && window.speechSynthesis.cancel();
        speakText(correctWord);
        return;
      }

      if (mode === MODES.MISMATCH_AUDIO) {
        // Play each box's audio once, left to right.
        speakSequence(boxes.map(b => b.audioText));
        return;
      }
    }

    function startSet() {
      bullets.length = 0;
      buildBoxesForSet(WORD_SETS[setIndex]);
      configureSetForMode();
      updateHud();
      if (audioUnlocked) playSetAudio();
    }

    function boxesBounds() {
      let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const bx of boxes) {
        if (!bx.alive) continue;
        minX = Math.min(minX, bx.x);
        maxX = Math.max(maxX, bx.x + bx.w);
        maxY = Math.max(maxY, bx.y + bx.h);
      }
      return { minX, maxX, maxY };
    }

    function buildBoxesForSet(words) {
      boxes = [];

      // Shuffle words so the target/mispronounced item is not always in the same position.
      const shuffled = Array.from(words);
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }

      const totalW = shuffled.length * BOX.w + (shuffled.length - 1) * BOX.gapX;
      const startX = (W - totalW) / 2;
      const startY = 80;

      for (let i = 0; i < shuffled.length; i++) {
        boxes.push({
          x: startX + i * (BOX.w + BOX.gapX),
          y: startY,
          w: BOX.w,
          h: BOX.h,
          text: shuffled[i],
          audioText: shuffled[i],
          isMismatch: false,
          alive: true
        });
      }

      boxDir = 1;
      boxLastMoveAt = performance.now();
    }

    function restartCurrentSet() {
      startSet();
    }

    function nextSet() {
      setIndex += 1;
      if (setIndex >= WORD_SETS.length) {
        running = false; // completed all sets => win
        return;
      }
      startSet();
    }

    // ----------------------------
    // Game setup
    // ----------------------------
    function resetGame() {
      score = 0;
      lives = 3;
      setIndex = 0;
      running = true;

      // Initialize selected mode
      if (modeSel && modeSel.value) mode = modeSel.value;

      player = {
        x: (W - PLAYER.w) / 2,
        y: H - 40,
        w: PLAYER.w,
        h: PLAYER.h
      };

      bullets = [];
      startSet();

      feedbackText = '';
      feedbackUntil = 0;
    }

    // ----------------------------
    // Input
    // ----------------------------
    window.addEventListener('keydown', (e) => {
      if (['ArrowLeft', 'ArrowRight', ' ', 'h', 'H'].includes(e.key)) e.preventDefault();
      keys.add(e.key);

      // Any key interaction can be treated as an "audio unlock" gesture
      if (e.key === 'h' || e.key === 'H') {
        unlockAudio();
        playSetAudio();
      }
    });

    window.addEventListener('keyup', (e) => {
      keys.delete(e.key);
    });

    restartBtn.addEventListener('click', resetGame);

    if (modeSel) {
      modeSel.addEventListener('change', () => {
        mode = modeSel.value;
        // Restart current set in the new mode (keeps the same set number)
        startSet();
      });
    }

    if (showTextChk) {
      showTextChk.addEventListener('change', () => updatePrompt());
    }

    if (playPromptBtn) {
      playPromptBtn.addEventListener('click', () => {
        unlockAudio();
        playSetAudio();
      });
    }

    // Click a box to hear its individual audio (practice / confirmation)
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const hit = boxes.find(bx => bx.alive && mx >= bx.x && mx <= bx.x + bx.w && my >= bx.y && my <= bx.y + bx.h);
      if (hit) {
        unlockAudio();
        speakText(hit.audioText);
      }
    });

    // ----------------------------
    // Game mechanics
    // ----------------------------
    function tryShoot(now) {
      if (now - lastShotAt < BULLET.cooldownMs) return;

      bullets.push({
        x: player.x + player.w / 2 - BULLET.w / 2,
        y: player.y - BULLET.h,
        w: BULLET.w,
        h: BULLET.h
      });

      lastShotAt = now;
    }

    function movePlayer() {
      if (keys.has('ArrowLeft')) player.x -= PLAYER.speed;
      if (keys.has('ArrowRight')) player.x += PLAYER.speed;
      player.x = clamp(player.x, 8, W - player.w - 8);
    }

    function moveBullets() {
      for (const b of bullets) b.y -= BULLET.speed;
      bullets = bullets.filter(b => b.y + b.h > 0 && !b._dead);
    }

    function moveBoxes(now) {
      if (now - boxLastMoveAt < BOX_MOVE.intervalMs) return;

      boxLastMoveAt = now;

      const { minX, maxX } = boxesBounds();
      if (!isFinite(minX) || !isFinite(maxX)) return;

      const hitRight = maxX + BOX_MOVE.stepX >= W - 10;
      const hitLeft = minX - BOX_MOVE.stepX <= 10;

      if ((boxDir === 1 && hitRight) || (boxDir === -1 && hitLeft)) {
        for (const bx of boxes) bx.y += BOX_MOVE.stepY;
        boxDir *= -1;
      } else {
        for (const bx of boxes) bx.x += BOX_MOVE.stepX * boxDir;
      }
    }

    function loseLife(reasonText) {
      lives -= 1;
      updateHud();

      if (lives <= 0) {
        running = false;
        return;
      }

      showFeedback(reasonText, 900);
      restartCurrentSet();
    }

    function handleCollisions() {
      const correctWord = ANSWERS[setIndex];

      // Bullet vs boxes
      for (const b of bullets) {
        if (b._dead) continue;

        for (const bx of boxes) {
          if (!bx.alive) continue;

          if (rectsOverlap(b, bx)) {
            b._dead = true;

            let isCorrect = false;
            if (mode === MODES.MISMATCH_AUDIO) {
              isCorrect = !!bx.isMismatch;
            } else {
              isCorrect = (String(bx.text).toLowerCase() === String(correctWord).toLowerCase());
            }

            if (isCorrect) {
              score += 10;
              updateHud();
              showFeedback('Correct!', 700);
              nextSet();
            } else {
              loseLife('Wrong word! -1 life');
            }
            break;
          }
        }
      }

      // If boxes reach player line => lose a life (optional pressure mechanic)
      const { maxY } = boxesBounds();
      if (running && isFinite(maxY) && maxY >= player.y) {
        loseLife('Too late! -1 life');
      }
    }

    // ----------------------------
    // Rendering
    // ----------------------------
    function drawBackground() {
      ctx.clearRect(0, 0, W, H);

      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#9bb3ff';
      for (let i = 0; i < 70; i++) {
        const x = (i * 97) % W;
        const y = (i * 53) % H;
        ctx.fillRect(x, y, 2, 2);
      }
      ctx.globalAlpha = 1;
    }

    function drawPlayer() {
      ctx.fillStyle = '#e8eefc';
      ctx.fillRect(player.x, player.y, player.w, player.h);
      ctx.fillRect(player.x + player.w / 2 - 4, player.y - 8, 8, 8);
    }

    function drawBullets() {
      ctx.fillStyle = '#ffd66b';
      for (const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);
    }

    function drawBoxes() {
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '16px system-ui, Arial';

      for (const bx of boxes) {
        if (!bx.alive) continue;

        ctx.fillStyle = '#7ee081';
        ctx.fillRect(bx.x, bx.y, bx.w, bx.h);

        ctx.strokeStyle = '#e8eefc';
        ctx.lineWidth = 2;
        ctx.strokeRect(bx.x, bx.y, bx.w, bx.h);

        ctx.fillStyle = '#060914';
        ctx.fillText(bx.text, bx.x + bx.w / 2, bx.y + bx.h / 2);
      }
    }

    function drawFeedback(now) {
      if (!feedbackText || now > feedbackUntil) return;

      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0, H - 70, W, 70);

      ctx.fillStyle = '#e8eefc';
      ctx.font = '18px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(feedbackText, W / 2, H - 35);
    }

    function drawOverlay() {
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = '#e8eefc';
      ctx.font = '28px system-ui, Arial';
      ctx.textAlign = 'center';

      const won = lives > 0 && setIndex >= WORD_SETS.length;
      ctx.fillText(won ? 'You Win!' : 'Game Over', W / 2, H / 2 - 10);

      ctx.font = '16px system-ui, Arial';
      ctx.fillText('Press Restart to play again', W / 2, H / 2 + 22);
    }

    // ----------------------------
    // Main loop
    // ----------------------------
    function loop(now) {
      if (running) {
        movePlayer();
        if (keys.has(' ')) tryShoot(now);
        moveBullets();
        moveBoxes(now);
        handleCollisions();
      }

      drawBackground();
      drawBoxes();
      drawPlayer();
      drawBullets();
      drawFeedback(now);

      if (!running) drawOverlay();

      requestAnimationFrame(loop);
    }

    // Start
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
