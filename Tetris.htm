<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Sentence Order Drop (shuffled only, tall field)</title>
  <style>

    :root{ color-scheme: dark; --bg0:#05060a; --bg1:#070b14; --panel:#0b1020; --panel2:#0a0f1a; --stroke:rgba(255,255,255,.10); --stroke2:rgba(255,255,255,.14); --text:#eaf1ff; --muted:rgba(234,241,255,.78); }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      display:flex;
      justify-content:center;
      align-items:stretch;
      min-height:100vh;
      padding:12px;
      box-sizing:border-box;
      background: transparent;
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position:fixed;
      inset:-20%;
      pointer-events:none;
      background:
        conic-gradient(from 180deg at 50% 50%, rgba(255,64,129,.12), rgba(0,212,255,.10), rgba(0,255,153,.10), rgba(255,64,129,.12));
      filter: blur(60px);
      opacity:.55;
      animation: drift 14s linear infinite;
      transform: translate3d(0,0,0);
      mix-blend-mode: screen;
    }
    body::after{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background: repeating-linear-gradient(180deg, rgba(255,255,255,.035) 0px, rgba(255,255,255,.035) 1px, transparent 3px, transparent 6px);
      opacity:.35;
      mix-blend-mode: overlay;
    }
    @keyframes drift{ from{ transform: translate3d(-2%, -1%, 0) rotate(0deg);} to{ transform: translate3d(2%, 1%, 0) rotate(360deg);} }

    .wrap{ width:min(900px,100%); display:flex; flex-direction:column; gap:10px; height: calc(100vh - 24px); max-height: calc(100vh - 24px); }
    .topbar{ display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .stats{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .pill{
      background: linear-gradient(180deg, rgba(17,26,46,.80), rgba(10,14,28,.78));
      border:1px solid var(--stroke);
      border-radius:999px;
      padding:7px 12px;
      font-size:14px;
      line-height:1;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 26px rgba(0,0,0,.32);
    }

    .stage{
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      background: linear-gradient(180deg, rgba(10,14,28,.65), rgba(6,8,16,.55));
      overflow:hidden;
      box-shadow:
        0 20px 60px rgba(0,0,0,.55),
        0 0 0 1px rgba(255,255,255,.03) inset;
      position:relative;
    
      flex: 1 1 auto;
      min-height: 240px;
    }
    .stage::before{
      content:"";
      position:absolute;
      inset:-2px;
      pointer-events:none;
      border-radius:18px;
      background: radial-gradient(600px 260px at 50% 0%, rgba(255,255,255,.10), transparent 60%);
      opacity:.8;
      mix-blend-mode: overlay;
    }
    canvas{ width:100%; height:100%; display:block; touch-action:none; position:relative; z-index:1; }

    .panel{
      display:grid;
      gap:8px;
      padding:12px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(14,20,40,.72), rgba(10,14,28,.62));
      border-radius:16px;
      backdrop-filter: blur(10px);
      box-shadow: 0 14px 40px rgba(0,0,0,.40);
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .label{ opacity:.92; font-size:13px; color:var(--muted); }
    .chips{ display:flex; gap:8px; flex-wrap:wrap; }

    .chip{
      border:1px solid var(--stroke2);
      background: linear-gradient(180deg, rgba(18,26,48,.78), rgba(9,12,24,.72));
      border-radius:999px;
      padding:5px 12px;
      font-size:13px;
      white-space:nowrap;
      box-shadow: 0 10px 22px rgba(0,0,0,.28);
    }

    .controls{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; user-select:none; -webkit-user-select:none; margin-top:auto; }

    /* Touch controls (scaled down ~30% to make more room for gameplay) */
    .controls button{
      padding:11px 10px;
      font-size:14px;
      min-height:42px;
      touch-action: manipulation;
    }
    .controls #leftBtn, .controls #rightBtn, .controls #softBtn{
      font-size:20px;
      font-weight:800;
    }
    @media (max-width: 600px), (pointer:coarse){
      .controls{ gap:10px; }
      .controls button{
        min-height:50px;
        font-size:15px;
        padding:14px 12px;
      }
      .controls #leftBtn, .controls #rightBtn, .controls #softBtn{
        font-size:24px;
      }
    }

    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(18,26,48,.86), rgba(9,12,24,.78));
      color:var(--text);
      border-radius:16px;
      padding:12px 10px;
      font-size:16px;
      font-weight:650;
      letter-spacing:.2px;
      box-shadow:
        0 14px 34px rgba(0,0,0,.45),
        0 0 0 1px rgba(255,255,255,.04) inset;
      position:relative;
      overflow:hidden;
    }
    button::before{
      content:"";
      position:absolute;
      inset:-30% -40%;
      background: radial-gradient(260px 120px at 30% 30%, rgba(0,212,255,.22), transparent 55%),
                  radial-gradient(260px 120px at 70% 70%, rgba(255,64,129,.18), transparent 55%);
      opacity:.9;
      filter: blur(10px);
      transform: translate3d(0,0,0);
      mix-blend-mode: screen;
    }
    button span, button{ isolation:isolate; }
    button:active{ transform:translateY(1px); }
    .diffBar{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .diffBtn{
      padding:10px 12px;
      font-size:14px;
      border-radius:18px;
      font-weight:700;
    }
    .diffBtn.active{
      border-color: rgba(34,211,238,.48);
      box-shadow:
        0 14px 34px rgba(0,0,0,.45),
        0 0 0 2px rgba(34,211,238,.18) inset,
        0 0 26px rgba(34,211,238,.18);
    }
    .wide{ grid-column: span 3; }
    .danger{ border-color: rgba(255,64,129,.28); }

    .hint{ font-size:12px; opacity:.86; line-height:1.35; color:var(--muted); }

    .prepHint{
      position:absolute;
      left:50%;
      top:14px;
      transform:translateX(-50%);
      z-index:5;
      max-width: calc(100% - 28px);
      padding:10px 14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background: linear-gradient(180deg, rgba(34,211,238,.18), rgba(124,58,237,.14));
      box-shadow:
        0 14px 38px rgba(0,0,0,.45),
        0 0 26px rgba(34,211,238,.18);
      color:#eaf1ff;
      font-weight:700;
      text-align:center;
      letter-spacing:.2px;
      backdrop-filter: blur(10px);
    }
    .hidden{ display:none !important; }


    /* Compact top UI on smartphones: reduce vertical space */
    @media (max-width: 520px), (max-height: 760px) and (pointer:coarse){
      body{ padding:8px; }
      .wrap{ gap:8px; height: calc(100vh - 16px); max-height: calc(100vh - 16px); }

      .topbar{
        display:grid;
        grid-template-columns: 1fr auto;
        grid-template-areas:
          "stats actions"
          "diff diff";
        gap:8px;
        align-items:center;
      }
      .topbar > .stats:first-child{ grid-area:stats; }
      .topbar > .stats:last-child{ grid-area:actions; justify-content:flex-end; }
      .topbar > .diffBar{ grid-area:diff; }

      .pill{ padding:6px 10px; font-size:13px; }

      .diffBar{
        flex-wrap:nowrap;
        overflow-x:auto;
        -webkit-overflow-scrolling:touch;
        scrollbar-width:none;
        padding-bottom:2px;
      }
      .diffBar::-webkit-scrollbar{ display:none; }
      .diffBtn{ padding:8px 10px; font-size:13px; border-radius:16px; white-space:nowrap; flex:0 0 auto; }

      .topbar > .stats:last-child button{
        padding:10px 10px;
        font-size:14px;
        border-radius:14px;
      }

      .panel{ padding:10px; }
      .hint{ font-size:11.5px; }
    }


    /* === Background video (looping) === */
    .bgVideo{
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      object-fit:cover;
      z-index:-6;
      pointer-events:none;
      opacity:0.38;
      filter:saturate(1.15) contrast(1.05);
    }
    .bgOverlay{
      position:fixed;
      inset:0;
      z-index:-5;
      pointer-events:none;
      background:
        radial-gradient(1200px 600px at 20% 20%, rgba(121,40,202,.22), transparent 55%),
        radial-gradient(900px 600px at 80% 30%, rgba(0,212,255,.18), transparent 60%),
        radial-gradient(900px 800px at 60% 85%, rgba(0,255,153,.10), transparent 60%),
        linear-gradient(180deg, rgba(5,6,10,.72), rgba(7,11,20,.72));
      mix-blend-mode: normal;
    }


    /* === Start + rotate overlays === */
    .overlay{
      position:fixed;
      inset:0;
      z-index:9999;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      background: rgba(5,6,10,.78);
      backdrop-filter: blur(10px);
    }
    .overlayCard{
      width: min(720px, 100%);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(14,20,40,.86), rgba(10,14,28,.78));
      box-shadow: 0 24px 80px rgba(0,0,0,.65);
      padding:16px 16px 14px;
    }
    .overlayTitle{
      margin:0 0 8px;
      font-size:22px;
      letter-spacing:.2px;
    }
    .overlayText{
      margin:0 0 12px;
      color: var(--muted);
      line-height:1.35;
      font-size:14px;
    }
    .overlayBox{
      border:1px solid var(--stroke);
      border-radius:14px;
      padding:12px;
      background: rgba(0,0,0,.18);
      margin-bottom:12px;
    }
    .overlaySub{
      font-weight:800;
      margin-bottom:6px;
      font-size:13px;
      opacity:.95;
    }
    .overlayList{
      margin:0;
      padding-left:18px;
      color: var(--muted);
      line-height:1.35;
      font-size:13px;
    }
    .overlayWarn{
      border:1px solid rgba(255,255,255,.14);
      border-radius:14px;
      padding:10px 12px;
      background: rgba(255,64,129,.10);
      margin:0 0 12px;
      font-size:13px;
      color: var(--text);
    }
    .overlayActions{
      display:flex;
      justify-content:flex-end;
      gap:10px;
    }

  </style>
</head>
<body>
  <video id="bgVideo" class="bgVideo" autoplay muted loop playsinline preload="auto" aria-hidden="true">
  <source src="Tetris Images/Background lights.mp4" type="video/mp4" />
  <source src="Background lights.mp4" type="video/mp4" />
</video>
<div class="bgOverlay" aria-hidden="true"></div>

  <div id="startOverlay" class="overlay" role="dialog" aria-modal="true" aria-label="Game instructions">
    <div class="overlayCard">
      <h1 class="overlayTitle">Sentence Order Drop</h1>
      <p class="overlayText">Place the falling 2×2 word blocks so the bottom row spells the sentence in the correct left-to-right order. Only the relative order matters. When the order is correct, the sentence clears and you earn 100 points.</p>
      <div class="overlayBox">
        <div class="overlaySub">Controls</div>
        <ul class="overlayList">
          <li><strong>Buttons:</strong> ◀ / ▶ move, ▼ soft drop, <strong>Drop</strong> = hard drop.</li>
          <li><strong>Touch gestures:</strong> swipe ◀/▶/▼, tap = soft drop, long-press = hard drop.</li>
          <li><strong>Keyboard:</strong> ←/→ move, ↓ soft drop, Space hard drop, P pause.</li>
        </ul>
      </div>
      <div id="portraitNote" class="overlayWarn">On smartphones and tablets, this game must be played in <strong>vertical (portrait)</strong> orientation.</div>
      <div id="rotateNote" class="overlayWarn hidden">Please rotate your device to <strong>portrait</strong> to start.</div>
      <div class="overlayActions">
        <button id="startBtn" type="button">Start</button>
      </div>
    </div>
  </div>

  <div id="rotateOverlay" class="overlay hidden" role="dialog" aria-modal="true" aria-label="Rotate device">
    <div class="overlayCard">
      <h2 class="overlayTitle" style="font-size:20px">Rotate device</h2>
      <p class="overlayText">This game must be played in portrait orientation on smartphones and tablets. Rotate your device to continue.</p>
    </div>
  </div>

  <audio id="bgMusic" loop preload="auto" autoplay>
    <source src="Tetris Images/Background music.mp3" type="audio/mpeg" />
    <source src="Background music.mp3" type="audio/mpeg" />
  </audio>
  <div class="wrap">
    <div class="topbar">
      <div class="stats">
        <div class="pill" id="scorePill">Score: 0</div>
        <div class="pill" id="highPill">High: 0</div>
        <div class="pill" id="roundPill">Round: 1</div>
      </div>

      <div class="diffBar" aria-label="Difficulty selector">
        <button id="diff1Btn" class="diffBtn" type="button" data-diff="1">Difficulty 1</button>
        <button id="diff2Btn" class="diffBtn" type="button" data-diff="2">Difficulty 2</button>
        <button id="diff3Btn" class="diffBtn" type="button" data-diff="3">Difficulty 3</button>
      </div>

      <div class="stats">
        <button id="pauseBtn" type="button">Pause</button>
        <button id="muteBtn" type="button">Mute</button>
        <button id="restartBtn" type="button" class="danger">Restart</button>
      </div>
</div>

    <div class="panel" aria-label="Sentence pieces">
      <div class="row">
        <div class="label">Sentence pieces (random order):</div>
        <div class="chips" id="piecesChips"></div>
      </div>
    </div>

    <div class="stage">
      <div id="prepHint" class="prepHint hidden">Look at the word boxes and think of the correct order.</div>
      <!-- doubled height (16:9 -> 16:18 effective aspect) -->
      <canvas id="game" width="640" height="720" aria-label="Sentence drop game" role="img"></canvas>
    </div>

    <div class="controls" aria-label="Controls">
      <button id="leftBtn" type="button">◀</button>
      <button id="softBtn" type="button">▼</button>
      <button id="rightBtn" type="button">▶</button>
      <button id="dropBtn" type="button" class="wide">Drop</button>
</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const stageEl = document.querySelector('.stage');

  function fitCanvasToStage(){
    if (!stageEl) return;
    const rect = stageEl.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    // Avoid zero-sized canvas during early layout
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if (canvas.width !== w) canvas.width = w;
    if (canvas.height !== h) canvas.height = h;
    recomputeGeometry();
  }


  // ===== Lumines-like visual theme (purely cosmetic) =====
  let tNow = 0;

  // Noise texture (subtle)
  const noiseCanvas = document.createElement('canvas');
  noiseCanvas.width = noiseCanvas.height = 128;
  const nctx = noiseCanvas.getContext('2d', { willReadFrequently: false });
  const nimg = nctx.createImageData(noiseCanvas.width, noiseCanvas.height);
  for (let i = 0; i < nimg.data.length; i += 4) {
    const v = (Math.random() * 255) | 0;
    nimg.data[i] = v;
    nimg.data[i+1] = v;
    nimg.data[i+2] = v;
    nimg.data[i+3] = (Math.random() * 32) | 0; // alpha
  }
  nctx.putImageData(nimg, 0, 0);

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function hexToRgb(hex){
    const h = hex.replace('#','').trim();
    const full = (h.length === 3) ? h.split('').map(ch=>ch+ch).join('') : h;
    const n = parseInt(full, 16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }
  function rgbToHex(r,g,b){
    const to = (v)=> v.toString(16).padStart(2,'0');
    return `#${to(r)}${to(g)}${to(b)}`;
  }
  function shade(hex, amt){ // amt: -1..+1
    const {r,g,b} = hexToRgb(hex);
    const t = amt >= 0 ? 255 : 0;
    const p = Math.abs(amt);
    return rgbToHex(
      (Math.round((t - r) * p) + r) | 0,
      (Math.round((t - g) * p) + g) | 0,
      (Math.round((t - b) * p) + b) | 0
    );
  }

  function drawBackground(){
    // full-canvas animated backplate
    const w = canvas.width, h = canvas.height;
    ctx.save();

    // base gradient
    const g = ctx.createRadialGradient(w*0.2, h*0.15, 0, w*0.55, h*0.6, Math.max(w,h));
    g.addColorStop(0, 'rgba(255,64,129,0.14)');
    g.addColorStop(0.45, 'rgba(0,212,255,0.10)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // equalizer-style bars (subtle, behind playfield)
    ctx.globalAlpha = 0.25;
    ctx.globalCompositeOperation = 'screen';
    const cols = 22;
    const bw = w / cols;
    for (let i = 0; i < cols; i++){
      const phase = (tNow*0.003) + i*0.55;
      const amp = 0.35 + 0.30*Math.sin(phase) + 0.18*Math.sin(phase*0.43);
      const barH = h * clamp01(0.18 + amp);
      const x = i*bw;
      const gg = ctx.createLinearGradient(x, h, x, h-barH);
      gg.addColorStop(0, 'rgba(255,255,255,0)');
      gg.addColorStop(1, 'rgba(255,255,255,0.22)');
      ctx.fillStyle = gg;
      ctx.fillRect(x+1, h-barH, Math.max(1, bw-2), barH);
    }

    // noise overlay
    ctx.globalCompositeOperation = 'overlay';
    ctx.globalAlpha = 0.18;
    const ox = ((tNow*0.03) % noiseCanvas.width) | 0;
    const oy = ((tNow*0.02) % noiseCanvas.height) | 0;
    for (let y = -noiseCanvas.height; y < h + noiseCanvas.height; y += noiseCanvas.height){
      for (let x = -noiseCanvas.width; x < w + noiseCanvas.width; x += noiseCanvas.width){
        ctx.drawImage(noiseCanvas, x-ox, y-oy);
      }
    }

    // scanlines
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = 'rgba(255,255,255,0.10)';
    for (let y = 0; y < h; y += 6){
      ctx.fillRect(0, y, w, 1);
    }

    ctx.restore();
  }

  function drawTimeline(){
    // moving vertical sweep line across the playfield
    const pulse = 0.55 + 0.45*Math.sin(tNow*0.005);
    const x = OFF_X + ((tNow*0.22) % GRID_W);

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.22 + 0.10*pulse;

    const lineW = Math.max(6, CELL * 0.65);
    const gg = ctx.createLinearGradient(x-lineW, 0, x+lineW, 0);
    gg.addColorStop(0, 'rgba(255,255,255,0)');
    gg.addColorStop(0.5, 'rgba(255,255,255,0.55)');
    gg.addColorStop(1, 'rgba(255,255,255,0)');

    ctx.fillStyle = gg;
    ctx.fillRect(x-lineW, OFF_Y, lineW*2, GRID_H);

    // soft bloom around the line
    ctx.globalAlpha = 0.08 + 0.06*pulse;
    ctx.fillRect(x-lineW*2, OFF_Y, lineW*4, GRID_H);

    ctx.restore();
  }

  // ===== Grid: doubled height while keeping width reasonable =====
  // Using 16 columns; 18 rows (double of 9) gives the "double height" feel.
  const COLS = 16;
  const ROWS = 18;

  let CELL = 0;
  let GRID_W = 0;
  let GRID_H = 0;
  let OFF_X = 0;
  let OFF_Y = 0;

  function recomputeGeometry(){
    CELL = Math.floor(Math.min(canvas.width / COLS, canvas.height / ROWS));
    GRID_W = COLS * CELL;
    GRID_H = ROWS * CELL;
    OFF_X = Math.floor((canvas.width - GRID_W) / 2);
    OFF_Y = Math.floor((canvas.height - GRID_H) / 2);
  }

  // Piece size (2x2)
  const PIECE_W = 2;
  const PIECE_H = 2;

  // Bottom strip is the last 2 rows
  const STRIP_TOP = ROWS - PIECE_H;

  // ===== UI =====
  const scorePill = document.getElementById('scorePill');
  const highPill = document.getElementById('highPill');
  const roundPill = document.getElementById('roundPill');
  const pauseBtn = document.getElementById('pauseBtn');
  const muteBtn = document.getElementById('muteBtn');
  const restartBtn = document.getElementById('restartBtn');
  const piecesChips = document.getElementById('piecesChips');
  const startOverlay = document.getElementById('startOverlay');
  const startBtn = document.getElementById('startBtn');
  const rotateOverlay = document.getElementById('rotateOverlay');
  const rotateNote = document.getElementById('rotateNote');

  let hasStarted = false;
  let orientationBlocked = false;

  function isTouchDevice(){
    return (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || window.matchMedia('(pointer: coarse)').matches;
  }
  function isPortrait(){
    return window.matchMedia('(orientation: portrait)').matches || (window.innerHeight >= window.innerWidth);
  }
  function shouldEnforcePortrait(){
    // Enforce portrait only on touch-centric devices (phones/tablets).
    return isTouchDevice();
  }
  function updateOrientationGate(){
    const enforce = shouldEnforcePortrait();
    const ok = !enforce || isPortrait();
    orientationBlocked = !ok;

    if (startOverlay && !hasStarted){
      if (rotateNote) rotateNote.classList.toggle('hidden', ok);
      if (startBtn) startBtn.disabled = !ok;
    }

    if (rotateOverlay){
      rotateOverlay.classList.toggle('hidden', !orientationBlocked || (!hasStarted && !!startOverlay));
    }

    // Freeze/resume gameplay when rotating during play
    if (hasStarted && enforce){
      if (orientationBlocked){
        paused = true;
      } else {
        // Only unpause if the user did not explicitly pause
        // (If pauseBtn shows 'Resume', user paused; do not override.)
        if (pauseBtn && pauseBtn.textContent !== 'Resume'){
          paused = false;
        }
      }
    }
  }

  // ===== Background music (loops) =====
  const bgMusic = document.getElementById('bgMusic');
  let musicStarted = false;

  function updateMuteUI() {
    if (!muteBtn || !bgMusic) return;
    muteBtn.textContent = bgMusic.muted ? 'Unmute' : 'Mute';
  }

  function startMusicIfAllowed() {
    if (!bgMusic || musicStarted) return;
    bgMusic.loop = true;
    bgMusic.volume = 0.35;

    const p = bgMusic.play();
    if (p && typeof p.then === 'function') {
      p.then(() => {
        musicStarted = true;
      }).catch(() => {
        // Autoplay may be blocked until a user gesture.
        musicStarted = false;
      });
    } else {
      // Very old browsers may not return a Promise.
      musicStarted = true;
    }
  }

  // Try to start music as soon as the page has loaded.
  // Note: many browsers block audible autoplay; if that happens, we fall back to muted autoplay
  // and unmute after the first user gesture.
  function startMusicOnLoad() {
    if (!bgMusic) return;
    if (musicStarted) return;

    bgMusic.loop = true;
    bgMusic.volume = 0.35;

    const p = bgMusic.play();
    if (p && typeof p.then === 'function') {
      p.then(() => {
        musicStarted = true;
      }).catch(() => {
        // Fallback: muted autoplay is often allowed.
        bgMusic.muted = true;
        updateMuteUI();

        const p2 = bgMusic.play();
        if (p2 && typeof p2.then === 'function') {
          p2.then(() => {
            musicStarted = true;
          }).catch(() => {
            musicStarted = false;
          });
        }

        const resumeWithSound = () => {
          bgMusic.muted = false;
          updateMuteUI();
          startMusicIfAllowed();
        };

        document.addEventListener('pointerdown', resumeWithSound, { once: true, passive: true });
        document.addEventListener('keydown', resumeWithSound, { once: true });
      });
    } else {
      musicStarted = true;
    }
  }

  function ensureMusicStarted() {
    if (!bgMusic) return;
    if (!bgMusic.muted) startMusicIfAllowed();
  }


  const diffBtns = [
    document.getElementById('diff1Btn'),
    document.getElementById('diff2Btn'),
    document.getElementById('diff3Btn')
  ];

  // ===== Sentences (Difficulty Banks) =====
  // Constraint: the field is 16 columns wide and every word box is 2x2.
  // Therefore, each sentence must not exceed 8 word boxes.

  const DIFFICULTIES = {
    1: {
      label: 'Difficulty 1',
      sentences: [
        'She gave him a book',
        'He bought his sister a gift',
        'I sent my friend a message',
        'They showed us the map',
        'We offered the guest some tea',
        'My mum made me a sandwich',
        'He told her a story',
        'She lent her brother some money',
        'We brought the teacher a card',
        'They gave the child a toy',
        'I wrote my parents a letter',
        'The waiter brought us the bill',
        'She explained the problem to me',
        'He handed the keys to his dad',
        'We sent the photo to our friends',
        'They sold the car to a neighbour'
      ]
    },
    2: {
      label: 'Difficulty 2',
      sentences: [
        'I will see you tomorrow',
        'She met her friend in town yesterday',
        'He works carefully at home',
        'We often play football after school',
        'They studied quietly in the library',
        'I usually get up early on weekdays',
        'She always does her homework in her room',
        'He sometimes eats lunch in the park',
        'We will travel by train next week',
        'They spoke English fluently in class',
        'I read the book slowly at night',
        'She sang loudly at the concert'
      ]
    },
    3: {
      label: 'Difficulty 3',
      sentences: [
        'He never goes to bed late',
        'She does not like coffee',
        'I have already finished my homework',
        'They have just arrived at school',
        'He usually takes the bus to work',
        'She often forgets her keys at home',
        'I do not understand this question',
        'We have always lived in Germany',
        'He cannot speak French very well',
        'She has never been to London',
        'I am interested in science',
        'They hardly ever watch TV at night'
      ]
    }
  };

  let difficulty = 1;
  let highScore = 0;
  const HIGH_KEY_PREFIX = 'sentenceDrop_high_d_';

  // Persistent "Best" score across all difficulties (Fruit-Ninja style)
  let globalHighScore = 0;
  const GLOBAL_HIGH_KEY = 'sentenceDrop_high_global';

  function loadGlobalHighScore() {
    try {
      let v = parseInt(localStorage.getItem(GLOBAL_HIGH_KEY) || '0', 10);
      if (!Number.isFinite(v) || v < 0) v = 0;
      return v;
    } catch {
      return 0;
    }
  }
  function saveGlobalHighScore(value) {
    try {
      localStorage.setItem(GLOBAL_HIGH_KEY, String(value));
    } catch {
      // ignore
    }
  }


  const ARTICLES = new Set(['a','an','the']);

  function normalizeWord(w) {
    return w.replace(/[^\w'-]+/g, '');
  }
  function chunkSentence(raw) {
    const words = raw.trim().split(/\s+/).map(normalizeWord).filter(Boolean);
    const chunks = [];
    for (let i = 0; i < words.length; i++) {
      const w = words[i];
      if (ARTICLES.has(w.toLowerCase()) && i + 1 < words.length) {
        chunks.push(`${w} ${words[i + 1]}`);
        i++;
      } else {
        chunks.push(w);
      }
    }
    return chunks;
  }
  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  const MAX_BOXES = COLS / PIECE_W;
  const sentenceBanks = buildSentenceBanks();
  let lastSentenceIndex = null;

  function buildSentenceBanks() {
    const banks = {};
    for (const [k, cfg] of Object.entries(DIFFICULTIES)) {
      const lvl = Number(k);
      const bank = [];
      for (const raw of cfg.sentences) {
        const chunks = chunkSentence(raw);
        if (chunks.length <= MAX_BOXES) {
          bank.push({ raw, chunks });
        } else {
          console.warn(`[SentenceDrop] Skipping sentence (too long for ${MAX_BOXES} boxes):`, raw, chunks);
        }
      }
      banks[lvl] = bank;
    }
    return banks;
  }

  function pickSentenceEntry() {
    const bank = sentenceBanks[difficulty] || sentenceBanks[1] || [];
    if (bank.length === 0) {
      const raw = 'I have a dog';
      return { raw, chunks: chunkSentence(raw) };
    }
    if (bank.length === 1) return bank[0];

    let idx = (Math.random() * bank.length) | 0;
    if (idx === lastSentenceIndex) idx = (idx + 1) % bank.length;
    lastSentenceIndex = idx;
    return bank[idx];
  }

  function highKey(level) {
    return `${HIGH_KEY_PREFIX}${level}`;
  }
  function loadHighScore(level) {
    // High scores are stored per difficulty.
    // This build removed the previous easiest level and renumbered the remaining levels.
    // To preserve existing user data, attempt to migrate from the former numbering (old = new + 1).
    try {
      let v = parseInt(localStorage.getItem(highKey(level)) || '0', 10);
      if (!Number.isFinite(v) || v < 0) v = 0;

      if (v === 0) {
        const legacyKey = highKey(level + 1);
        const legacyRaw = localStorage.getItem(legacyKey);
        if (legacyRaw !== null) {
          const legacyV = parseInt(legacyRaw || '0', 10);
          if (Number.isFinite(legacyV) && legacyV > 0) v = legacyV;
        }
      }
      return v;
    } catch {
      return 0;
    }
  }
  function saveHighScore(level, value) {
    try {
      localStorage.setItem(highKey(level), String(value));
    } catch {
      // ignore
    }
  }

  function setDifficulty(level, initial = false) {
    const lvl = Number(level);
    difficulty = DIFFICULTIES[lvl] ? lvl : 1;

    // Update active button state
    for (const btn of diffBtns) {
      if (!btn) continue;
      const bd = Number(btn.dataset.diff || '0');
      btn.classList.toggle('active', bd === difficulty);
    }

    highScore = loadHighScore(difficulty);
    // Load / reconcile global best score
    globalHighScore = Math.max(loadGlobalHighScore(), highScore);
    // If difficulty-high is higher than stored global best, persist the higher value.
    saveGlobalHighScore(globalHighScore);
    round = 1;
    score = 0;
    lastSentenceIndex = null;

    // Start the first round only after the player presses Start.
    if (hasStarted) {
      newRound(true);
    } else {
      // Pre-start: clear UI pieces so the instructions are the primary focus.
      if (piecesChips) piecesChips.innerHTML = '';
      updateUI();
    }

    // Prevent accidental scroll-to-top focus jumps on first load
    if (!initial && document.activeElement) document.activeElement.blur();
  }

  // ===== Game state =====

  const emptyRow = () => Array(COLS).fill(0);
  let board;              // board[y][x] = pieceId or 0
  let piecesById;         // id -> {id,text,color,x,y}
  let current;            // active falling piece
  let targetChunks = [];  // correct order (hidden)
  let bag = [];           // remaining pieces to spawn (random order)
  let round = 1;
  let score = 0;

  let dropIntervalMs = 520;
  let acc = 0;
  let lastTs = 0;
  let paused = false;
  let gameOver = false;


  // Round end handling (so the game continues beyond round 1)
  // When a round ends due to failure/blocked/out-of-pieces, we briefly show an overlay,
  // then auto-advance to the next round.
  let roundEnd = null; // {start:number, reason:string}


  // Pre-drop countdown (preparation time before the first piece starts falling)
  let countdown = null; // {start,durationMs,seconds,goFlashMs}

  // Sentence-complete clear animation (Lumines-inspired light burst)
  let clearFx = null; // {start,duration,cells,particles}

  let nextPieceId = 1;

  const COLORS = ["#7c3aed","#22d3ee","#f97316","#10b981","#fb7185","#60a5fa","#facc15","#a78bfa"];
  const GHOST = "rgba(234,241,255,0.18)";

  function hashColor(text) {
    let h = 0;
    for (let i = 0; i < text.length; i++) h = (h * 31 + text.charCodeAt(i)) >>> 0;
    return COLORS[h % COLORS.length];
  }

  function updateUI() {
    // Maintain highscore per difficulty
    if (score > highScore) {
      highScore = score;
      saveHighScore(difficulty, highScore);
    }

    // Maintain global best (across all difficulties)
    if (score > globalHighScore) {
      globalHighScore = score;
      saveGlobalHighScore(globalHighScore);
    } else if (highScore > globalHighScore) {
      // Reconcile if per-difficulty data is higher (e.g. legacy keys)
      globalHighScore = highScore;
      saveGlobalHighScore(globalHighScore);
    }

    scorePill.textContent = `Score: ${score}`;
    if (highPill) highPill.textContent = `High: ${globalHighScore}`;
    roundPill.textContent = `Round: ${round}`;
  }

  function renderChips(arr) {
    piecesChips.innerHTML = "";
    for (const t of arr) {
      const el = document.createElement("div");
      el.className = "chip";
      el.textContent = t;
      piecesChips.appendChild(el);
    }
  }


  const prepHintEl = document.getElementById('prepHint');
  function showPrepHint(show) {
    if (!prepHintEl) return;
    prepHintEl.classList.toggle('hidden', !show);
  }

  function startCountdown(seconds = 5) {
    countdown = {
      start: performance.now(),
      durationMs: seconds * 1000,
      seconds,
      goFlashMs: 350
    };
    showPrepHint(true);
  }

  function beginRoundEnd(reason) {
    // Freeze gameplay, show overlay, then proceed to next round.
    // Keep a copy of the correct solution so it can be shown before the next round starts.
    const solution = (targetChunks && targetChunks.length) ? targetChunks.join(' ') : '';
    // Give users enough time to read the solution; slightly scale with length.
    const delayMs = 1800 + Math.min(2200, solution.length * 45);
    roundEnd = {
      start: tNow || performance.now(),
      reason,
      solution,
      delayMs
    };
    gameOver = true;
    paused = true;
  }

  function countdownRunning(nowTs) {
    if (!countdown) return false;
    const end = countdown.start + countdown.durationMs;
    return nowTs < end;
  }

  function countdownInGoFlash(nowTs) {
    if (!countdown) return false;
    const end = countdown.start + countdown.durationMs;
    const endFlash = end + countdown.goFlashMs;
    return nowTs >= end && nowTs < endFlash;
  }

  function countdownBlocksInput(nowTs) {
    if (!countdown) return false;
    const end = countdown.start + countdown.durationMs + countdown.goFlashMs;
    return nowTs < end;
  }

  function drawCountdownOverlay() {
    if (!countdown) return;

    const now = tNow;
    const end = countdown.start + countdown.durationMs;
    const remainingMs = end - now;

    // Darken playfield
    ctx.save();
    ctx.fillStyle = 'rgba(6,8,16,0.58)';
    ctx.fillRect(OFF_X, OFF_Y, GRID_W, GRID_H);

    let label = null;
    let tFrac = 0;

    if (remainingMs > 0) {
      const remainingSec = Math.ceil(remainingMs / 1000);
      label = String(remainingSec);
      const withinThisSec = (1000 - (remainingMs % 1000)) / 1000; // 0..1
      tFrac = withinThisSec;
    } else {
      // brief GO flash
      const goT = Math.min(1, Math.max(0, (now - end) / countdown.goFlashMs));
      label = 'GO';
      tFrac = goT;
    }

    const centerX = OFF_X + GRID_W / 2;
    const centerY = OFF_Y + GRID_H / 2;

    // Animated scale + glow
    const pop = 0.88 + 0.22 * Math.sin(Math.min(1, tFrac) * Math.PI);
    const alpha = 0.75 + 0.25 * (1 - Math.abs(0.5 - Math.min(1, tFrac)) * 2);

    ctx.globalCompositeOperation = 'screen';
    ctx.shadowColor = 'rgba(34,211,238,0.55)';
    ctx.shadowBlur = 34;
    ctx.globalAlpha = alpha;

    ctx.font = `900 ${Math.round(120 * pop)}px system-ui, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(label, centerX, centerY);

    ctx.restore();
  }

  function newRound(keepScore = true) {
    board = Array.from({ length: ROWS }, emptyRow);
    piecesById = new Map();
    nextPieceId = 1;

    const entry = pickSentenceEntry();
    targetChunks = entry.chunks.slice();        // hidden target order
    bag = shuffle(targetChunks);
    if (bag.join("|") === targetChunks.join("|") && bag.length > 1) bag = shuffle(targetChunks);

    renderChips(bag); // show only shuffled pieces
    paused = false;
    gameOver = false;
    roundEnd = null;
    acc = 0;
    pauseBtn.textContent = "Pause";

    if (!keepScore) score = 0;
    updateUI();

    // Per-round preparation countdown before blocks start to drop.
    current = null;
    startCountdown(5);
  }

  function resetAll() {
    round = 1;
    score = 0;
    newRound(true);
  }

  function restartRound() {
    // Restart the CURRENT round (do not reset back to round 1).
    newRound(true);
  }

  // ===== Mechanics =====
  function newPiece(text) {
    // random horizontal start; keep piece fully inside
    const x = (Math.random() * (COLS - PIECE_W + 1)) | 0;
    return {
      id: nextPieceId++,
      text,
      color: hashColor(text),
      x,
      y: -PIECE_H
    };
  }

  function spawnNext() {
    if (bag.length === 0) {
      // If they didn't solve it with available pieces, end round and continue.
      beginRoundEnd('outOfPieces');
      return;
    }
    const text = bag.shift();
    renderChips(bag);

    const p = newPiece(text);
    piecesById.set(p.id, p);
    current = p;

    if (collides(current, 0, 1)) {
      beginRoundEnd('blocked');
    }
  }

  function collides(piece, dx = 0, dy = 0) {
    const px = piece.x + dx;
    const py = piece.y + dy;
    for (let r = 0; r < PIECE_H; r++) {
      for (let c = 0; c < PIECE_W; c++) {
        const nx = px + c;
        const ny = py + r;
        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
        if (ny >= 0 && board[ny][nx]) return true;
      }
    }
    return false;
  }

  function mergePiece(piece) {
    for (let r = 0; r < PIECE_H; r++) {
      for (let c = 0; c < PIECE_W; c++) {
        const nx = piece.x + c;
        const ny = piece.y + r;
        if (ny >= 0 && ny < ROWS) board[ny][nx] = piece.id;
      }
    }
  }

  function move(dx) {
    if (!hasStarted) return;
    if (paused || gameOver || clearFx || countdownBlocksInput(tNow)) return;
    if (!collides(current, dx, 0)) current.x += dx;
  }

  function softDrop() {
    if (!hasStarted) return;
    if (paused || gameOver || clearFx || countdownBlocksInput(tNow)) return;
    if (!collides(current, 0, 1)) current.y += 1;
    else lockDown();
  }

  function hardDrop() {
    if (!hasStarted) return;
    if (paused || gameOver || clearFx || countdownBlocksInput(tNow)) return;
    let d = 0;
    while (!collides(current, 0, d + 1)) d++;
    current.y += d;
    lockDown();
  }

  function lockDown() {
    mergePiece(current);

    if (current.y < 0) {
      beginRoundEnd('overflow');
      return;
    }

    // Evaluate bottom line condition (relative order anywhere)
    if (sentenceCompleteRelativeOrder()) {
      score += 100;
      updateUI();
      beginSentenceClearFx();
      return;
    }

    spawnNext();
  }

  // ===== Completion check: correct relative order anywhere on bottom strip =====
  function sentenceCompleteRelativeOrder() {
    // Determine correctness by the left-to-right order of distinct piece IDs placed in the bottom strip.
    // The absolute horizontal position does not matter (the first word does NOT need to start at the left edge).

    // Collect counts and x-extents for all piece IDs currently on the board.
    const info = new Map(); // id -> {count, minX, maxX, minY, maxY}
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const id = board[y][x];
        if (!id) continue;
        let it = info.get(id);
        if (!it) {
          it = { count: 0, minX: x, maxX: x, minY: y, maxY: y };
          info.set(id, it);
        }
        it.count += 1;
        if (x < it.minX) it.minX = x;
        if (x > it.maxX) it.maxX = x;
        if (y < it.minY) it.minY = y;
        if (y > it.maxY) it.maxY = y;
      }
    }

    // A valid completion requires that ALL target pieces are fully placed in the bottom strip,
    // and that there are no extra/partial pieces in the strip.
    const placedInStrip = [];

    for (const [id, it] of info.entries()) {
      // Each piece is 2x2 => exactly 4 cells.
      // If a piece is partially in the strip (or partially elsewhere), do not allow completion.
      const touchesStrip = (it.maxY >= STRIP_TOP);
      if (!touchesStrip) continue;

      // Must be a complete 2x2 fully within the strip rows.
      if (it.count !== (PIECE_W * PIECE_H)) return false;
      if (it.minY < STRIP_TOP) return false;

      placedInStrip.push({ id, minX: it.minX });
    }

    // Must have exactly the number of target chunks placed in the strip.
    if (placedInStrip.length !== targetChunks.length) return false;

    // Sort by horizontal position (left-to-right), allowing arbitrary offset.
    placedInStrip.sort((a, b) => a.minX - b.minX);

    for (let i = 0; i < targetChunks.length; i++) {
      const p = piecesById.get(placedInStrip[i].id);
      if (!p || p.text !== targetChunks[i]) return false;
    }

    return true;
  }

  function beginSentenceClearFx() {
    // Capture cells in the bottom strip for a short, flashy clear animation.
    const cells = [];
    for (let y = STRIP_TOP; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const id = board[y][x];
        if (!id) continue;
        const p = piecesById.get(id);
        cells.push({ x, y, color: p ? p.color : '#22d3ee', id });
      }
    }

    // Particles (small light shards)
    const particles = [];
    const makeRand = (seed) => {
      let s = seed >>> 0;
      return () => {
        s = (1664525 * s + 1013904223) >>> 0;
        return (s & 0xffffff) / 0x1000000;
      };
    };

    for (let i = 0; i < cells.length; i++) {
      const c = cells[i];
      const rnd = makeRand(((c.x + 1) * 73856093) ^ ((c.y + 1) * 19349663) ^ ((c.id + 1) * 83492791));
      const cx = OFF_X + (c.x + 0.5) * CELL;
      const cy = OFF_Y + (c.y + 0.5) * CELL;
      const n = 2 + ((rnd() * 3) | 0); // 2..4
      for (let k = 0; k < n; k++) {
        const a = rnd() * Math.PI * 2;
        const sp = 40 + rnd() * 160;
        particles.push({
          x: cx,
          y: cy,
          vx: Math.cos(a) * sp,
          vy: Math.sin(a) * sp - 30,
          color: c.color,
          r: 1.2 + rnd() * 2.4,
          seed: rnd()
        });
      }
    }

    clearFx = {
      start: tNow || performance.now(),
      duration: 650,
      cells,
      particles
    };

    // Freeze gameplay during the clear.
    current = null;
  }

  function clearBottomStrip() {
    for (let y = STRIP_TOP; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) board[y][x] = 0;
    }
  }

  // ===== Drawing =====

  function drawCell(x, y, fill, alphaMul = 1.0) {
    const px = OFF_X + x * CELL;
    const py = OFF_Y + y * CELL;

    // glossy block with glow
    const top = shade(fill, 0.42);
    const mid = fill;
    const bot = shade(fill, -0.30);

    const g = ctx.createLinearGradient(px, py, px + CELL, py + CELL);
    g.addColorStop(0, top);
    g.addColorStop(0.55, mid);
    g.addColorStop(1, bot);

    const pulse = 0.72 + 0.28 * Math.sin(tNow * 0.004 + (x * 0.35) + (y * 0.22));

    ctx.save();
    ctx.shadowColor = fill;
    ctx.shadowBlur = (10 + 10 * pulse) * alphaMul;

    ctx.globalAlpha = 1.0 * alphaMul;
    ctx.fillStyle = g;
    ctx.fillRect(px, py, CELL, CELL);

    // specular highlight
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.30 * alphaMul;
    const hg = ctx.createLinearGradient(px, py, px, py + CELL);
    hg.addColorStop(0, 'rgba(255,255,255,0.55)');
    hg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = hg;
    ctx.fillRect(px + 1, py + 1, CELL - 2, Math.max(2, CELL * 0.45));

    // thin inner border
    ctx.globalAlpha = 0.80 * alphaMul;
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = 1;
    ctx.strokeRect(px + 0.5, py + 0.5, CELL - 1, CELL - 1);

    // subtle outer edge
    ctx.globalAlpha = 0.55 * alphaMul;
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeRect(px + 1.5, py + 1.5, CELL - 3, CELL - 3);

    ctx.restore();
  }

  function drawGrid() {
    // Draw playfield panel (do not clear full canvas; draw() handles that)

    // soft vignette around playfield
    ctx.save();
    const vg = ctx.createRadialGradient(
      OFF_X + GRID_W * 0.5, OFF_Y + GRID_H * 0.4, GRID_W * 0.1,
      OFF_X + GRID_W * 0.5, OFF_Y + GRID_H * 0.6, GRID_W * 0.85
    );
    vg.addColorStop(0, 'rgba(255,255,255,0.05)');
    vg.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = 'rgba(8,16,25,0.35)';
    ctx.fillRect(OFF_X - 6, OFF_Y - 6, GRID_W + 12, GRID_H + 12);

    ctx.globalCompositeOperation = 'overlay';
    ctx.fillStyle = vg;
    ctx.fillRect(OFF_X - 6, OFF_Y - 6, GRID_W + 12, GRID_H + 12);
    ctx.restore();

    // playfield base
    ctx.save();
    ctx.globalAlpha = 0.95;
    const bg = ctx.createLinearGradient(OFF_X, OFF_Y, OFF_X, OFF_Y + GRID_H);
    bg.addColorStop(0, 'rgba(6,10,18,0.80)');
    bg.addColorStop(1, 'rgba(4,6,12,0.78)');
    ctx.fillStyle = bg;
    ctx.fillRect(OFF_X, OFF_Y, GRID_W, GRID_H);

    // grid lines
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(234,241,255,0.07)";
    ctx.lineWidth = 1;
    for (let c = 1; c < COLS; c++) {
      const x = OFF_X + c * CELL + 0.5;
      ctx.beginPath();
      ctx.moveTo(x, OFF_Y);
      ctx.lineTo(x, OFF_Y + GRID_H);
      ctx.stroke();
    }
    for (let r = 1; r < ROWS; r++) {
      const y = OFF_Y + r * CELL + 0.5;
      ctx.beginPath();
      ctx.moveTo(OFF_X, y);
      ctx.lineTo(OFF_X + GRID_W, y);
      ctx.stroke();
    }

    // Bottom strip highlight
    const pulse = 0.55 + 0.45 * Math.sin(tNow * 0.006);
    ctx.globalCompositeOperation = 'screen';
    ctx.fillStyle = `rgba(34,211,238,${0.05 + 0.05 * pulse})`;
    ctx.fillRect(OFF_X, OFF_Y + STRIP_TOP * CELL, GRID_W, PIECE_H * CELL);

    // Slot separators in bottom strip
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = "rgba(234,241,255,0.14)";
    for (let s = 1; s < COLS / PIECE_W; s++) {
      const x = OFF_X + s * PIECE_W * CELL + 0.5;
      ctx.beginPath();
      ctx.moveTo(x, OFF_Y + STRIP_TOP * CELL);
      ctx.lineTo(x, OFF_Y + GRID_H);
      ctx.stroke();
    }

    ctx.restore();
  }

  function ghostY(piece) {
    let d = 0;
    while (!collides(piece, 0, d + 1)) d++;
    return piece.y + d;
  }


  function drawPiece(piece, yOverride = null, alpha = 1.0) {
    const py = (yOverride === null) ? piece.y : yOverride;

    for (let r = 0; r < PIECE_H; r++) {
      for (let c = 0; c < PIECE_W; c++) {
        const x = piece.x + c;
        const y = py + r;
        if (y < 0) continue;
        drawCell(x, y, piece.color, alpha);
      }
    }

    if (py >= 0) {
      const cx = OFF_X + (piece.x + PIECE_W / 2) * CELL;
      const cy = OFF_Y + (py + PIECE_H / 2) * CELL;
      const maxW = PIECE_W * CELL - 8;

      // Larger, resolution-aware text inside the 2×2 word boxes.
      // Starts bigger than before, then shrinks only if needed to fit.
      let fontSize = Math.max(12, Math.floor(CELL * 0.9));
      ctx.font = `800 ${fontSize}px system-ui, sans-serif`;
      while (ctx.measureText(piece.text).width > maxW && fontSize > 12) {
        fontSize -= 1;
        ctx.font = `800 ${fontSize}px system-ui, sans-serif`;
      }

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowColor = "rgba(0,0,0,0.55)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetY = 1;
      ctx.fillStyle = "#ffffff";
      ctx.fillText(piece.text, cx, cy);
      ctx.restore();
    }
  }

  function drawBoard() {
    // cells
    const fxT = clearFx ? Math.min(1, Math.max(0, (tNow - clearFx.start) / clearFx.duration)) : 0;
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const id = board[y][x];
        if (!id) continue;
        const p = piecesById.get(id);
        const alphaMul = (clearFx && y >= STRIP_TOP) ? (1 - fxT) : 1.0;
        drawCell(x, y, p ? p.color : "#4cc9f0", alphaMul);
      }
    }

    // labels: draw on intact 2x2 top-lefts only
    for (let y = 0; y < ROWS - 1; y++) {
      for (let x = 0; x < COLS - 1; x++) {
        const id = board[y][x];
        if (!id) continue;
        if (board[y][x+1] !== id || board[y+1][x] !== id || board[y+1][x+1] !== id) continue;

        // only top-left once
        if (x > 0 && board[y][x-1] === id) continue;
        if (y > 0 && board[y-1][x] === id) continue;

        const p = piecesById.get(id);
        if (!p) continue;

        const cx = OFF_X + (x + 1) * CELL;
        const cy = OFF_Y + (y + 1) * CELL;
        const maxW = PIECE_W * CELL - 8;

        // Larger, resolution-aware text inside placed 2×2 word boxes.
        let fontSize = Math.max(12, Math.floor(CELL * 0.9));
        ctx.font = `800 ${fontSize}px system-ui, sans-serif`;
        while (ctx.measureText(p.text).width > maxW && fontSize > 12) {
          fontSize -= 1;
          ctx.font = `800 ${fontSize}px system-ui, sans-serif`;
        }
        const fxT2 = clearFx ? Math.min(1, Math.max(0, (tNow - clearFx.start) / clearFx.duration)) : 0;
        const aMul = (clearFx && y >= STRIP_TOP) ? (1 - fxT2) : 1.0;
        ctx.save();
        ctx.globalAlpha = aMul;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.55)";
        ctx.shadowBlur = 6;
        ctx.shadowOffsetY = 1;
        ctx.fillStyle = "#ffffff";
        ctx.fillText(p.text, cx, cy);
        ctx.restore();
      }
    }
  }


  function drawClearFx() {
    if (!clearFx) return;

    const t = Math.min(1, Math.max(0, (tNow - clearFx.start) / clearFx.duration));
    const easeOut = 1 - Math.pow(1 - t, 3);
    const inv = 1 - t;

    const stripY = OFF_Y + STRIP_TOP * CELL;
    const stripH = PIECE_H * CELL;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    // Soft full-strip glow
    const baseGlow = 0.18 * Math.sin(Math.min(1, t) * Math.PI);
    const g = ctx.createLinearGradient(OFF_X, stripY, OFF_X + GRID_W, stripY);
    g.addColorStop(0, 'rgba(124,58,237,0)');
    g.addColorStop(0.35, `rgba(34,211,238,${baseGlow})`);
    g.addColorStop(0.65, `rgba(255,64,129,${baseGlow})`);
    g.addColorStop(1, 'rgba(16,185,129,0)');
    ctx.fillStyle = g;
    ctx.fillRect(OFF_X, stripY - 8, GRID_W, stripH + 16);

    // Bright sweep beam left->right
    const beamX = OFF_X + GRID_W * easeOut;
    const beamW = 120;
    const beam = ctx.createLinearGradient(beamX - beamW, 0, beamX + beamW, 0);
    beam.addColorStop(0, 'rgba(255,255,255,0)');
    beam.addColorStop(0.45, `rgba(255,255,255,${0.32 * inv})`);
    beam.addColorStop(0.5, `rgba(34,211,238,${0.48 * inv})`);
    beam.addColorStop(0.55, `rgba(255,64,129,${0.38 * inv})`);
    beam.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = beam;
    ctx.fillRect(beamX - beamW, OFF_Y, beamW * 2, GRID_H);

    // Per-cell bloom
    for (let i = 0; i < clearFx.cells.length; i++) {
      const c = clearFx.cells[i];
      const cx = OFF_X + (c.x + 0.5) * CELL;
      const cy = OFF_Y + (c.y + 0.5) * CELL;
      const r = CELL * (0.7 + 1.8 * t);
      const rg = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
      rg.addColorStop(0, `rgba(255,255,255,${0.22 * inv})`);
      rg.addColorStop(0.25, `${c.color}80`);
      rg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = rg;
      ctx.globalAlpha = 0.55 * inv;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Particles
    ctx.globalAlpha = 1;
    for (let i = 0; i < clearFx.particles.length; i++) {
      const p = clearFx.particles[i];
      const px = p.x + p.vx * t * 0.012;
      const py = p.y + p.vy * t * 0.012 - (t * t * 22);
      const pr = p.r * (0.85 + 0.9 * (1 - t));
      const pg = ctx.createRadialGradient(px, py, 0, px, py, pr * 6);
      pg.addColorStop(0, `rgba(255,255,255,${0.30 * inv})`);
      pg.addColorStop(0.25, `${p.color}cc`);
      pg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = pg;
      ctx.globalAlpha = 0.70 * inv;
      ctx.beginPath();
      ctx.arc(px, py, pr * 6, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.restore();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();

    drawGrid();
    drawBoard();

    if (current && !gameOver) {
      drawPiece(current, ghostY(current), 0.22);
      drawPiece(current);
    }

    drawTimeline();

    drawClearFx();

    if (countdownBlocksInput(tNow)) {
      drawCountdownOverlay();
    }

    if (paused && !gameOver) {
      ctx.fillStyle = "rgba(6,8,16,0.55)";
      ctx.fillRect(OFF_X, OFF_Y, GRID_W, GRID_H);
      ctx.fillStyle = "#eaf1ff";
      ctx.font = "700 22px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Paused", OFF_X + GRID_W / 2, OFF_Y + GRID_H / 2);
    }

    if (gameOver) {
      ctx.fillStyle = "rgba(6,8,16,0.65)";
      ctx.fillRect(OFF_X, OFF_Y, GRID_W, GRID_H);
      ctx.fillStyle = "#eaf1ff";
      ctx.font = "700 22px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const title = (roundEnd && roundEnd.reason === 'outOfPieces') ? "Round failed" :
                    (roundEnd && roundEnd.reason === 'blocked') ? "Blocked" :
                    (roundEnd && roundEnd.reason === 'overflow') ? "Overflow" :
                    "Round ended";
      ctx.fillText(title, OFF_X + GRID_W / 2, OFF_Y + GRID_H / 2 - 10);

      // Show the correct solution before the next round starts (when the user did not solve the round).
      const sol = (roundEnd && roundEnd.solution) ? roundEnd.solution : "";
      if (sol) {
        const maxW = GRID_W - 44;
        const centerX = OFF_X + GRID_W / 2;
        let y = OFF_Y + GRID_H / 2 + 18;

        ctx.font = "700 14px system-ui, sans-serif";
        ctx.fillText("Correct order:", centerX, y);
        y += 18;

        ctx.font = "14px system-ui, sans-serif";
        const words = sol.split(/\s+/).filter(Boolean);
        const lines = [];
        let line = "";
        for (const w of words) {
          const next = line ? (line + " " + w) : w;
          if (ctx.measureText(next).width <= maxW || !line) {
            line = next;
          } else {
            lines.push(line);
            line = w;
          }
        }
        if (line) lines.push(line);
        for (const ln of lines) {
          ctx.fillText(ln, centerX, y);
          y += 18;
        }
        y += 10;

        ctx.font = "14px system-ui, sans-serif";
        ctx.fillText("Next round starting...", centerX, y);
      } else {
        ctx.font = "14px system-ui, sans-serif";
        ctx.fillText("Next round starting...", OFF_X + GRID_W / 2, OFF_Y + GRID_H / 2 + 16);
      }
    }
  }

  // ===== Loop =====
  function tick(ts) {
    tNow = ts;
    const dt = ts - lastTs;
    lastTs = ts;

    // If paused (manual pause or orientation lock), freeze time-based effects.
    if (paused) {
      if (countdown) countdown.start += dt;
      if (roundEnd) roundEnd.start += dt;
      if (clearFx) clearFx.start += dt;
    }

    // Auto-advance after a brief round-end overlay (includes showing the correct solution).
    if (roundEnd && (ts - roundEnd.start) >= (roundEnd.delayMs || 1200)) {
      roundEnd = null;
      round += 1;
      newRound(true);
    }

    if (clearFx && (ts - clearFx.start) >= clearFx.duration) {
      // Finish the clear: reset board and start next sentence.
      clearFx = null;
      clearBottomStrip();
      round += 1;
      newRound(true);
    }

    // Countdown: wait 5 seconds before the first piece starts falling (each round)
    if (countdown) {
      const end = countdown.start + countdown.durationMs;
      const endFlash = end + countdown.goFlashMs;
      if (ts >= endFlash) {
        countdown = null;
        showPrepHint(false);
        acc = 0;
        if (!current && !gameOver) spawnNext();
      }
    }

    if (!paused && !gameOver && !clearFx && !countdownBlocksInput(ts)) {
      acc += dt;
      if (acc >= dropIntervalMs) {
        acc = acc % dropIntervalMs;
        if (!collides(current, 0, 1)) current.y += 1;
        else lockDown();
      }
    }
    draw();
    requestAnimationFrame(tick);
  }

  // ===== Controls =====
  function togglePause() {
    if (gameOver || clearFx || countdownBlocksInput(tNow)) return;
    paused = !paused;
    pauseBtn.textContent = paused ? "Resume" : "Pause";
  }

  window.addEventListener("keydown", (e) => {
    if (e.repeat) return;
    const k = e.key;
    if (k === "ArrowLeft") { e.preventDefault(); move(-1); }
    else if (k === "ArrowRight") { e.preventDefault(); move(1); }
    else if (k === "ArrowDown") { e.preventDefault(); softDrop(); }
    else if (k === " ") { e.preventDefault(); hardDrop(); }
    else if (k.toLowerCase() === "p") { e.preventDefault(); togglePause(); }
  });


  // Mobile buttons: make controls more responsive.
  // - Tap: immediate action
  // - Hold: repeats (left/right) or keeps dropping (down)
  function bindHoldRepeat(btn, stepFn, opts = {}){
    const delay = Number.isFinite(opts.delay) ? opts.delay : 140;     // ms before repeat starts
    const interval = Number.isFinite(opts.interval) ? opts.interval : 55; // ms between repeats
    const accelAfter = Number.isFinite(opts.accelAfter) ? opts.accelAfter : 650;
    const fastInterval = Number.isFinite(opts.fastInterval) ? opts.fastInterval : 35;

    let holdTimer = null;
    let repeatTimer = null;
    let pressedAt = 0;

    const stop = () => {
      if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
      if (repeatTimer) { clearInterval(repeatTimer); repeatTimer = null; }
    };

    const start = (e) => {
      // Prevent page scrolling / text selection on long presses.
      if (e && e.cancelable) e.preventDefault();
      stop();
      pressedAt = performance.now();

      // Immediate response on press.
      stepFn();

      // Start repeating after a short delay.
      holdTimer = setTimeout(() => {
        repeatTimer = setInterval(() => {
          // Acceleration: after ~0.6s, speed up repeats.
          const heldFor = performance.now() - pressedAt;
          stepFn();
          if (heldFor >= accelAfter && interval !== fastInterval) {
            clearInterval(repeatTimer);
            repeatTimer = setInterval(stepFn, fastInterval);
          }
        }, interval);
      }, delay);
    };

    btn.addEventListener('pointerdown', start, { passive:false });
    btn.addEventListener('pointerup', stop);
    btn.addEventListener('pointercancel', stop);
    btn.addEventListener('pointerleave', stop);
    btn.addEventListener('contextmenu', (e) => e.preventDefault());
  }

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const softBtn = document.getElementById('softBtn');
  const dropBtn = document.getElementById('dropBtn');

  // Repeatable movement
  bindHoldRepeat(leftBtn, () => move(-1), { delay: 120, interval: 55, fastInterval: 35 });
  bindHoldRepeat(rightBtn, () => move(1), { delay: 120, interval: 55, fastInterval: 35 });

  // Faster soft drop while holding
  bindHoldRepeat(softBtn, () => softDrop(), { delay: 0, interval: 45, accelAfter: 450, fastInterval: 28 });

  // Hard drop stays single-tap
  dropBtn.addEventListener('click', () => hardDrop());
  pauseBtn.addEventListener("click", () => togglePause());
  if (muteBtn) {
    muteBtn.addEventListener("click", () => {
      if (!bgMusic) return;
      bgMusic.muted = !bgMusic.muted;
      updateMuteUI();
      ensureMusicStarted();
    });
  }
  restartBtn.addEventListener("click", () => restartRound());

  // Start button: hide instructions, enforce portrait (on touch devices), then begin the first round + countdown.
  if (startBtn) {
    startBtn.addEventListener("click", () => {
      if (orientationBlocked) return;
      hasStarted = true;
      if (startOverlay) startOverlay.classList.add('hidden');
      if (rotateOverlay) rotateOverlay.classList.add('hidden');

      // Ensure canvas matches the current viewport before starting.
      fitCanvasToStage();
      updateOrientationGate();

      // Start music on user gesture (if not muted).
      ensureMusicStarted();

      // Start the game at the currently selected difficulty.
      setDifficulty(difficulty, true);

      // Start the animation loop.
      requestAnimationFrame((ts) => { lastTs = ts; requestAnimationFrame(tick); });
    });
  }

  // Try to start music immediately after the game has loaded.
  // If autoplay is blocked, the first user gesture will resume playback.
  if (document.readyState === 'complete') {
    startMusicOnLoad();
  } else {
    window.addEventListener('load', startMusicOnLoad, { once: true });
  }

  // Also attempt to resume music after the first user gesture.
  // If the user has muted the music, do not attempt to start playback.
  document.addEventListener('pointerdown', ensureMusicStarted, { passive: true });
  document.addEventListener('keydown', ensureMusicStarted);

  updateMuteUI();


  // Difficulty selector
  for (const btn of diffBtns) {
    if (!btn) continue;
    btn.addEventListener('click', () => setDifficulty(btn.dataset.diff));
  }

  // Touch: swipe L/R/D, tap = soft drop, long-press = hard drop
  let tStart = null;
  let longPressTimer = null;
  const SWIPE_MIN = 22;
  const SWIPE_TIME = 450;
  const LONG_PRESS = 420;

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    tStart = { x: e.clientX, y: e.clientY, t: performance.now(), moved: false };

    clearTimeout(longPressTimer);
    longPressTimer = setTimeout(() => {
      if (tStart && !tStart.moved) hardDrop();
    }, LONG_PRESS);
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!tStart) return;
    const dx = e.clientX - tStart.x;
    const dy = e.clientY - tStart.y;
    if (Math.abs(dx) > 6 || Math.abs(dy) > 6) tStart.moved = true;
  });

  canvas.addEventListener("pointerup", (e) => {
    clearTimeout(longPressTimer);
    if (!tStart) return;

    const dx = e.clientX - tStart.x;
    const dy = e.clientY - tStart.y;
    const dt = performance.now() - tStart.t;

    // tap: soft drop
    if (Math.abs(dx) < 10 && Math.abs(dy) < 10 && dt < 250) {
      softDrop();
      tStart = null;
      return;
    }

    if (dt <= SWIPE_TIME) {
      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) >= SWIPE_MIN) {
        move(dx > 0 ? 1 : -1);
      } else if (Math.abs(dy) > Math.abs(dx) && dy >= SWIPE_MIN) {
        softDrop();
      }
    }
    tStart = null;
  });

  canvas.addEventListener("pointercancel", () => {
    clearTimeout(longPressTimer);
    tStart = null;
  });

  // Reduce double-tap zoom on some browsers
  let lastTouchEnd = 0;
  document.addEventListener("touchend", (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, { passive: false });

  // ===== Start =====
  // Initialize UI (difficulty, layout) but do not start gameplay until Start is pressed.
  setDifficulty(1, true);
  fitCanvasToStage();
  updateOrientationGate();

  window.addEventListener('resize', () => {
    fitCanvasToStage();
    updateOrientationGate();
  }, { passive: true });
  window.addEventListener('orientationchange', () => {
    setTimeout(() => {
      fitCanvasToStage();
      updateOrientationGate();
    }, 120);
  });
})();
</script>
</body>
</html>
