<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Sentence Order Drop (shuffled only, tall field)</title>
  <style>

    :root{ color-scheme: dark; --bg0:#05060a; --bg1:#070b14; --panel:#0b1020; --panel2:#0a0f1a; --stroke:rgba(255,255,255,.10); --stroke2:rgba(255,255,255,.14); --text:#eaf1ff; --muted:rgba(234,241,255,.78); }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      display:grid;
      place-items:center;
      min-height:100vh;
      padding:12px;
      box-sizing:border-box;
      background:
        radial-gradient(1200px 600px at 20% 20%, rgba(121,40,202,.22), transparent 55%),
        radial-gradient(900px 600px at 80% 30%, rgba(0,212,255,.18), transparent 60%),
        radial-gradient(900px 800px at 60% 85%, rgba(0,255,153,.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position:fixed;
      inset:-20%;
      pointer-events:none;
      background:
        conic-gradient(from 180deg at 50% 50%, rgba(255,64,129,.12), rgba(0,212,255,.10), rgba(0,255,153,.10), rgba(255,64,129,.12));
      filter: blur(60px);
      opacity:.55;
      animation: drift 14s linear infinite;
      transform: translate3d(0,0,0);
      mix-blend-mode: screen;
    }
    body::after{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background: repeating-linear-gradient(180deg, rgba(255,255,255,.035) 0px, rgba(255,255,255,.035) 1px, transparent 3px, transparent 6px);
      opacity:.35;
      mix-blend-mode: overlay;
    }
    @keyframes drift{ from{ transform: translate3d(-2%, -1%, 0) rotate(0deg);} to{ transform: translate3d(2%, 1%, 0) rotate(360deg);} }

    .wrap{ width:min(900px,100%); display:grid; gap:10px; }
    .topbar{ display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .stats{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .pill{
      background: linear-gradient(180deg, rgba(17,26,46,.80), rgba(10,14,28,.78));
      border:1px solid var(--stroke);
      border-radius:999px;
      padding:7px 12px;
      font-size:14px;
      line-height:1;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 26px rgba(0,0,0,.32);
    }

    .stage{
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      background: linear-gradient(180deg, rgba(10,14,28,.65), rgba(6,8,16,.55));
      overflow:hidden;
      box-shadow:
        0 20px 60px rgba(0,0,0,.55),
        0 0 0 1px rgba(255,255,255,.03) inset;
      position:relative;
    }
    .stage::before{
      content:"";
      position:absolute;
      inset:-2px;
      pointer-events:none;
      border-radius:18px;
      background: radial-gradient(600px 260px at 50% 0%, rgba(255,255,255,.10), transparent 60%);
      opacity:.8;
      mix-blend-mode: overlay;
    }
    canvas{ width:100%; height:auto; display:block; touch-action:none; }

    .panel{
      display:grid;
      gap:8px;
      padding:12px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(14,20,40,.72), rgba(10,14,28,.62));
      border-radius:16px;
      backdrop-filter: blur(10px);
      box-shadow: 0 14px 40px rgba(0,0,0,.40);
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .label{ opacity:.92; font-size:13px; color:var(--muted); }
    .chips{ display:flex; gap:8px; flex-wrap:wrap; }

    .chip{
      border:1px solid var(--stroke2);
      background: linear-gradient(180deg, rgba(18,26,48,.78), rgba(9,12,24,.72));
      border-radius:999px;
      padding:5px 12px;
      font-size:13px;
      white-space:nowrap;
      box-shadow: 0 10px 22px rgba(0,0,0,.28);
    }

    .controls{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; user-select:none; -webkit-user-select:none; }

    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(18,26,48,.86), rgba(9,12,24,.78));
      color:var(--text);
      border-radius:16px;
      padding:12px 10px;
      font-size:16px;
      font-weight:650;
      letter-spacing:.2px;
      box-shadow:
        0 14px 34px rgba(0,0,0,.45),
        0 0 0 1px rgba(255,255,255,.04) inset;
      position:relative;
      overflow:hidden;
    }
    button::before{
      content:"";
      position:absolute;
      inset:-30% -40%;
      background: radial-gradient(260px 120px at 30% 30%, rgba(0,212,255,.22), transparent 55%),
                  radial-gradient(260px 120px at 70% 70%, rgba(255,64,129,.18), transparent 55%);
      opacity:.9;
      filter: blur(10px);
      transform: translate3d(0,0,0);
      mix-blend-mode: screen;
    }
    button span, button{ isolation:isolate; }
    button:active{ transform:translateY(1px); }
    .wide{ grid-column: span 3; }
    .danger{ border-color: rgba(255,64,129,.28); }

    .hint{ font-size:12px; opacity:.86; line-height:1.35; color:var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="stats">
        <div class="pill" id="scorePill">Score: 0</div>
        <div class="pill" id="roundPill">Round: 1</div>
      </div>
      <div class="stats">
        <button id="pauseBtn" type="button">Pause</button>
        <button id="restartBtn" type="button" class="danger">Restart</button>
      </div>
    </div>

    <div class="panel" aria-label="Sentence pieces">
      <div class="row">
        <div class="label">Sentence pieces (random order):</div>
        <div class="chips" id="piecesChips"></div>
      </div>
      <div class="hint">
        Place the falling blocks so that the bottom line contains the pieces in the correct order (left-to-right).
        The pieces may start anywhere on the bottom line; only the relative order matters.
        When correct, the sentence clears and you earn 100 points.
      </div>
    </div>

    <div class="stage">
      <!-- doubled height (16:9 -> 16:18 effective aspect) -->
      <canvas id="game" width="640" height="720" aria-label="Sentence drop game" role="img"></canvas>
    </div>

    <div class="controls" aria-label="Controls">
      <button id="leftBtn" type="button">◀</button>
      <button id="softBtn" type="button">▼</button>
      <button id="rightBtn" type="button">▶</button>
      <button id="dropBtn" type="button" class="wide">Drop</button>
      <button id="helpBtn" type="button" class="wide">
        Touch: swipe ◀/▶/▼, tap = soft drop, long-press = hard drop
      </button>
    </div>

    <div class="hint">
      Keyboard: ←/→ move, ↓ soft drop, Space hard drop, P pause.
      Blocks are fixed 2×2 (no rotation). Article + noun are kept together (e.g., “a dog”).
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');


  // ===== Lumines-like visual theme (purely cosmetic) =====
  let tNow = 0;

  // Noise texture (subtle)
  const noiseCanvas = document.createElement('canvas');
  noiseCanvas.width = noiseCanvas.height = 128;
  const nctx = noiseCanvas.getContext('2d', { willReadFrequently: false });
  const nimg = nctx.createImageData(noiseCanvas.width, noiseCanvas.height);
  for (let i = 0; i < nimg.data.length; i += 4) {
    const v = (Math.random() * 255) | 0;
    nimg.data[i] = v;
    nimg.data[i+1] = v;
    nimg.data[i+2] = v;
    nimg.data[i+3] = (Math.random() * 32) | 0; // alpha
  }
  nctx.putImageData(nimg, 0, 0);

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function hexToRgb(hex){
    const h = hex.replace('#','').trim();
    const full = (h.length === 3) ? h.split('').map(ch=>ch+ch).join('') : h;
    const n = parseInt(full, 16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }
  function rgbToHex(r,g,b){
    const to = (v)=> v.toString(16).padStart(2,'0');
    return `#${to(r)}${to(g)}${to(b)}`;
  }
  function shade(hex, amt){ // amt: -1..+1
    const {r,g,b} = hexToRgb(hex);
    const t = amt >= 0 ? 255 : 0;
    const p = Math.abs(amt);
    return rgbToHex(
      (Math.round((t - r) * p) + r) | 0,
      (Math.round((t - g) * p) + g) | 0,
      (Math.round((t - b) * p) + b) | 0
    );
  }

  function drawBackground(){
    // full-canvas animated backplate
    const w = canvas.width, h = canvas.height;
    ctx.save();

    // base gradient
    const g = ctx.createRadialGradient(w*0.2, h*0.15, 0, w*0.55, h*0.6, Math.max(w,h));
    g.addColorStop(0, 'rgba(255,64,129,0.14)');
    g.addColorStop(0.45, 'rgba(0,212,255,0.10)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // equalizer-style bars (subtle, behind playfield)
    ctx.globalAlpha = 0.25;
    ctx.globalCompositeOperation = 'screen';
    const cols = 22;
    const bw = w / cols;
    for (let i = 0; i < cols; i++){
      const phase = (tNow*0.003) + i*0.55;
      const amp = 0.35 + 0.30*Math.sin(phase) + 0.18*Math.sin(phase*0.43);
      const barH = h * clamp01(0.18 + amp);
      const x = i*bw;
      const gg = ctx.createLinearGradient(x, h, x, h-barH);
      gg.addColorStop(0, 'rgba(255,255,255,0)');
      gg.addColorStop(1, 'rgba(255,255,255,0.22)');
      ctx.fillStyle = gg;
      ctx.fillRect(x+1, h-barH, Math.max(1, bw-2), barH);
    }

    // noise overlay
    ctx.globalCompositeOperation = 'overlay';
    ctx.globalAlpha = 0.18;
    const ox = ((tNow*0.03) % noiseCanvas.width) | 0;
    const oy = ((tNow*0.02) % noiseCanvas.height) | 0;
    for (let y = -noiseCanvas.height; y < h + noiseCanvas.height; y += noiseCanvas.height){
      for (let x = -noiseCanvas.width; x < w + noiseCanvas.width; x += noiseCanvas.width){
        ctx.drawImage(noiseCanvas, x-ox, y-oy);
      }
    }

    // scanlines
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = 'rgba(255,255,255,0.10)';
    for (let y = 0; y < h; y += 6){
      ctx.fillRect(0, y, w, 1);
    }

    ctx.restore();
  }

  function drawTimeline(){
    // moving vertical sweep line across the playfield
    const pulse = 0.55 + 0.45*Math.sin(tNow*0.005);
    const x = OFF_X + ((tNow*0.22) % GRID_W);

    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.22 + 0.10*pulse;

    const lineW = Math.max(6, CELL * 0.65);
    const gg = ctx.createLinearGradient(x-lineW, 0, x+lineW, 0);
    gg.addColorStop(0, 'rgba(255,255,255,0)');
    gg.addColorStop(0.5, 'rgba(255,255,255,0.55)');
    gg.addColorStop(1, 'rgba(255,255,255,0)');

    ctx.fillStyle = gg;
    ctx.fillRect(x-lineW, OFF_Y, lineW*2, GRID_H);

    // soft bloom around the line
    ctx.globalAlpha = 0.08 + 0.06*pulse;
    ctx.fillRect(x-lineW*2, OFF_Y, lineW*4, GRID_H);

    ctx.restore();
  }

  // ===== Grid: doubled height while keeping width reasonable =====
  // Using 16 columns; 18 rows (double of 9) gives the "double height" feel.
  const COLS = 16;
  const ROWS = 18;

  const CELL = Math.floor(Math.min(canvas.width / COLS, canvas.height / ROWS));
  const GRID_W = COLS * CELL;
  const GRID_H = ROWS * CELL;
  const OFF_X = Math.floor((canvas.width - GRID_W) / 2);
  const OFF_Y = Math.floor((canvas.height - GRID_H) / 2);

  // Piece size (2x2)
  const PIECE_W = 2;
  const PIECE_H = 2;

  // Bottom strip is the last 2 rows
  const STRIP_TOP = ROWS - PIECE_H;

  // ===== UI =====
  const scorePill = document.getElementById('scorePill');
  const roundPill = document.getElementById('roundPill');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const piecesChips = document.getElementById('piecesChips');

  // ===== Sentences =====
  const RAW_SENTENCES = [
    "I have a dog",
    "She likes the pizza",
    "We play football",
    "They have an apple",
    "He reads a book",
    "My sister has the red pen"
  ];
  const ARTICLES = new Set(["a","an","the"]);

  function normalizeWord(w) {
    return w.replace(/[^\w'-]+/g, "");
  }
  function chunkSentence(raw) {
    const words = raw.trim().split(/\s+/).map(normalizeWord).filter(Boolean);
    const chunks = [];
    for (let i = 0; i < words.length; i++) {
      const w = words[i];
      if (ARTICLES.has(w.toLowerCase()) && i + 1 < words.length) {
        chunks.push(`${w} ${words[i + 1]}`);
        i++;
      } else {
        chunks.push(w);
      }
    }
    return chunks;
  }
  function shuffle(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // ===== Game state =====
  const emptyRow = () => Array(COLS).fill(0);
  let board;              // board[y][x] = pieceId or 0
  let piecesById;         // id -> {id,text,color,x,y}
  let current;            // active falling piece
  let targetChunks = [];  // correct order (hidden)
  let bag = [];           // remaining pieces to spawn (random order)
  let round = 1;
  let score = 0;

  let dropIntervalMs = 520;
  let acc = 0;
  let lastTs = 0;
  let paused = false;
  let gameOver = false;

  let nextPieceId = 1;

  const COLORS = ["#7c3aed","#22d3ee","#f97316","#10b981","#fb7185","#60a5fa","#facc15","#a78bfa"];
  const GHOST = "rgba(234,241,255,0.18)";

  function hashColor(text) {
    let h = 0;
    for (let i = 0; i < text.length; i++) h = (h * 31 + text.charCodeAt(i)) >>> 0;
    return COLORS[h % COLORS.length];
  }

  function updateUI() {
    scorePill.textContent = `Score: ${score}`;
    roundPill.textContent = `Round: ${round}`;
  }

  function renderChips(arr) {
    piecesChips.innerHTML = "";
    for (const t of arr) {
      const el = document.createElement("div");
      el.className = "chip";
      el.textContent = t;
      piecesChips.appendChild(el);
    }
  }

  function newRound(keepScore = true) {
    board = Array.from({ length: ROWS }, emptyRow);
    piecesById = new Map();
    nextPieceId = 1;

    const raw = RAW_SENTENCES[(round - 1) % RAW_SENTENCES.length];
    targetChunks = chunkSentence(raw);        // hidden target order
    bag = shuffle(targetChunks);
    if (bag.join("|") === targetChunks.join("|") && bag.length > 1) bag = shuffle(targetChunks);

    renderChips(bag); // show only shuffled pieces
    paused = false;
    gameOver = false;
    acc = 0;
    pauseBtn.textContent = "Pause";

    if (!keepScore) score = 0;
    updateUI();

    spawnNext();
  }

  function resetAll() {
    round = 1;
    score = 0;
    newRound(true);
  }

  // ===== Mechanics =====
  function newPiece(text) {
    // random horizontal start; keep piece fully inside
    const x = (Math.random() * (COLS - PIECE_W + 1)) | 0;
    return {
      id: nextPieceId++,
      text,
      color: hashColor(text),
      x,
      y: -PIECE_H
    };
  }

  function spawnNext() {
    if (bag.length === 0) {
      // If they didn't solve it with available pieces, end round
      gameOver = true;
      paused = true;
      pauseBtn.textContent = "No more pieces";
      return;
    }
    const text = bag.shift();
    renderChips(bag);

    const p = newPiece(text);
    piecesById.set(p.id, p);
    current = p;

    if (collides(current, 0, 1)) {
      gameOver = true;
      paused = true;
      pauseBtn.textContent = "Blocked";
    }
  }

  function collides(piece, dx = 0, dy = 0) {
    const px = piece.x + dx;
    const py = piece.y + dy;
    for (let r = 0; r < PIECE_H; r++) {
      for (let c = 0; c < PIECE_W; c++) {
        const nx = px + c;
        const ny = py + r;
        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
        if (ny >= 0 && board[ny][nx]) return true;
      }
    }
    return false;
  }

  function mergePiece(piece) {
    for (let r = 0; r < PIECE_H; r++) {
      for (let c = 0; c < PIECE_W; c++) {
        const nx = piece.x + c;
        const ny = piece.y + r;
        if (ny >= 0 && ny < ROWS) board[ny][nx] = piece.id;
      }
    }
  }

  function move(dx) {
    if (paused || gameOver) return;
    if (!collides(current, dx, 0)) current.x += dx;
  }

  function softDrop() {
    if (paused || gameOver) return;
    if (!collides(current, 0, 1)) current.y += 1;
    else lockDown();
  }

  function hardDrop() {
    if (paused || gameOver) return;
    let d = 0;
    while (!collides(current, 0, d + 1)) d++;
    current.y += d;
    lockDown();
  }

  function lockDown() {
    mergePiece(current);

    if (current.y < 0) {
      gameOver = true;
      paused = true;
      pauseBtn.textContent = "Overflow";
      return;
    }

    // Evaluate bottom line condition (relative order anywhere)
    if (sentenceCompleteRelativeOrder()) {
      score += 100;
      updateUI();
      clearBottomStrip();
      // Start next sentence immediately
      round += 1;
      newRound(true);
      return;
    }

    spawnNext();
  }

  // ===== Completion check: correct relative order anywhere on bottom strip =====
  function getStripSlots() {
    // Each slot is 2 columns wide; we read left->right
    const slots = [];
    const slotCount = Math.floor(COLS / PIECE_W); // 8 for 16 cols
    for (let s = 0; s < slotCount; s++) {
      const x0 = s * PIECE_W;
      const y0 = STRIP_TOP;

      const id00 = board[y0][x0];
      const id01 = board[y0][x0 + 1];
      const id10 = board[y0 + 1][x0];
      const id11 = board[y0 + 1][x0 + 1];

      const filled = id00 && id01 && id10 && id11 && (id00 === id01 && id00 === id10 && id00 === id11);
      slots.push(filled ? id00 : 0);
    }
    return slots;
  }

  function sentenceCompleteRelativeOrder() {
    const slots = getStripSlots();                 // e.g. [0, id, id, 0, id, ...]
    const texts = slots
      .filter(id => id !== 0)
      .map(id => (piecesById.get(id) ? piecesById.get(id).text : null))
      .filter(Boolean);

    // Must place exactly all pieces (no duplicates, no missing) into the bottom strip.
    // Then: their left-to-right order must equal the hidden targetChunks.
    if (texts.length !== targetChunks.length) return false;

    for (let i = 0; i < targetChunks.length; i++) {
      if (texts[i] !== targetChunks[i]) return false;
    }
    return true;
  }

  function clearBottomStrip() {
    for (let y = STRIP_TOP; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) board[y][x] = 0;
    }
  }

  // ===== Drawing =====
  function drawCell(x, y, fill) {
    const px = OFF_X + x * CELL;
    const py = OFF_Y + y * CELL;

    // glossy block with glow
    const top = shade(fill, 0.42);
    const mid = fill;
    const bot = shade(fill, -0.30);

    const g = ctx.createLinearGradient(px, py, px + CELL, py + CELL);
    g.addColorStop(0, top);
    g.addColorStop(0.55, mid);
    g.addColorStop(1, bot);

    const pulse = 0.72 + 0.28 * Math.sin(tNow * 0.004 + (x * 0.35) + (y * 0.22));

    ctx.save();
    ctx.shadowColor = fill;
    ctx.shadowBlur = 10 + 10 * pulse;
    ctx.fillStyle = g;
    ctx.fillRect(px, py, CELL, CELL);

    // specular highlight
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.30;
    const hg = ctx.createLinearGradient(px, py, px, py + CELL);
    hg.addColorStop(0, 'rgba(255,255,255,0.55)');
    hg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = hg;
    ctx.fillRect(px + 1, py + 1, CELL - 2, Math.max(2, CELL * 0.45));

    // thin inner border
    ctx.globalAlpha = 0.80;
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = 1;
    ctx.strokeRect(px + 0.5, py + 0.5, CELL - 1, CELL - 1);

    // subtle outer edge
    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeRect(px + 1.5, py + 1.5, CELL - 3, CELL - 3);

    ctx.restore();
  }

  function drawGrid() {
    // Draw playfield panel (do not clear full canvas; draw() handles that)

    // soft vignette around playfield
    ctx.save();
    const vg = ctx.createRadialGradient(
      OFF_X + GRID_W * 0.5, OFF_Y + GRID_H * 0.4, GRID_W * 0.1,
      OFF_X + GRID_W * 0.5, OFF_Y + GRID_H * 0.6, GRID_W * 0.85
    );
    vg.addColorStop(0, 'rgba(255,255,255,0.05)');
    vg.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = 'rgba(8,16,25,0.35)';
    ctx.fillRect(OFF_X - 6, OFF_Y - 6, GRID_W + 12, GRID_H + 12);

    ctx.globalCompositeOperation = 'overlay';
    ctx.fillStyle = vg;
    ctx.fillRect(OFF_X - 6, OFF_Y - 6, GRID_W + 12, GRID_H + 12);
    ctx.restore();

    // playfield base
    ctx.save();
    ctx.globalAlpha = 0.95;
    const bg = ctx.createLinearGradient(OFF_X, OFF_Y, OFF_X, OFF_Y + GRID_H);
    bg.addColorStop(0, 'rgba(6,10,18,0.80)');
    bg.addColorStop(1, 'rgba(4,6,12,0.78)');
    ctx.fillStyle = bg;
    ctx.fillRect(OFF_X, OFF_Y, GRID_W, GRID_H);

    // grid lines
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(234,241,255,0.07)";
    ctx.lineWidth = 1;
    for (let c = 1; c < COLS; c++) {
      const x = OFF_X + c * CELL + 0.5;
      ctx.beginPath();
      ctx.moveTo(x, OFF_Y);
      ctx.lineTo(x, OFF_Y + GRID_H);
      ctx.stroke();
    }
    for (let r = 1; r < ROWS; r++) {
      const y = OFF_Y + r * CELL + 0.5;
      ctx.beginPath();
      ctx.moveTo(OFF_X, y);
      ctx.lineTo(OFF_X + GRID_W, y);
      ctx.stroke();
    }

    // Bottom strip highlight
    const pulse = 0.55 + 0.45 * Math.sin(tNow * 0.006);
    ctx.globalCompositeOperation = 'screen';
    ctx.fillStyle = `rgba(34,211,238,${0.05 + 0.05 * pulse})`;
    ctx.fillRect(OFF_X, OFF_Y + STRIP_TOP * CELL, GRID_W, PIECE_H * CELL);

    // Slot separators in bottom strip
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = "rgba(234,241,255,0.14)";
    for (let s = 1; s < COLS / PIECE_W; s++) {
      const x = OFF_X + s * PIECE_W * CELL + 0.5;
      ctx.beginPath();
      ctx.moveTo(x, OFF_Y + STRIP_TOP * CELL);
      ctx.lineTo(x, OFF_Y + GRID_H);
      ctx.stroke();
    }

    ctx.restore();
  }

  function ghostY(piece) {
    let d = 0;
    while (!collides(piece, 0, d + 1)) d++;
    return piece.y + d;
  }

  function drawPiece(piece, yOverride = null, alpha = 1.0) {
    const py = (yOverride === null) ? piece.y : yOverride;

    for (let r = 0; r < PIECE_H; r++) {
      for (let c = 0; c < PIECE_W; c++) {
        const x = piece.x + c;
        const y = py + r;
        if (y < 0) continue;
        ctx.globalAlpha = alpha;
        drawCell(x, y, piece.color);
      }
    }
    ctx.globalAlpha = 1.0;

    if (py >= 0) {
      const cx = OFF_X + (piece.x + PIECE_W / 2) * CELL;
      const cy = OFF_Y + (py + PIECE_H / 2) * CELL;
      const maxW = PIECE_W * CELL - 8;

      let fontSize = 16;
      ctx.font = `600 ${fontSize}px system-ui, sans-serif`;
      while (ctx.measureText(piece.text).width > maxW && fontSize > 10) {
        fontSize -= 1;
        ctx.font = `600 ${fontSize}px system-ui, sans-serif`;
      }

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(11,15,20,0.92)";
      ctx.fillText(piece.text, cx, cy);
    }
  }

  function drawBoard() {
    // cells
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const id = board[y][x];
        if (!id) continue;
        const p = piecesById.get(id);
        drawCell(x, y, p ? p.color : "#4cc9f0");
      }
    }

    // labels: draw on intact 2x2 top-lefts only
    for (let y = 0; y < ROWS - 1; y++) {
      for (let x = 0; x < COLS - 1; x++) {
        const id = board[y][x];
        if (!id) continue;
        if (board[y][x+1] !== id || board[y+1][x] !== id || board[y+1][x+1] !== id) continue;

        // only top-left once
        if (x > 0 && board[y][x-1] === id) continue;
        if (y > 0 && board[y-1][x] === id) continue;

        const p = piecesById.get(id);
        if (!p) continue;

        const cx = OFF_X + (x + 1) * CELL;
        const cy = OFF_Y + (y + 1) * CELL;
        const maxW = PIECE_W * CELL - 8;

        let fontSize = 16;
        ctx.font = `600 ${fontSize}px system-ui, sans-serif`;
        while (ctx.measureText(p.text).width > maxW && fontSize > 10) {
          fontSize -= 1;
          ctx.font = `600 ${fontSize}px system-ui, sans-serif`;
        }
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(11,15,20,0.92)";
        ctx.fillText(p.text, cx, cy);
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();

    drawGrid();
    drawBoard();

    if (current && !gameOver) {
      drawPiece(current, ghostY(current), 0.22);
      drawPiece(current);
    }

    drawTimeline();

    if (paused && !gameOver) {
      ctx.fillStyle = "rgba(6,8,16,0.55)";
      ctx.fillRect(OFF_X, OFF_Y, GRID_W, GRID_H);
      ctx.fillStyle = "#eaf1ff";
      ctx.font = "700 22px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Paused", OFF_X + GRID_W / 2, OFF_Y + GRID_H / 2);
    }

    if (gameOver) {
      ctx.fillStyle = "rgba(6,8,16,0.65)";
      ctx.fillRect(OFF_X, OFF_Y, GRID_W, GRID_H);
      ctx.fillStyle = "#eaf1ff";
      ctx.font = "700 22px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Round ended", OFF_X + GRID_W / 2, OFF_Y + GRID_H / 2 - 10);
      ctx.font = "14px system-ui, sans-serif";
      ctx.fillText("Press Restart to start over", OFF_X + GRID_W / 2, OFF_Y + GRID_H / 2 + 16);
    }
  }

  // ===== Loop =====
  function tick(ts) {
    tNow = ts;
    const dt = ts - lastTs;
    lastTs = ts;

    if (!paused && !gameOver) {
      acc += dt;
      if (acc >= dropIntervalMs) {
        acc = acc % dropIntervalMs;
        if (!collides(current, 0, 1)) current.y += 1;
        else lockDown();
      }
    }
    draw();
    requestAnimationFrame(tick);
  }

  // ===== Controls =====
  function togglePause() {
    if (gameOver) return;
    paused = !paused;
    pauseBtn.textContent = paused ? "Resume" : "Pause";
  }

  window.addEventListener("keydown", (e) => {
    if (e.repeat) return;
    const k = e.key;
    if (k === "ArrowLeft") { e.preventDefault(); move(-1); }
    else if (k === "ArrowRight") { e.preventDefault(); move(1); }
    else if (k === "ArrowDown") { e.preventDefault(); softDrop(); }
    else if (k === " ") { e.preventDefault(); hardDrop(); }
    else if (k.toLowerCase() === "p") { e.preventDefault(); togglePause(); }
  });

  document.getElementById("leftBtn").addEventListener("click", () => move(-1));
  document.getElementById("rightBtn").addEventListener("click", () => move(1));
  document.getElementById("softBtn").addEventListener("click", () => softDrop());
  document.getElementById("dropBtn").addEventListener("click", () => hardDrop());
  pauseBtn.addEventListener("click", () => togglePause());
  restartBtn.addEventListener("click", () => resetAll());

  // Touch: swipe L/R/D, tap = soft drop, long-press = hard drop
  let tStart = null;
  let longPressTimer = null;
  const SWIPE_MIN = 22;
  const SWIPE_TIME = 450;
  const LONG_PRESS = 420;

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    tStart = { x: e.clientX, y: e.clientY, t: performance.now(), moved: false };

    clearTimeout(longPressTimer);
    longPressTimer = setTimeout(() => {
      if (tStart && !tStart.moved) hardDrop();
    }, LONG_PRESS);
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!tStart) return;
    const dx = e.clientX - tStart.x;
    const dy = e.clientY - tStart.y;
    if (Math.abs(dx) > 6 || Math.abs(dy) > 6) tStart.moved = true;
  });

  canvas.addEventListener("pointerup", (e) => {
    clearTimeout(longPressTimer);
    if (!tStart) return;

    const dx = e.clientX - tStart.x;
    const dy = e.clientY - tStart.y;
    const dt = performance.now() - tStart.t;

    // tap: soft drop
    if (Math.abs(dx) < 10 && Math.abs(dy) < 10 && dt < 250) {
      softDrop();
      tStart = null;
      return;
    }

    if (dt <= SWIPE_TIME) {
      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) >= SWIPE_MIN) {
        move(dx > 0 ? 1 : -1);
      } else if (Math.abs(dy) > Math.abs(dx) && dy >= SWIPE_MIN) {
        softDrop();
      }
    }
    tStart = null;
  });

  canvas.addEventListener("pointercancel", () => {
    clearTimeout(longPressTimer);
    tStart = null;
  });

  // Reduce double-tap zoom on some browsers
  let lastTouchEnd = 0;
  document.addEventListener("touchend", (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, { passive: false });

  // ===== Start =====
  updateUI();
  newRound(true);
  requestAnimationFrame((ts) => { lastTs = ts; requestAnimationFrame(tick); });
})();
</script>
</body>
</html>
